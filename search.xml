<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOSP Introduction</title>
    <url>/2025/03/11/AOSP-Introduction/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><span id="more"></span>
<h2 id="For-Raspi5"><a href="#For-Raspi5" class="headerlink" title="For Raspi5"></a>For Raspi5</h2>]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Bash 使用简明笔记</title>
    <url>/2022/04/14/Bash%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%8E%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>&emsp;&emsp;Shell的最佳之处在于书写小型脚本非常自然快捷，而复杂的shell脚本经常出现可移植问题，因其依赖大量可能不具有跨平台性的辅助命令。现在，负责的胶合层程序几乎都由Perl和Python来完成，shell只是为最简单的包装器和系统初始化脚本而保留。—— 《Unix编程艺术》</p>
</blockquote>
<span id="more"></span>
<h3 id="bash的执行循环"><a href="#bash的执行循环" class="headerlink" title="bash的执行循环"></a>bash的执行循环</h3><ul>
<li>a. 获得输入：文件、命令行或者shell终端</li>
<li>b. 词法解析：获得操作符和单词，解析引用和别名</li>
<li>c. 命令解析：将b中token解析为单个或者组合命令</li>
<li>d. 执行shell扩展</li>
<li>e. 处理必要的重定向</li>
<li>f. 执行命令</li>
<li>g. 可选地等待命令完成并获得其退出状态</li>
</ul>
<p><strong>login shell读取的配置文件：</strong></p>
<ul>
<li>a. <code>/etc/profile</code> 全局配置，它会读入<code>/etc/bash.bashrc</code></li>
<li>b. <code>~/.bash_profile</code>或<code>~/.bash_rc</code>或<code>~/.bash_login</code> 个人设定</li>
<li>c. <code>/etc/inputrc</code> bash的热键设定，比如[tab]键禁止Beep.</li>
<li>d. <code>/etc/profile.d/*.sh</code> 规范了bash操作接口的补全、颜色、语系，一些命令的别名等</li>
</ul>
<h3 id="字符串引用（quoting）"><a href="#字符串引用（quoting）" class="headerlink" title="字符串引用（quoting）"></a>字符串引用（quoting）</h3><ul>
<li>转义字符：</li>
<li>单引号：保留字符值</li>
<li>双引号：保留字符值，除了 ‘$’、‘&#96;’、‘\‘，！（历史扩展功能被打开后）</li>
<li>ANSI-C引用：\a、\b、\e、\n、\r、\t、&#39;、&quot;、\?、\nnn（八进制）、\xHH、\uHHHH（Unicode16）、\uHHHHHHHH（Unicode32）、\cx（控制x字符）</li>
</ul>
<h3 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h3><p><strong>简单命令</strong></p>
<ul>
<li>管道： | 或者 |&amp; , “|&amp;” 等价于 “2&gt;&amp;1 |”，将标准错误重定向到标准输出并一起通过管道连接到下一条命令的标准输入。管道里的所有命令都会在单独进程中运行，最后一条命令的退出状态作为整个pipeline的退出状态。</li>
<li>time 保留字</li>
<li>命令序列：&amp;&amp;、||、；、&amp;、newline  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newcomand || newcommand2 &amp;&amp; newcommand3</span><br><span class="line">newcomand ; newcomand2 ; newcomand3</span><br><span class="line"># 注意控制结构中‘;’分割符的使用，使用该分隔符可以获得更紧凑的代码，</span><br><span class="line"># 不需要分行编写代码</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>控制结构和复杂命令</strong></p>
<ul>
<li>until循环  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">until test-commands; do consequent-commands; done</span><br></pre></td></tr></table></figure></li>
<li>while循环  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while test-commands; do consequent-commands; done</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while IFS= read -r x; do</span><br><span class="line">    do-something1 &quot;$x&quot; &quot;config-$x&quot;</span><br><span class="line">    do-something2 &lt; &quot;$x&quot;</span><br><span class="line">done &lt; file | process-output</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>for 循环  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for [ [in [words …] ] ; ] do commands; done</span><br><span class="line">#  words或被扩展</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 类似于C语言</span><br><span class="line">for (( expr1 ; expr2 ; expr3 )) ; do commands ; done</span><br></pre></td></tr></table></figure></li>
<li>if 语句  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if test-commands; then</span><br><span class="line">  consequent-commands;</span><br><span class="line">[elif more-test-commands; then</span><br><span class="line">  more-consequents;]</span><br><span class="line">[else alternate-consequents;]</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li>case 语句  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case word in</span><br><span class="line">    [ [(] pattern [| pattern]…) command-list ;;]…</span><br><span class="line">esac</span><br><span class="line"># * 类似与else，如果前面所有的case项没有选中，则选中该项</span><br><span class="line"># ;; 会终止执行匹配项后剩余的待匹配项</span><br><span class="line"># ;&amp; 会继续执行下一个(如果有的话)case项的命令</span><br><span class="line"># ;;&amp; 会继续匹配剩下的case项</span><br></pre></td></tr></table></figure></li>
<li>select 语句  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成选择菜单</span><br><span class="line">select name [in words …]; do commands; done</span><br></pre></td></tr></table></figure></li>
<li>((expression)) 语句</li>
</ul>
<p>&emsp;&emsp;执行算术表达式，等价于 let “expression”，如果表达式非0，退出状态为0；否则，退出状态为1。</p>
<ul>
<li>[[expression]] 语句</li>
</ul>
<p>&emsp;&emsp;如果条件表达式非0，退出状态为0；否则，退出状态为1。<strong>该语句与((…))都可以作为if结构的谓词判断部分。</strong>不支持字符分列和文件名扩展，支持 <code>~</code> 扩展、参数和变量扩展、算术扩展、命令扩展、过程扩展、去除引用。&#x3D;&#x3D;、!&#x3D;使用时右边的操作元为模式（pattern），<strong>pattern的任何部分都可能加引号。</strong> &#x3D;~ 操作符可以用于扩展正则表达式的模式匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[ $line =~ [[:space:]]*(a)?b ]]</span><br><span class="line"></span><br><span class="line">    pattern=&#x27;[[:space:]]*(a)?b&#x27;</span><br><span class="line">    [[ $line =~ $pattern ]]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>( list ) 命令组语句<br>&emsp;&emsp; 将一组命令在一个子shell环境中执行，这与管道组成的pipeline不同。重定向会应用到该组所有的命令，输出也会重定向到一个流中去。特别注意的是，在括号中的变量赋值是没有意义的，因为子shell完成退出后，其中所有的变量都不会保留。</p>
</li>
<li><p>{ list; } 命令组语句<br>&emsp;&emsp; 与（）不同的是，该组命令会在当前shell环境中执行，而不是在新建的子shell环境中。 <strong>{}为保留字，所以其必须与命令用元符号（如空格）分开；（）为操作符，其不必要与命令分开。</strong></p>
</li>
<li><p>coprocess 语句</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">coproc [NAME] command [redirections]</span><br></pre></td></tr></table></figure></li>
<li><p>并发语句<br>&emsp;&emsp;并发特性不是bash内部的特性，而是依靠外部工具来实现。GNU Parallel提供了这样的特性。parallel可用于替代xargs。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &#x27;*.html&#x27; -print | parallel gzip    </span><br><span class="line">parallel -j 10 &lt; file</span><br></pre></td></tr></table></figure>
</li>
<li><p>function 函数语句</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fname () compound-command [ redirections ]</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fname [()] compound-command [ redirections ]</span><br></pre></td></tr></table></figure>
<p>‘#’ 变量被用来存放参数的个数；‘0’ 变量存放第一个参数即函数名，后面的数字变量依次存放剩余的参数（大于10的参数应使用{}）。local参数设置局部变量，变量的作用域是定义它的代码块以及被该代码块调用的子函数。unset可以取消变量定义。declare或者typeset列出当前环境所有变量名，-f参数只列出函数名。（参考SICP中的环境模型）</p>
</li>
</ul>
<h3 id="Shell参数"><a href="#Shell参数" class="headerlink" title="Shell参数"></a>Shell参数</h3><p>&emsp;&emsp;变量赋值：<code>name=[value]</code> 注意：<strong>变量不但有值而且有0或多个属性。</strong> 赋值语句可以作为 declare、typeset、alias、export、readonly和local的参数。<br>+&#x3D; 操作符 可以扩充变量。<code>name+=[value]</code>,例如对PATH环境变量经常会如此操作。<br><strong>名字引用</strong>：<code>declare -n ref=$1</code> 出现对ref操作的任何地方都会实际操作$1。<br><strong>位置参数</strong>： $N 或 ${N}（当N大于10时）<br><strong>特殊参数</strong>：<br>* : 被展开为参数列表，从1开始；<br>@ ：被展开为参数列表，从1开始；<br># ：参数个数；<br>? ：最近执行的前端pipeline的退出状态<br>$ ：当前进程ID，在（）子shell中，它展开为调用shell的ID，而不是子shell的ID。<br>! ：最近放入后端执行的进程ID。<br>0 ：shell或者shell脚本的名字。<br>_ ：shell执行外部命令时的命令全名。</p>
<h3 id="Shell展开"><a href="#Shell展开" class="headerlink" title="Shell展开"></a>Shell展开</h3><p>&emsp;&emsp;参考 <a href="https://www.cnblogs.com/alongdidi/p/bash_parameter_expansion.html?msclkid=5a4c1d10bbd311ec956a01a248c11a83">Shell参数展开-博客园</a></p>
<ul>
<li><p>{}展开：<code>mkdir /usr/local/src/bash/&#123;old,new,dist,bugs&#125;</code></p>
</li>
<li><p>~展开：~：HOME； ~+ ：PWD，~- ：OLDPWD ； ~N：被替换为‘dirs +N’</p>
</li>
<li><p><strong>参数展开</strong>：<br>基本格式：<code>$&#123;parameters&#125;</code><br>其他格式：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;parameter:-word&#125;</span><br><span class="line">$&#123;paramater:=word&#125;</span><br><span class="line">$&#123;paramater:?word&#125;</span><br><span class="line">$&#123;paramater:+word&#125;</span><br></pre></td></tr></table></figure>
<p><strong>索引子字符串展开</strong>: <code>$&#123;paramater:offset:length&#125;</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ string=01234567890abcdefgh </span><br><span class="line">$ echo $&#123;string:7&#125;</span><br><span class="line">7890abcdefgh</span><br><span class="line">$ echo $&#123;string:7:2&#125;</span><br><span class="line">78</span><br><span class="line">$ array[0]=01234567890abcdefgh</span><br><span class="line">$ echo $&#123;array[0]:7&#125;</span><br><span class="line">7890abcdefgh</span><br><span class="line">$ set -- 1 2 3 4 5 6 7 8 9 0 a b c d e f g h</span><br><span class="line">$ echo $&#123;@:7&#125;</span><br><span class="line">7 8 9 0 a b c d e f g h</span><br><span class="line">$ array=(0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h)</span><br><span class="line">$ echo $&#123;array[@]:7&#125;</span><br><span class="line">7 8 9 0 a b c d e f g h</span><br></pre></td></tr></table></figure>
<p><strong>模式匹配子字符串展开</strong>:<br><code>$&#123;变量#关键词&#125;</code> 若变量从头开始的数据匹配关键词，则将匹配的最 <strong>短</strong> 数据删除<br><code>$&#123;变量##关键词&#125;</code> 若变量从头开始的数据匹配关键词，则将匹配的最 <strong>长</strong> 数据删除<br><code>$&#123;变量%关键词&#125;</code> 若变量从尾向头开始的数据匹配关键词，则将匹配的最 <strong>短</strong> 数据删除<br><code>$&#123;变量%%关键词&#125;</code> 若变量从尾向头开始的数据匹配关键词，则将匹配的最 <strong>长</strong> 数据删除</p>
<p><strong>查找替换展开</strong>:<br><code>$&#123;变量/旧字符串/新字符串&#125;</code> 若变量内容匹配旧字符串，则<strong>第一个匹配</strong>的旧字符串会被新字符串取代。<br><code>$&#123;变量//旧字符串/新字符串&#125;</code>  若变量内容匹配旧字符串，则<strong>全部</strong>旧字符串会被新字符串取代。</p>
</li>
<li><p><strong>命令展开</strong>：<code>$(command)</code>或者 <code>&quot;``command``&quot;</code></p>
</li>
<li><p><strong>算术展开</strong>：<code>$(( expression ))</code></p>
</li>
<li><p><strong>进程替换</strong>： <code>&lt;(list)</code>或者<code>&gt;(list)</code>，(list)执行的结果会存到一个文件中，该文件然后被作为重定向的目标。</p>
</li>
<li><p><strong>字符分列</strong>：将<code>IFS</code>设置为分隔符号，参考 <a href="https://www.w3cschool.cn/bashshell/bashshell-ws3n37lg.html?msclkid=bb6af889bbd611ec9dce49c765f91cf2">Bash拆分字符串</a></p>
</li>
<li><p><strong>文件名展开</strong>：模式匹配</p>
</li>
<li><p>Quote Removal</p>
</li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li><code>&lt;&lt;&lt;</code> 从字符串重定向</li>
</ul>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>&emsp;&emsp;任何命令的执行都必须有上下文<strong>环境</strong>。环境中主要是key-value对，包括变量、打开文件描述符、重定向描述符等。内部命令、函数执行时不会生成子shell环境，而其他命令的执行会生成子shell环境。子shell环境继承了部分或者全部父环境的内容，在子shell环境中的操作不会影响父环境。<br>&emsp;&emsp;退出状态：命令如果终止于一个信号N，退出状态会被shell设置为128+N。127表示命令没找到，126表示命令找到但没有执行，1表示一般性错误，2表示错误的shell命令。<br>&emsp;&emsp;信号</p>
<h3 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h3><ul>
<li><code>: [arguments]</code> 参数扩展和重定向</li>
<li><code>. filename [arguments]</code> 执行命令  基本上和source命令等价</li>
<li><code>break[n]</code>、<code>cd </code>、<code>continue [n]</code></li>
<li><code>eval [arguments]</code> 参数被合并成命令，然后载入执行。</li>
<li><code>exec [-cl] [-a name] [command [arguments]]</code> 如果支持command命令，则代替shell执行，而不是在创建的新的进程中执行，这与普通命令不同。</li>
<li><code>exit [n]</code> 以状态码n退出。</li>
<li><code>export [-fn] [-p] [name[=value]]</code> 标记name可以在子进程环境中可见。-f选项表示name是函数，否则name表示变量。</li>
<li><code>getopts optstring name [arg...]</code></li>
<li><code>hash [-r] [-p filename] [-dt] [name]</code> 建立命令路径的hash映射，加快搜索效率。</li>
<li><code>pwd [-LP]</code> 、<code>return [n]</code></li>
<li><code>readonly [-aAf] [-p] [name[=value]]</code> 标记name只读</li>
<li><code>shift [n]</code> 对位置参数的编码向左移位n位</li>
<li><code>test expr</code> 或 <code>[ expr</code>  执行条件表达式expr；当使用<code>[</code>格式时，命令的最后一个参数必须是<code>]</code>。表达式可以使用操作符进行组合，这些操作符包括<code>!</code>、<code>()</code>、<code>expr1 -a expr2</code>(<code>逻辑与</code>)、<code>expr1 -o expr2</code>(<code>逻辑或</code>)</li>
<li><code>times</code></li>
<li><code>trap [-lp] [arg] [sigspec...]</code> 绑定信号处理函数</li>
<li><code>umask [-p] [-S] mode</code> 设置文件创建掩码</li>
<li><code>unset [-fnv] [name]</code> 从环境中去除name符号</li>
<li><code>alias [-p] [name[=value] ...]</code> 设置别名</li>
<li><code>bind [-m keymap] ...</code> Readline绑定（bash专用）</li>
<li><code>builtin [shell-builtin [args]]</code> 运行shell-builtin命令，在定义与内置命令有着相同名字的函数中，该命令可以重新获得原来内置命令的功能。</li>
<li><code>caller [expr]</code> 返回当前激活的子程序调用的内容。</li>
<li><code>command [-pVv] command [arguments …]</code> 执行非函数类命令</li>
<li><code>declare [-aAfFgiIlnrtux] [-p] [name[=value] …]</code>声明变量和设置变量属性，例如只读、调试跟踪、名字引用、大小写转换、整数、数组。</li>
<li><code>echo [-neE] [arg ...]</code></li>
<li><code>enable [-a] [-dnps] [-f filename] [name ...]</code>enable或者disable内置shell命令，使用-n选项代表disable。</li>
<li><code>help [-dms] [pattern]</code>获取内置命令帮助信息</li>
<li><code>let expression [expression …]</code>使表达式可以进行算术运算</li>
<li><code>local [option] name[=value] …</code></li>
<li><code>logout [n]</code></li>
<li><code>mapfile</code> 从标准输入或者文件描述符生成索引数组</li>
<li><code>printf [-v var] format [arguments]</code>格式化输出</li>
<li><code>read -ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]</code> 从标准输入或者文件描述符读入一行</li>
<li><code>readarray -d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]</code> 从标准输入或者文件描述符读入一行到索引数组</li>
<li><code>source filename</code></li>
<li><code>type [-afptP] [name …]</code> 输出命令的类型</li>
<li><code>typeset</code> 兼容Korn Shell，等价于<code>declare</code></li>
<li><code>ulimit</code> 设置资源限制</li>
<li><code>unalias [-a] [name … ]</code> 去除别名</li>
<li><code>set</code></li>
<li><code>shopt</code></li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul>
<li><code>CDPATH</code>、<code>HOME</code>、<code>IFS</code>、<code>MAIL</code>、<code>MAILPATH</code>、<code>PATH</code>、<code>PS1</code>、<code>PS2</code>、<code>BASH*</code>、<code>BASH_*</code>、<code>COMP_*</code>、<code>EUID</code>、<code>HIST*</code>(<code>与历史记录有关</code>)</li>
<li><code>PS1</code>的设定：<code>\d</code>(日期)、<code>\H</code>(主机名)、<code>\h</code>(反取主机名在第一个小数点之前的名字)、<code>\t</code>(显示24小时格式时间)、<code>\T</code>或<code>\A</code>或<code>\@</code>(显示12小时格式的时间)、<code>\u</code>(当前用户名称)、<code>\v</code>(Bash版本号)、<code>\w</code>(完整工作目录名称)、<code>\W</code>(显示最后一个目录名)、<code>\#</code>(下达的第n个指令)、<code>\$</code>(提示字符)</li>
</ul>
<h3 id="Bash特性"><a href="#Bash特性" class="headerlink" title="Bash特性"></a>Bash特性</h3><p><strong>条件表达式:</strong></p>
<ul>
<li><code>-a|-b|-c|-d|-e|-f|-g|-h|-k|-p|-r|-s|-t|-u|-w|-x|-G|-L|-N|-O|-S| file</code> 文件判断单元操作符</li>
<li><code>file1 -ef file2</code> file2和file1是否引用相同的节点</li>
<li><code>file1 -nt file2</code> file1的修改时间更新或者file1存在,file2不存在。</li>
<li><code>file1 -ot file2</code> file1的修改时间更旧或者file2存在,file1不存在。</li>
<li><code>-v varname</code> 变量varname是否被设置</li>
<li><code>-z string</code> 字符串长度是否为0</li>
<li><code>-n string</code>或<code>string</code> 字符串长度是否非0</li>
<li><code>string1 == string2</code> 或 <code>string1=string2</code> 或 <code>string1 != string2</code></li>
<li><code>string1 &gt; string2</code> 或 <code>string1 &lt; string2</code></li>
<li><code>arg1 Op arg2</code> : <code>Op</code>可以是 <code>-eq</code>、<code>-ne</code>、<code>-lt</code>、<code>-le</code>、<code>-gt</code>、<code>-ge</code>算法比较<br><strong>算术：</strong>使用<code>let</code>或者<code>(())</code>或者<code>declare -i</code></li>
<li><code>id++</code>、<code>id--</code>、<code>++id</code>、<code>--id</code>、<code>+ - ! ~ ** * / % &gt;&gt; &lt;&lt; &lt;= &gt;= &lt; &gt; == !=  &amp; ^ | &amp;&amp; || expr1?expr2:expr3  </code><br><strong>数组</strong>：</li>
<li><code>name[subscript]=value</code> 自动生成索引数组，subscript可以是数字或表达式</li>
<li><code>declare -a name</code></li>
<li><code>name=(value1 value2 … )</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=&quot;ds,fds,fd,wq,daw&quot;</span><br><span class="line">IFS=&quot;,&quot;</span><br><span class="line">array=($name) # 自动将name根据&#x27;,&#x27;号进行分列。</span><br></pre></td></tr></table></figure>
<strong>目录栈</strong>：</li>
<li><code>dirs [-clpv] [+N | -N]</code></li>
<li><code>pushd [-n] [+N | -N | dir]</code></li>
<li><code>popd [-n] [+N | -N]</code><br><strong>提示符设置：</strong></li>
<li><code>\a</code> Bell、<code>\d</code> date、<code>\h</code>或<code>\H </code>主机名、<code>请输入代码</code><br><strong>各种其他模式</strong>：</li>
<li><code>rbash</code> 严格模式</li>
<li><code>bash --posix</code> posix模式</li>
<li>兼容模式</li>
</ul>
<h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p>&emsp;&emsp;作业控制与操作系统的进程控制有关。操作系统会引入终端组进程ID的概念，组ID为当前终端进程ID的组可以接收终端信号；而后端运行的组则会对信号免疫。<code>Ctrl-z</code>会导致当前前端运行的进程停止并将控制返回给bash；</p>
<ul>
<li><code>bg [jobspec...]</code></li>
<li><code>fg [jobspec ...]</code></li>
<li><code>jobs [-lnprs] [jobspec] 或 jobs -x command [arguments]</code></li>
<li><code>kill</code></li>
<li><code>wait [-fn] [-p varname] [jobspec or pid …]</code></li>
<li><code>disown [-ar] [-h] [jobspec … | pid … ]</code></li>
<li><code>suspend [-f]</code></li>
</ul>
<h3 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h3><ul>
<li><p><code>fc</code></p>
</li>
<li><p><code>history</code></p>
</li>
<li><p><code>!!</code>重复执行前个命令</p>
</li>
<li><p><code>!n</code> 执行第n个命令</p>
</li>
</ul>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>BuildRoot工具介绍</title>
    <url>/2025/02/28/BuildRoot%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://buildroot.org/">Buildroot</a> 是一个可以快速制作 Linux 系统（包括内核、rootfs、bootloader等）的工具，并支持交叉编译，它与 <a href="/2021/04/05/LFS-0-LFS-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" title="LFS 0: LFS 项目介绍">[LFS 项目]</a> 类似。</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Buildroot 所依赖的宿主 Linux 系统上的软件包（包括编译工具链等）、工具等参考<a href="https://buildroot.org/downloads/manual/manual.html#_getting_started">Buildroot 官方文档</a></p>
<h2 id="构建-Buildroot"><a href="#构建-Buildroot" class="headerlink" title="构建 Buildroot"></a>构建 Buildroot</h2><h3 id="下载源码包"><a href="#下载源码包" class="headerlink" title="下载源码包"></a>下载源码包</h3>]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Birthday Attack for Hash Function Analysis</title>
    <url>/2024/12/19/Birthday-Attack-for-Hash-Function-Analysis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>生日攻击</code>是一种密码学攻击手段，它常用于攻击<code>弱散列函数</code>，因为它不具有抗强碰撞性。生日攻击源于概率论中的<code>生日问题</code>。</p>
<span id="more"></span>

<h2 id="生日悖论问题"><a href="#生日悖论问题" class="headerlink" title="生日悖论问题"></a>生日悖论问题</h2><p><code>生日悖论（Birthday Paradox）</code>可以表述为：不少于 23 个人中至少有两人生日相同的概率大于 50%。这个数学事实非常反直觉，因为这个概率比人们想象的要高得多。</p>
<p>假设有 n 个人，那么至少有两个人生日相同的概率可以使用下面的公式计算：<br>$$ P(n) &#x3D; 1 - \frac {365!} {(365-n)! * {365} ^ n} $$</p>
<p>这个公式可以通过计算逆问题得到：计算 n 个人中没有两个人生日相同的概率 P’。 P’ 的计算很容易使用排列组合公式获得：<br>$$ P’ &#x3D; \frac { A_{365} ^ n } { 365 ^ n } &#x3D; \frac {365!} {(365 - n)! * {365 ^ n}} $$</p>
<p>然后 $ P &#x3D; 1 - P’ $。</p>
<p>当 n &#x3D; 23 时，$ P \approx 50 % $<br>当 n &#x3D; 30 时，$ P \approx 70 % $<br>当 n &#x3D; 40 时，$ P \approx 90 % $<br>当 n &#x3D; 50 时，$ P \approx 97 % $</p>
<p>生日悖论普遍应用于检测散列函数：N bit 的散列函数可能发生的碰撞测试次数不是 $ 2 ^ N $ 而是 $ 2 ^ {N &#x2F; 2} $。</p>
<h2 id="生日攻击"><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h2><p>生日攻击一般应用在数字签名中。数字签名通常首先对消息明文计算 HASH ，然后对这个 HASH 进行签名。为了抵御生日攻击，需要规定签名方案所使用的散列函数的输出长度足够大，以使生日攻击在计算上不可行。</p>
<h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>上节中的公式可以进一步推导成一般性的、便于计算的形式。<br>根据泰勒公式，指数函数 $ e^x $ 可以用多项式展开：<br>$$ e^x &#x3D; \sum_{k&#x3D;0}^\infty\frac{x^k}{k!} &#x3D; 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + \frac{x^4}{24} + … $$</p>
<p>如果 x 是一个极小的值，那么可以得到下面的近似公式：<br>$$ e^x \approx 1 + x $$</p>
<p>现在将生日问题中的 $ \frac{1}{365} $ 代入: $ e^{-\frac{1}{365}} \approx 1 - \frac{1}{365} $</p>
<p>因此，生日问题的概率公式，可以转化为：<br>$$\begin{align}<br>P’ &amp;\approx 1 \cdot e^{-\frac{1}{365}} \cdot e^{-\frac{2}{365}} … \cdot e^{-\frac{n-1}{365}} \\<br>&amp;&#x3D; e ^ {- \frac{n(n-1)&#x2F;2}{365}} \\<br>&amp;&#x3D; e ^ {- \frac{n(n-1)}{730}}\\<br>\end{align}$$</p>
<p>所以：<br>$$ P &#x3D; 1 - P’ \approx 1 - e ^ {- \frac{n(n-1)}{730}} $$</p>
<p>假设 d 为 取消空间（在生日问题中 d &#x3D; 365），就可以得到一般化公式：<br>$$ P(n,d) \approx 1 - e ^ {- \frac{n(n-1)}{2d}} $$</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>CMake 构建工具介绍</title>
    <url>/2022/11/29/CMake-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <a href="http://cmake.org/">CMake</a> 是跨平台的编译、构建工具，它主要被设计为各种<code>Ｍakefile</code>方言的<strong>生成器</strong>。CMake 可以生成各种编译系统，例如 <code>Ninja</code>，也可以生成各种 IDE 的工程文件，例如 <code>Visual Studio</code> 和 <code>Xcode</code>。<br>&emsp;&emsp; Cmake 被广泛用于 C&#x2F;C++ 语言，但也可以构建使用其他语言的源代码。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://cmake.org/documentation/">CMake - Documentation</a> 文档。<br>参考 <a href="https://github.com/Akagi201/learning-cmake/blob/master/docs/mastering-cmake.pdf">Mastering CMake: A Cross-Platform Build System</a> By Ken Martin &amp; Bill Hoffman</p>
</blockquote>
<h2 id="为什么使用-CMake"><a href="#为什么使用-CMake" class="headerlink" title="为什么使用 CMake"></a>为什么使用 CMake</h2><h3 id="MakeFile-的问题"><a href="#MakeFile-的问题" class="headerlink" title="MakeFile 的问题"></a>MakeFile 的问题</h3><ul>
<li>对于比较复杂庞大的软件系统，手写 MakeFile 过于复杂繁琐，维护困难。</li>
<li>与平台环境耦合性强，跨平台性不足</li>
</ul>
<h3 id="为什么不使用-Autoconf"><a href="#为什么不使用-Autoconf" class="headerlink" title="为什么不使用 Autoconf"></a>为什么不使用 Autoconf</h3><h3 id="为什么不使用-JAM，qmake，SCons-或者-ANT"><a href="#为什么不使用-JAM，qmake，SCons-或者-ANT" class="headerlink" title="为什么不使用 JAM，qmake，SCons 或者 ANT"></a>为什么不使用 JAM，qmake，SCons 或者 ANT</h3><h3 id="为什么不使用脚本"><a href="#为什么不使用脚本" class="headerlink" title="为什么不使用脚本"></a>为什么不使用脚本</h3><h2 id="CMake-的特性"><a href="#CMake-的特性" class="headerlink" title="CMake 的特性"></a>CMake 的特性</h2><p><strong>使用 CMake 与直接编写 Makefile 相比到底有哪些优势呢？</strong><br>CMake 是 Makefile 生成器，它包含了大部分关于 Makefile 的知识，而直接掌握这些知识需要一段时间（可能很长）经验的积累。</p>
<ul>
<li><strong>跨平台性</strong>：同一个源代码工程可以构建到不同的平台，从 Android，iOS 到高性能计算平台（包括构建、打包、安装和测试）。</li>
<li><strong>高效率</strong>：CMake 可以描述复杂工程各子模块的精确依赖关系（支持并行构建），并进行最小化构建。</li>
<li><strong>外部构建</strong>(out-of-source build)：在单独的构建目录中存放临时文件，不影响源代码目录。</li>
<li><strong>以目标（target）为中心的方法论</strong>：</li>
<li><strong>支持多种后端（生成器）</strong>：CMake 支持生成多种构建工具脚本，包括 Visual Studio，Xcode，ninja，make 和 VSCode。  </li>
<li><strong>自定义命令</strong>：可以自定义命令去生成文件，或者完成用户自定义的任务。</li>
<li><strong>可复用性强</strong>: CMake可以从构建中导出和导入目标，以允许重用软件。</li>
<li><strong>组件化&#x2F;模块化</strong>：</li>
<li>支持多种构建模式</li>
</ul>
<h2 id="CMake-构建系统"><a href="#CMake-构建系统" class="headerlink" title="CMake 构建系统"></a>CMake 构建系统</h2><p>&emsp;&emsp;基于 CMake 的构建系统由一系列高级逻辑目标（<code>target</code>）构成的，这些目标对应于可执行目标文件、库文件或者包含自定义命令的自定义目标（<code>custom target</code>）。各个目标间的依赖关系会在构建系统中指明，并依此来决定构建顺序和重新构建的规则。</p>
<h3 id="二进制目标"><a href="#二进制目标" class="headerlink" title="二进制目标"></a>二进制目标</h3><table>
<thead>
<tr>
<th>类型</th>
<th>命令</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>库</td>
<td><a href="https://cmake.org/cmake/help/v3.24/command/add_library.html#command:add_library">add_library()</a></td>
<td><code>add_library(mylib mylib.cxx)</code></td>
</tr>
<tr>
<td>可执行文件</td>
<td><a href="https://cmake.org/cmake/help/v3.24/command/add_executable.html#command:add_executable">add_executable()</a></td>
<td><code>add_executable(demo2 demo2.c)</code></td>
</tr>
<tr>
<td>自定义目标</td>
<td><a href="https://cmake.org/cmake/help/v3.24/command/add_custom_command.html#command:add_custom_command">add_custom_command()</a></td>
<td>add_custom_command(OUTPUT demo2.h<br>COMMAND demo2 demo2.h<br>DEPENDS demo2)</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：</p>
<ul>
<li>add_library() 支持生成多种类型的“库”，如 <code>SHARED</code>、<code>STATIC</code>、<code>MODULE</code>、<code>OBJECT</code>。具体用法参考<a href="https://cmake.org/cmake/help/v3.24/manual/cmake-buildsystem.7.html#id14">官方文档</a>。</li>
</ul>
<p>将库链接到可执行文件：<a href="https://cmake.org/cmake/help/v3.24/command/target_link_libraries.html#command:target_link_libraries">target_link_libraries()</a>，例如：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(demo2 PRIVATE mylib)</span><br></pre></td></tr></table></figure>

<h3 id="构建规范和使用要求"><a href="#构建规范和使用要求" class="headerlink" title="构建规范和使用要求"></a>构建规范和使用要求</h3><p>&emsp;&emsp;以库目标为例，其构建时需要指定一些规范：头文件路径、编译选项和宏定义等；当其他目标（<code>consumers</code>）使用（如链接）该库时，则必须满足使用要求，这些要求可能是必须包含某个头文件或者必须打开某个编译选项。</p>
<p>相关命令表：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://cmake.org/cmake/help/v3.24/command/target_include_directories.html#command:target_include_directories">target_include_directories()</a></td>
<td align="left">可认为等价于GCC的 <code>-I</code> 选项</td>
<td align="left">None</td>
</tr>
<tr>
<td align="left"><a href="https://cmake.org/cmake/help/v3.24/command/target_compile_definitions.html#command:target_compile_definitions">target_compile_definitions()</a></td>
<td align="left">可认为等价于GCC的 <code>-D</code> 选项</td>
<td align="left">None</td>
</tr>
<tr>
<td align="left">set_property()</td>
<td align="left">None</td>
<td align="left">None</td>
</tr>
</tbody></table>
<p>命令模式：</p>
<ul>
<li><code>PUBLIC</code>：</li>
<li><code>PRIVATE</code>：</li>
<li><code>INTERFACE</code>：</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(archive SHARED archive.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有 archive 源文件在编译时带有 -DBUILDING_WITH_LZMA</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(archive PRIVATE BUILDING_WITH_LZMA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># archive 源文件在编译时不会带有 -DUSING_ARCHIVE_LIB，而对于链接archive库的目标</span></span><br><span class="line"><span class="comment">#，其源文件编译时会带有 -DUSING_ARCHIVE_LIB，例如下面的 consumer 目标。</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(archive INTERFACE USING_ARCHIVE_LIB)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(consumer)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(consumer archive)</span><br></pre></td></tr></table></figure>

<p>使用要求的传播（Transitive Usage Requirements）：</p>
<ul>
<li><code>target_link_libraries()</code>命令的不同模式可以控制某个库的使用要求是否可以沿<strong>依赖链</strong>传递。</li>
</ul>
<p>使用生成器表达式（Generator Expressions）: 有些构建规范只能在generate-time获得或者需要有条件地获得。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(lib1Version2 SHARED lib1_v2.cpp)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> lib1Version2 PROPERTY</span><br><span class="line">  INTERFACE_CONTAINER_SIZE_REQUIRED <span class="number">200</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> lib1Version2 APPEND PROPERTY</span><br><span class="line">  COMPATIBLE_INTERFACE_NUMBER_MAX CONTAINER_SIZE_REQUIRED</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(exe1 exe1.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(exe1 lib1Version2)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(exe1 PRIVATE</span><br><span class="line">    CONTAINER_SIZE=$&lt;TARGET_PROPERTY:CONTAINER_SIZE_REQUIRED&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>find_package</code> 命令是非常便利的</strong>，它会生成对应依赖包的编译选项，例如头文件路径。经常使用的变量如下：</p>
<ul>
<li><code>&lt;package&gt;_&lt;lang&gt;_INCLUDE_DIRS</code>: 头文件路径</li>
<li><code>&lt;package&gt;_&lt;lang&gt;_LIBRARIES</code>: 共享库路径</li>
<li><code>&lt;package&gt;_&lt;lang&gt;_VERSION</code>:</li>
</ul>
<p>可以参考 <a href="https://cmake.org/cmake/help/latest/module/FindMPI.html">FindMPI - Cmake</a> 作为一个例子。</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">set</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">option (ccmake)</td>
<td align="left">如果需要在源代码文件中引用该选项，a: 在 CMakeLists.txt 中 使用 <code>configure_file</code>；b: 使用 <code>target_compile_options</code>。</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">target_compile_options()</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">set_target_properties</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">configure_file</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">add_subdirectory</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">install</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h2 id="输出编译信息"><a href="#输出编译信息" class="headerlink" title="输出编译信息"></a>输出编译信息</h2><p><code>make VERBOSE=1</code></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>集成 <code>CTest</code></p>
<h3 id="enable-testing"><a href="#enable-testing" class="headerlink" title="enable_testing"></a>enable_testing</h3><h3 id="add-test"><a href="#add-test" class="headerlink" title="add_test"></a>add_test</h3><h3 id="set-tests-properties"><a href="#set-tests-properties" class="headerlink" title="set_tests_properties"></a>set_tests_properties</h3><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>集成 <code>CPack</code></p>
<h2 id="常用构建变量"><a href="#常用构建变量" class="headerlink" title="常用构建变量"></a>常用构建变量</h2><table>
<thead>
<tr>
<th>Variable</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CMAKE_PREFIX_PATH</strong></td>
<td>依赖包路径</td>
</tr>
<tr>
<td><strong>CMAKE_MODULE_PATH</strong></td>
<td>CMake扩展模块所在路径</td>
</tr>
<tr>
<td><strong>CMAKE_INSTALL_PREFIX</strong></td>
<td>当执行<strong>install</strong> 目标时的安装路径</td>
</tr>
<tr>
<td><strong>CMAKE_BUILD_TYPE</strong></td>
<td>构建类型，例如<code>Debug</code>或<code>Release</code></td>
</tr>
<tr>
<td><strong>BUILD_SHARED_LIBS</strong></td>
<td>指定<code>add_library()</code>生成静态库还是动态库</td>
</tr>
</tbody></table>
<p>上述变量可以通过<code>option()</code>或者 <code>ccmake</code>工具设置，或者通过命令行设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Debug</span></span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><ul>
<li>打印变量列表<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --help-variable-list</span></span><br></pre></td></tr></table></figure></li>
<li>打印命令列表<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --help-command-list</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">project</span>(myproject VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>()</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>()</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>微型语言</tag>
      </tags>
  </entry>
  <entry>
    <title>CPython Internals 0: 配置和构建</title>
    <url>/2022/11/27/CPython-Internals-0-%E9%85%8D%E7%BD%AE%E5%92%8C%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; CPython 是使用最广的 Python 解释器。CPython 抽象了C语言开发平台和操作系统的复杂性，它使得开发者可以更高效、更优雅地编写可移植、可裁减和高性能的应用程序。但对于 Python 开发者而言，不能仅仅满足于使用 Python，理解 CPython 内部是如何工作，也同样重要，甚至它也是非常有趣的。</p>
<blockquote>
<p>官方文档：<a href="https://devguide.python.org/">Python Developer’s Guide</a><br>书籍：<a href="https://realpython.com/products/cpython-internals-book/">CPython Internals</a> By Anthony Shaw。该书的中文翻译版本：<a href="https://hai-shi.gitbook.io/cpython-internals/">CPython 实现原理</a></p>
</blockquote>
<span id="more"></span>

<h2 id="构建和编译"><a href="#构建和编译" class="headerlink" title="构建和编译"></a>构建和编译</h2><ul>
<li>安装依赖<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install libssl-dev zlib1g-dev libncurses5-dev \</span></span><br><span class="line"><span class="language-bash">libncursesw5-dev libreadline-dev libsqlite3-dev libgdbm-dev \</span></span><br><span class="line"><span class="language-bash">libdb5.3-dev libbz2-dev libexpat1-dev liblzma-dev libffi-dev</span></span><br></pre></td></tr></table></figure></li>
<li>clone 仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/python/cpython.git</span></span><br></pre></td></tr></table></figure></li>
<li>生成 makefile<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span> </span><br></pre></td></tr></table></figure></li>
<li>编译<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>EBNF -&gt; NFA -&gt; DFA</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>CPython</category>
      </categories>
  </entry>
  <entry>
    <title>CUDA Tutorial</title>
    <url>/2023/04/12/CUDA-Tutorial/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; CUDA 是专门为提高并行程序效率而开发的计算架构。它提供了对编程人员友好的编程模型，并支持多种高级编程语言（如 C&#x2F;C++、Fortran、Python、Java）或者 <code>OpenACC</code>。</p>
<blockquote>
<p>参考 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA C++ Programming Guide</a>。<br>参考 <a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html">CUDA C++ Best Practices Guide</a>。<br>参考 <strong>《CUDA By Example : An introduction to General-Purpose GPU Programming》</strong> By Jason Sanders &amp; Edward Kandrot.</p>
</blockquote>
<span id="more"></span>


<h2 id="开发环境和工具包"><a href="#开发环境和工具包" class="headerlink" title="开发环境和工具包"></a>开发环境和工具包</h2><p><strong>查看显卡型号</strong>：</p>
<p><code>$ ubuntu-drivers devices</code></p>
<p>在<a href="https://developer.nvidia.com/zh-cn/cuda-gpus#compute">CUDA-GPUS 官网</a> 查询该型号显卡是否支持 GPU 计算。</p>
<p><strong>安装驱动</strong>:<br><code>$ sudo apt-get install nvidia-driver-&lt;xxx&gt;</code></p>
<p>注意在 Linux 平台要禁用 <code>nouveau</code> 驱动，避免和 <code>NVIDIA 驱动</code>冲突。</p>
<p><strong>查看安装后的显卡驱动版本（以及支持的 CUDA 版本）：</strong><br><code>$ nvidia-smi</code></p>
<p><strong>安装 CUDA（Ubuntu 平台已经对 CUDA 进行了打包）</strong> ：</p>
<p><code>$ sudo apt-get install nvidia-cuda-toolkit</code></p>
<p>或者 参考<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA 官网安装方法</a></p>
<p><strong>cmake 支持</strong>，参考：<a href="https://developer.nvidia.com/zh-cn/blog/building-cuda-applications-cmake/">使用 CMake 构建跨平台 CUDA 应用程序</a>。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>&emsp;&emsp; GPU 在某些应用上的性能为什么比在 CPU 上更将大？GPU 的架构和 CPU 的架构有什么不同呢？</p>
<p>&emsp;&emsp; 相比而言，GPU 更加注重并行计算。尽管 CPU 被设计成擅长以尽可能快的速度执行线程，并且可以并行执行几十个这样的线程，但 GPU 被设计成擅长并行执行数千个（甚至更多）的线程（将较慢的单线程的性能进行分摊，以获得更大的吞吐量）。</p>
<p>&emsp;&emsp; 另外在硬件设计上，GPU 的晶体管更多的用于<code>数据处理（data processing）</code>而不是<code>数据缓存（data caching）</code>和<code>控制（flow control）</code>。GPU 和 CPU 在芯片资源上的分布如下图所示：</p>
<p><img src="/2023/04/12/CUDA-Tutorial/GPU_CPU_Layout.png"></p>
<p>GPU 可以通过计算来隐藏存储器访问延迟，而不是依赖于大量数据缓存和复杂的流控制来避免过长的存储器访问延迟（这两者在晶体管方面都是昂贵的）。</p>
<p>通常，对于具有高度并行性的应用，在 GPU 上比在 CPU 上更能发掘它的并行潜能。</p>
<p>无论是 CPU 还是 GPU，目前基本上都是<code>多核</code>的，这使得<code>并行计算</code>变得越来越重要。但早期的 GPU 计算使用起来非常的复杂，它受限于图形 API 的编程模型（例如 <code>OpenGL</code> 和 <code>DirectX</code>），因为它是和 GPU 交互的唯一方式。</p>
<p>后来，NVIDIA 在其<code>GeForce 8800 GTX</code>产品中首次使用 <code>CUDA</code> 架构，<code>CUDA</code> 架构专门为 GPU 计算设计了一个全新的模块，目的是减轻早期 CPU 计算中存在的一些限制。</p>
<p>CUDA 架构包含了一个统一的<code>着色器流水线</code>，使得执行通用计算的程序能够对芯片上的每个 <code>ALU （算术逻辑单元）</code>进行排列，而且这些 ALU 满足 <code>IEEE</code> 单精度浮点运算，并可以使用一个裁减后的指令集进行通用计算。GPU 上的执行单元既能任意地读写内存，还可以访问由软件管理的缓冲，也称为共享内存（注意与 <code>IPC</code> 机制区分）。</p>
<p>NVIDIA 不仅仅使用 CUDA 架构的硬件来提供通用计算和图形功能，还在软件层面开发了面向 GPU 的高级语言的编译器（如 <code>CUDA C</code>）。<code>CUDA C</code> 在 C 语言的基础上增加了一小部分关键字。另外，NVIDIA 还提供了专门的硬件驱动程序来发挥 CUDA 架构的大规模计算功能。这些都使得用户既不需要了解 <code>OpenGL</code>或 <code>DirectX</code>图形编程框架，<strong>也不需要将通用问题伪装成图形计算问题</strong>。</p>
<p><code>CUDA C</code> 提供了三个主要的抽象：线程块的层次结构、共享内存和<code>屏障同步（barrier synchronization ）</code>。这些抽象提供了细粒度的数据级并行和线程级并行，并嵌套在粗粒度的数据级并行和任务级并行中。用户需要将其要解决的问题划分成子问题，这些子问题可以独立并行地被<code>线程块</code>执行，子问题中更加细粒度的交互可以由块中的线程来完成。</p>
<p>这样分解（<code>block</code> 和 <code>block threads</code> ）使得解决子问题的线程可以相互交互，也可以保持一种可扩展性。线程块的具体调度由运行时系统完成，而不需要用户关心，也就是说同样的程序可以运行在不同档次的 GPU 上而<strong>自动</strong>获得不同的性能。</p>
<h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p><code>CUDA C++</code> 是如何描述并行任务的?<br><code>CUDA C++</code> 对 <code>C++</code> 进行了扩展，使得用户可以定义 <code>核函数</code>。<code>核函数</code> 与 一般的 C++ 函数不同之处在于：它可以被 N 个 <em>CUDA 线程</em> 并行执行 N 次。</p>
<p><code>核函数</code> 需要使用<code>__global__</code> 声明标识符，当调用<code>核函数</code>时需要使用语言扩展符号 <code>&lt;&lt;&lt;...&gt;&gt;&gt;</code>指定<strong>线程组</strong>。每个执行核函数的线程都会指定一个单独的 <em>线程ID</em>，并可以在核函数中通过变量<code>threadIdx</code>访问。一个简单例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">float</span>* A, <span class="type">float</span>* B, <span class="type">float</span>* C)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x;</span><br><span class="line">    C[i] = A[i] + B[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    add&lt;&lt;&lt;<span class="number">1</span>, N&gt;&gt;&gt;(A, B, C);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程块"><a href="#线程块" class="headerlink" title="线程块"></a>线程块</h3><p><code>线程块</code>中的线程可以在逻辑上被组织成一维结构、二维结构和三维结构；同样地，线程块中也可以被组织成单维或多维结构的<code>线程格(Grid)</code>。在一个线程块中的线程的个数是有限制的，可以使用<code>cudaDeviceProp</code>结构中的<code>maxThreadPerBlock</code>成员变量来获得该值（对于当前的 GPU，该值为1024）。</p>
<p>在&lt;&lt;&lt;…&gt;&gt;&gt;中指定<code>线程格</code>和<code>线程块</code>结构时，可以使用<code>int</code>或者<code>dim3</code>类型，使用<code>int</code>就默认指示其结构是一维的。每个块都有一个单独的<code>块 ID</code>，可以使用变量<code>blockIdx</code>访问。每个块的<code>度（可以理解为块的长度和宽度）</code>可以使用变量<code>blockDim</code>访问。线程格的<code>度</code>可以使用<code>gridDim</code>变量访问。</p>
<p>修改上节中的例子，使用二维结构的线程格和二维结构的线程块：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">float</span> A[N][N], <span class="type">float</span> B[N][N], <span class="type">float</span> C[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="type">int</span> j = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line">    C[i][j] = A[i][j] + B[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> xDim = (N + threadsPerBlock.x - <span class="number">1</span>) / threadsPerBlock.x;</span><br><span class="line">    <span class="type">int</span> yDim = (N + threadsPerBlock.y - <span class="number">1</span>) / threadsPerBlock.y;</span><br><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(xDim, yDim)</span></span>;</span><br><span class="line">    add&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有线程块并行执行，并且执行顺序是任意的，也就是线程块之间不能存在逻辑上或者数据上的相互依赖。每个线程块中的线程虽然也是并行的，但可以访问共享内存（使用<code>__shared__</code>声明标示符），并可以使用<code>__syncthreads()</code> 函数进行同步。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>每个线程有私有的本地存储。每个线程块有共享内存，该块中的每个线程都可以访问。另外，所有的线程都可以访问全局内存。另外，还有两种只读内存：<code>常量内存（constant memory）</code>和<code>纹理内存（texture memory）</code>，它们可以被所有线程访问。全局内存、常量内存和纹理内存空间对不同的内存使用场景进行了优化，因此恰当地使用合适的内存空间可以显著提供程序的内存性能。<br><img src="/2023/04/12/CUDA-Tutorial/cuda_memory.png"></p>
<h3 id="异构编程"><a href="#异构编程" class="headerlink" title="异构编程"></a>异构编程</h3><h3 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h3>]]></content>
      <categories>
        <category>高性能计算</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Can总线的安全分析</title>
    <url>/2025/02/20/Can%E6%80%BB%E7%BA%BF%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用 ICSim 模拟器</p>
<blockquote>
<p>参考 <a href="https://xz.aliyun.com/news/12474">浅谈车辆CAN总线安全</a></p>
</blockquote>
<span id="more"></span>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title>Circle: Raspberry Pi 的裸机编程环境</title>
    <url>/2024/12/12/Circle-Raspberry-Pi-%E7%9A%84%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://github.com/rsta2/circle/">Circle</a> 提供了一个针对 Raspberry Pi 的裸机编程环境。</p>
<span id="more"></span>

<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git <span class="built_in">clone</span> https://github.com/rsta2/circle.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> circle</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure -r 5 <span class="comment"># For raspiberry pi 5</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./makeall clean</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./makeall</span></span><br></pre></td></tr></table></figure>

<p>针对 <code>qemu</code> 的构建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure -p aarch64-none-elf- -r 4 --qemu  -f</span></span><br><span class="line">Configuration file successfully created:</span><br><span class="line"></span><br><span class="line">PREFIX64 = aarch64-none-elf-</span><br><span class="line">AARCH = 64</span><br><span class="line">RASPPI = 4</span><br><span class="line">DEFINE += -DNO_SDHOST</span><br><span class="line"></span><br><span class="line">Now enter ./makeall to build the Circle libraries!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./makeall clean</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./makeall</span></span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> boot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">SDCARD=XXXX make install</span></span><br></pre></td></tr></table></figure>

<h3 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h3><p><strong>armstub</strong> 是引导分区中加载 ARM 存根的文件名。默认 ARM 存根存储在固件中，并根据树莓派型号和各种设置自动选择。<br>存根是先于内核运行的一小段 ARM 代码。它的任务是在将控制权传递给内核之前设置中断控制器等低级硬件。</p>
]]></content>
      <categories>
        <category>开源硬件</category>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>C++的并发编程</title>
    <url>/2025/02/20/Cplusplus%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>C++</code> 在 C++ 11 标准中正式增加了对并发的支持，不仅包含了线程内存模型，还在 C++ 的标准库中扩展了管理线程的类、共享数据保护、线程同步以及低级操作原语。 </p>
<p>C++ 14 和 C++ 17 标准随后又增加了其他扩展。同时在标准库的具体实现下，兼顾性能，尽可能地减小<strong>抽象惩罚（abstraction penalty）</strong>。</p>
<blockquote>
<p>参考 《C++ Concurrency in Action. 2nd Edition》 by Anthony Williams.</p>
</blockquote>
<span id="more"></span>

<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>使用 <code>RAII</code> 来等待线程完成。<code>RAII</code> 的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。<br>具体使用时，可以利用局部变量自动销毁的机制，在变量的析构函数中释放资源（或其他操作，如线程 join 等）。<code>RAII</code> 比较典型的应用场景是对<code>锁</code>资源的管理。</p>
<p><strong>分离线程（detach）</strong></p>
<h2 id="线程共享数据"><a href="#线程共享数据" class="headerlink" title="线程共享数据"></a>线程共享数据</h2><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h2 id="内存模型和原子类型操作"><a href="#内存模型和原子类型操作" class="headerlink" title="内存模型和原子类型操作"></a>内存模型和原子类型操作</h2><h2 id="并发数据结构（有锁和无锁）"><a href="#并发数据结构（有锁和无锁）" class="headerlink" title="并发数据结构（有锁和无锁）"></a>并发数据结构（有锁和无锁）</h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++语言的设计与演化</title>
    <url>/2025/02/20/Cplusplus%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%BC%94%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>《The Design and Evolution of C++》 是 C++ 之父 <strong>Bjarne Stroustrup</strong> 为描述 C++ 语言的发展历史、设计理念和技术细节的著作。本篇文章对该书做一些精要部分的摘抄，并记录一些自己的心得。</p>
<span id="more"></span>

<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>（在作者看来，语言的设计要考虑到许多实践性的和社会性的因素，初始设计往往是满足当时的特定问题，后来成才去满足新的需求，反映对问题和对解决它们的工具和技术的新理解。）  </p>
<blockquote>
<p>我始终不渝的信念是，所有成功的语言都是逐渐成长起来的，而不是仅根据某个第一原则设计出来的。</p>
</blockquote>
<p>（很多语言，例如 Lisp，在设计时就指定了很多原则，如函数的第一性原则、函数式、基于序对的表结构是所有数据结构的基础等等，Lisp 很难说可以去尽可能满足现实中的需求。）</p>
<h3 id="C-之前的历史"><a href="#C-之前的历史" class="headerlink" title="C++ 之前的历史"></a>C++ 之前的历史</h3><p><strong>Simula 语言和分布式系统</strong></p>
<p>（Simula 语言是被认为是第一个 OOP 语言，它引入了 OOP 的基本概念：对象、类和继承。）<br>（在作者看来，在没有合适工具的情况下绝不去冲击一个问题，作者总结了一个“合适的工具”应该是什么样的。）</p>
<ul>
<li>对程序组织的支持（类）、对并发的某种形式的支持，以及对基于类的类型系统的强检查。</li>
<li>构建、运行都要快（至少能够运行得像 BCPL 一样快）。</li>
<li>允许高度可移植。</li>
</ul>
<p>（在作者看来，这些准则和语言的任何特定特征没有任何关系。相反，它们只是提出了对解决方案的一些约束条件。）</p>
<blockquote>
<p>我在操作系统领域的知识基础，以及对于模块化和通信的兴趣对于 C++ 有持久的影响。例如 C++ 的保护模型就来自于访问权限许可和转让的概念；初始化和赋值<br>的区分来自于对转让能力的思考；C++ 的 const 概念是从读写保护机制中演化出来的；而 C++ 异常处理机制的设计则受到 Brian Randell 小组在容错系统工作的影响。</p>
</blockquote>
<p><strong>C语言</strong></p>
<p>（作者分析了自己的实用主义和经验主义哲学倾向，倾心<code>齐克果</code>的存在主义哲学，认为其对个人的几乎狂热关心以及敏锐的心理洞察力比黑格尔及马克思更具有感染力。）<br>（这影响了 C++ 被有意地设计成能够支持各种各样的风格，而不是强调“一条真理之路”。）</p>
<h3 id="带类的-C-语言"><a href="#带类的-C-语言" class="headerlink" title="带类的 C 语言"></a>带类的 C 语言</h3><p>（语言要保持通用型，而不是面向特定的应用领域，当需要支持时，就应该通过库或者特定的扩充来做这件事。）  </p>
<blockquote>
<p>来类的 C 应该能够用到 C 可以使用的一切地方。这还意味着需要取得与 C 相当的执行效率。</p>
</blockquote>
<p>（早期<code>带类的 C </code>是通过<strong>预处理程序</strong>实现的，C 的全部能力都是可以使用的 ）</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>（<code>类</code> 是最重要和核心的概念。但不要把它看得过于神秘，我们可以说类是一种抽象机制，在数据和数据操作方面，又是一种封装机制。）</p>
<p><code>对象</code>是<code>类</code>的实例化，或者说前者由后者创建，这和基本数据类型（如 <code>int</code>、<code>float</code>等）的变量的创建是一致的。  </p>
<blockquote>
<p>函数定义通常写在“其他地方”，以使得类的声明看起来就像是一个接口描述，而不像是为了组织代码而提供的一种语法结构，这也意味着可以分别编译。</p>
</blockquote>
<p><code>new()</code> 是构造函数，后来演化为 C++ 里面的构造函数，不过函数名使用类名，而 <code>new</code> 则作为保留关键字用于动态分配对象的内存空间。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>用户定义的类型和内部类型在语言法则上要保持一致性，即都可以定义局部或者全局变量（Simula没有做到这一点）。</p>
<p><strong>内联</strong></p>
<blockquote>
<p>引入内联的一般性理由与越过保护屏障的代价有关。…… 在带类的 C 中只有成员函数能做成 inline 的，做法只有一种，就是把它的函数体放进类的声明中。<br>后来 C++ 引入了 inline 关键字并允许内联非成员函数。</p>
</blockquote>
<p><code>inline</code> 关键字只是一种让编译器<strong>尽可能</strong>去内联的提示，编译器可以忽略它。</p>
<h4 id="link"><a href="#link" class="headerlink" title="link"></a>link</h4><blockquote>
<p>按名字等价是 C++ 类型系统的基石，而内存布局相容性则保证了可以使用显式类型转换，以便能够提供低级的转换服务。</p>
</blockquote>
<p>（相反，在 python 语言中可以按照结构等价的，在底层内存数据层面，相同名字的变量引用的是同一块只读存储区。）</p>
<blockquote>
<p>惟一定义原则：在 C++ 中，每个函数、变量、类型、变量、常量等都应该恰好有一个定义。</p>
</blockquote>
<p>（在作者看来，带类的 C 要考虑一种纯朴的实现，不使用复杂的、花哨的和不实用的算法或机制。这种简单性和实用性可以快速培养用户的满足感与成就感。）</p>
<p>（在作者看来，C++ 是一个系统中的一个语言，而不是系统本身，不像 Smalltalk 或者 Lisp 那样被认为是完整的系统或者环境。）</p>
<blockquote>
<p>能够与其他语言和系统共生的问题至今还明显不是大多数理论家、所谓的完美主义者、学术界用户们的关注点。但我相信这是 C++ 成功的一个主要原因。</p>
</blockquote>
<p><strong>和 C 的连接兼容性要比代码的兼容性重要得多</strong></p>
<h4 id="对象的内存布局模型"><a href="#对象的内存布局模型" class="headerlink" title="对象的内存布局模型"></a>对象的内存布局模型</h4><p>class 的布局模型和 struct 完全一样。<code>this</code> 指针的使用。</p>
<h3 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h3><p>对调用不加声明函数是否需要检查以及如何检查的讨论。带类的 C 引入了 <code>void</code> 关键字。</p>
<p>是否支持隐式窄转换（如 int -&gt; char）的讨论。（不阻止，但会报告警告信息，但多数程序员往往忽略编译器的警告信息）</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>C++ 引入的很多对 C 的语法的改进最后也被 ASNI C 标准所接受，但作者的原则是一贯的：对 C 用户的兼容是第一位的。不会做激进地改进，“什么都不做就什么都做了”。</p>
<h3 id="派生类与虚函数"><a href="#派生类与虚函数" class="headerlink" title="派生类与虚函数"></a>派生类与虚函数</h3><p>没有虚函数时的多态性：用户可以使用派生类的对象而把基类当作实现细节。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>DDoS Attack and Defense Analysis</title>
    <url>/2024/12/19/DDoS-Attack-and-Defense-Analysis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DoS (Denial of Service, DoS) 是经常被使用的一种行之有效但难以防范的攻击手段。它主要依靠消耗网络带宽或系统资源（如CPU、Disk、Memory）导致网络或者系统过载以至于瘫痪而停止提供正常的网络服务和使服务质量显著降低，或通过更改系统配置使系统无法正常工作（如更改路由表）来达到攻击的目的。</p>
<span id="more"></span>

<h2 id="剧毒包型-DoS"><a href="#剧毒包型-DoS" class="headerlink" title="剧毒包型 DoS"></a>剧毒包型 DoS</h2><p>该类攻击主要利用协议本身或者软件实现中的漏洞（Software vulnerabilities），向 Target 发送一些异常的（畸形的）的数据包（malformed packet）使得目标系统在处理时出现异常，甚至崩溃。</p>
<h3 id="碎片攻击"><a href="#碎片攻击" class="headerlink" title="碎片攻击"></a>碎片攻击</h3><p>碎片攻击（Teardrop）是利用 TCP&#x2F;IP 协议栈实现上的漏洞，向目标主机发送<strong>分片偏移地址异常</strong>的 UDP 数据包分片，使得目标主机在重组分区时出现异常而崩溃或重启。</p>
<h3 id="Ping-of-Death-攻击"><a href="#Ping-of-Death-攻击" class="headerlink" title="Ping of Death 攻击"></a>Ping of Death 攻击</h3><p>该类攻击利用协议实现漏洞，向目标主机发送超长的 Ping 数据包（ICMP 包），导致目标主机系统异常，如死机、重启或崩溃。</p>
<h3 id="Land-攻击"><a href="#Land-攻击" class="headerlink" title="Land 攻击"></a>Land 攻击</h3><p>Land 攻击主要是针对目标主机上某个打开并处于监听的 TCP 端口，向其发送一个特别构造的 <code>TCP SYN</code> 包，该包的源地址和目标地址都被设置成目标主机的地址。目标主机收到上述报文后会向自己回复 <code>TCP SYN+ACK</code>消息，然后目标主机又发回自己一个 <code>TCP ACK</code> 报文，最后创建一个空连接。</p>
<h3 id="循环攻击"><a href="#循环攻击" class="headerlink" title="循环攻击"></a>循环攻击</h3><p>循环攻击又称为振荡攻击（Oscillate Attack）或者乒乓攻击，其原理是：当两个都会产生输出的端口（可以是用一个主机上的端口，也可能是不同主机上的端口）之间建立连接后，第一个端口的输出成为第一个端口的输入，反之亦然，最后导致两个端口间产生大量数据包，导致拒绝服务。</p>
<h2 id="风暴型-DoS"><a href="#风暴型-DoS" class="headerlink" title="风暴型 DoS"></a>风暴型 DoS</h2><p>攻击者首先通过控制攻击 Handler 和大量代理主机（agent）来向目标主机发送大量网络分组报文。使用的网络分组报文类型通常有以下几种：</p>
<ul>
<li>TCP Flood：向目标主机发送大量设置了不同标志的 TCP 分组。如 TCP SYN 攻击导致主机不断地为 TCP 连接分配资源，从而使得资源耗尽或者使其他程序分配资源失败。Trinoo 工具。</li>
<li>ICMP Echo Request&#x2F;Response 报文：向目标主机发送大量的 ICMP 分组。</li>
<li>应用层协议报文：HTTP&#x2F;HTTPS、NTP、SSDP、DNS 和 SNMP 等。</li>
</ul>
<p>同时，为了提高攻击效果，一些 DDoS 攻击工具还常常改变分组流中分组的某些字段来达到各种目的，如下面几种情况：</p>
<ul>
<li>源 IP 地址：IP spoofing ，隐藏分组的真正源地址，甚至可以将源地址改为目标主机地址。</li>
<li>源&#x2F;目的端口号</li>
<li>其他的 IP 头字段</li>
</ul>
<h2 id="重定向型-DoS"><a href="#重定向型-DoS" class="headerlink" title="重定向型 DoS"></a>重定向型 DoS</h2>]]></content>
      <categories>
        <category>信息安全</category>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title>Diffie-Hellman 算法分析及其改进</title>
    <url>/2024/12/17/Diffie-HellMan-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Diffie-Hellman 算法（简称 <code>DH</code> 算法）是最早的密钥交换算法，用于通信双方在非安全的信道中安全地交换密钥，用于加密后续的通信消息。该算法及其衍生算法在安全领域中应用很多，包括 TLS、IPSec、IKE 及 Bluetooth 网络和通信协议等。</p>
<span id="more"></span>

<h3 id="匿名-DH-算法"><a href="#匿名-DH-算法" class="headerlink" title="匿名 DH 算法"></a>匿名 DH 算法</h3><p>使用基本的 Diffie-Hellman 算法（见上节），在向对方发送 Diffie-Hellman 公钥参数时不进行认证。因此该方法容易遭受中间人攻击。</p>
<h3 id="瞬时-DH-算法"><a href="#瞬时-DH-算法" class="headerlink" title="瞬时 DH 算法"></a>瞬时 DH 算法</h3><p>用于创建临时密钥，在这种方法中，Diffie-Hellman 公钥在交换时使用发送者的 RSA 或 DSS 或 ECC 私钥签名。接收者使用相应的公钥验证签名。</p>
<h3 id="基于-RSA-的密钥交换算法"><a href="#基于-RSA-的密钥交换算法" class="headerlink" title="基于 RSA 的密钥交换算法"></a>基于 RSA 的密钥交换算法</h3><p>RSA 密钥交换算法使用文字描述如下：<br>a. 客户端向服务器端发起“交换请求（或证书请求）”，服务器首先回复公钥到客户端。<br>b. 客户端使用随机数生成密钥 <code>S</code>，使用收到的公钥进行加密，生成 <code>C</code>，把 <code>C</code> 发送到服务器。<br>c. 服务器收到 <code>C</code>，使用公钥对应的私钥进行解密，得到 <code>S</code>。<br>d. 客户端和服务器端得到了共享密钥 <code>S</code> （预主密钥）</p>
<p>图示如下：<br><img src="/2024/12/17/Diffie-HellMan-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B/RSA_KeyExchange.png"></p>
<p>SSL 协议中，服务器发送的公钥在 SSL 中是通过<code>certificate</code>报文发送的，<code>certificate</code>中的包含了公钥。<code>C</code> 是通过<code>Client key exchange</code>报文发送的。</p>
<h3 id="Oakley-算法"><a href="#Oakley-算法" class="headerlink" title="Oakley 算法"></a>Oakley 算法</h3><p>Oakley 算法是 IETF 对 DH 算法的改进，其特性包括：</p>
<ul>
<li>采用称为 <code>cookie</code> 程序的机制以对抗阻塞攻击。</li>
<li>允许双方协商一个全局参数集合。</li>
<li>利用现时确保抵抗重放攻击。</li>
<li>能够交换 Diffie-Hellman 公开密钥。</li>
<li>对 Diffie-Hellman 交换进行鉴别以防止中间人攻击。</li>
</ul>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>DroidCam 工具使用</title>
    <url>/2022/07/21/DroidCam-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <a href="https://www.dev47apps.com/">DroidCam</a> 软件可以将手机或者 tablet 的摄像头作为 PC 的 <code>webcam</code>（网络摄像头）来使用。</p>
<span id="more"></span>

<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="App端"><a href="#App端" class="headerlink" title="App端"></a>App端</h3><p>下载 App 端</p>
<h3 id="PC-端"><a href="#PC-端" class="headerlink" title="PC 端"></a>PC 端</h3><p><strong>下载安装：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /tmp/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -O droidcam_latest.zip https://files.dev47apps.net/linux/droidcam_1.8.2.zip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sha1sum</span>: d1038e6d62cac6f60b0dd8caa8d5849c79065a7b</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip droidcam_latest.zip -d droidcam</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> droidcam &amp;&amp; <span class="built_in">sudo</span> ./install-client</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Video 模块</strong>：</p>
<p>安装 <code>v4l2loopback-dc</code> 内核模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ./install-video</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 检查是否安装成功</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsmod | grep v4l2loopback_dc</span></span><br></pre></td></tr></table></figure>

<p><strong>Audio 模块</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ./install-audio</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="使用-WIFI-连接"><a href="#使用-WIFI-连接" class="headerlink" title="使用 WIFI 连接"></a>使用 WIFI 连接</h3><p>运行<code>droidcam</code> 或者 <code>droidcam-cli</code>：</p>
<p><code>$ droidcam</code></p>
<p><img src="/2022/07/21/DroidCam-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/droidcom_wifi.png"></p>
<p>其中 <code>Phone IP</code> 填写手机 App 中显示的 IP 地址。然后点击 <code>Connect</code> 即可。</p>
<p>然后，用户可以在浏览器中的网络摄像头列表中找到对应的一项，可以在网站： <a href="https://www.webcamtest.cc/">网络摄像头测试</a> 中进行检验。</p>
<p>使用完成后，可以在上面的<code>DroidCam Client</code>界面中点击 <code>Stop</code> 后退出。</p>
<h3 id="使用-USB-连接"><a href="#使用-USB-连接" class="headerlink" title="使用 USB 连接"></a>使用 USB 连接</h3><p>首先打开手机的 <code>Debugging 模式</code>，具体方法可以查询网络资源。</p>
<p>下载安装 <code>adb</code> 工具：</p>
<p><code>$ sudo apt-get install adb</code></p>
<p>检查设备是否可用：</p>
<p><code>$ adb devices</code></p>
<p>接下来，打开 <code>droidcam</code> 客户端，选择 <code>USB</code> 连接模式：</p>
<p><img src="/2022/07/21/DroidCam-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/droidcom_usb.png"></p>
<p>然后点击 <code>Connect</code> 。最后在浏览器中进行再进行检验即可。</p>
]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>ESP32 模组</title>
    <url>/2023/05/14/ESP32-%E6%A8%A1%E7%BB%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <code>ESP32</code> 是 ESP8266 的升级版本。除了 WIFI 模块外，<code>ESP32</code> 还包括蓝牙模块。</p>
<blockquote>
<p>参考 <a href="https://makeradvisor.com/esp32-vs-esp8266/">ESP32 vs ESP8266 – Pros and Cons</a> .</p>
</blockquote>
]]></content>
      <categories>
        <category>开源硬件</category>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>ESP8266 NodeMCU 介绍</title>
    <url>/2022/05/20/ESP8266-NodeMCU-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;<code>ESP8266 NodeMCU Kit</code> 开发板使用 <code>ESP8266 WIFI 模组</code>，再加上一些外部电路，可方便用于学习、测试和原型开发。其开源的可用固件除了<a href="https://github.com/espressif/">官方固件</a>外，还包括 <a href="https://www.nodemcu.com/index_cn.html">NodeMCU</a> 和 <a href="https://micropython.org/">MicroPython</a>。<br>&emsp;&emsp; 其中 <a href="https://nodemcu.readthedocs.io/en/release/">NodeMCU</a> 是基于 <code>Lua</code> 的开源固件。它使用基于模块（<code>on-module</code>）闪存的<code>SPIFFS</code>文件系统 。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://www.espressif.com.cn/sites/default/files/documentation/0a-esp8266ex_datasheet_cn.pdf">《ESP8266EX 技术规格书》</a> 。<br>参考 <a href="https://www.espressif.com.cn/sites/default/files/documentation/esp8266-technical_reference_cn.pdf">《ESP8266 技术参考》</a> 。<br>参考 <a href="https://randomnerdtutorials.com/getting-started-with-esp8266-wifi-transceiver-review/">Learn ESP8266</a> 。</p>
</blockquote>
<h2 id="技术规格及接口"><a href="#技术规格及接口" class="headerlink" title="技术规格及接口"></a>技术规格及接口</h2><h3 id="WIFI-参数及射频性能"><a href="#WIFI-参数及射频性能" class="headerlink" title="WIFI 参数及射频性能"></a>WIFI 参数及射频性能</h3><ul>
<li>工作频率： 2400 - 2483.5 MHz</li>
<li>功率：802.11g，PA 输出：12-16 dBm</li>
<li>协议标准：支持 IEEE 802.11 b&#x2F;g&#x2F;n</li>
<li>WIFI 安全标准：WEP 或 WPA&#x2F;WPA2 加密认证</li>
<li>接收灵敏度：是指无线设备<strong>正常工作所需的天线口最小信号接收功率</strong>。 接收灵敏度 &#x3D; <code>10lg</code> (带宽范围内的热噪声功率 &#x3D; KTB) + 系统噪声系数 + 解调所需信噪比。单位是dBm，接收灵敏度值越小，说明接收机的接收性能越好。温度越高、带宽越大，接收灵敏度就大。<br><strong>CCK，11Mbps：       &lt;&#x3D; -85 dBm</strong> （BPSK： 二进制相移键控 调制技术）<br><strong>(1&#x2F;2 BPSK)，6Mbps： &lt;&#x3D; -88 dBm</strong><br><strong>(3&#x2F;4 64-QAM)，54Mbps：&lt;&#x3D; -70 dBm</strong></li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="/2022/05/20/ESP8266-NodeMCU-%E4%BB%8B%E7%BB%8D/esp8266_interface.png"></p>
<ul>
<li>17 个 GPIO 端口</li>
<li>SPI&#x2F;I2C&#x2F;I2S&#x2F;UART： 2&#x2F;1&#x2F;2&#x2F;2</li>
<li>ADC： 10-Bit</li>
</ul>
<h3 id="CPU-存储-总线"><a href="#CPU-存储-总线" class="headerlink" title="CPU&#x2F;存储&#x2F;总线"></a>CPU&#x2F;存储&#x2F;总线</h3><ul>
<li>CPU：Tensilica L106 32-bit RISC ，时钟最高可达 160 MHz 。</li>
<li>RAM：32 KB 指令 RAM，32 KB 指令缓存，80 KB 用户数据 RAM，16KB ETS 系统数据 RAM 。</li>
<li>ROM：外部 QSPI Flash（最高可达 16 MB，通常容量范围为 512 KB - 4 MB）。（对于 NodeMCU 为 4 MB 容量）</li>
<li>总线：iBus &#x2F; dBus&#x2F; AHB</li>
</ul>
<h2 id="获取固件"><a href="#获取固件" class="headerlink" title="获取固件"></a>获取固件</h2><p><strong>NodeMCU固件:</strong></p>
<p>下载固件 <a href="https://github.com/nodemcu/nodemcu-firmware/releases">NodeMCU Release</a>。<br>在Linux编译环境下，Makefile文件会自动下载工具链<code>toolchain-esp8266-linux-x86_64-20190731</code>。</p>
<p><strong>MicroPython固件:</strong><br>下载已经编译的固件 <a href="https://micropython.org/download/esp8266/">MicroPython Firmware For ESP8266</a>。在flash新固件时，首先要擦除flash，否则新的固件无法正常运行。<br>使用串口通信工具: <code>picocom &lt;port&gt; -b&lt;baud rate&gt;</code>连接设备获得 <code>REPL</code></p>
<p><strong>ESPRESSIF 官方固件</strong>:<br>下载固件 <a href="https://github.com/espressif/ESP8266_NONOS_SDK/releases">ESP8266_NONOS_SDK</a> 或者 <a href="https://github.com/espressif/ESP8266_RTOS_SDK">ESP8266_RTOS_SDK</a>。</p>
<p><strong>Ai-Thinker 固件</strong>:<br><a href="https://docs.ai-thinker.com/%E5%9B%BA%E4%BB%B6%E6%B1%87%E6%80%BB">ESP8266 固件汇总</a> （注意选择 32Mbit 版本，32Mbit &#x3D; 4MByte）。</p>
<h2 id="编译-ESPRESSIF-ESP-AT-固件"><a href="#编译-ESPRESSIF-ESP-AT-固件" class="headerlink" title="编译 ESPRESSIF ESP-AT 固件"></a>编译 ESPRESSIF ESP-AT 固件</h2><p>下载交叉编译工具链: <a href="https://dl.espressif.com/dl/xtensa-lx106-elf-gcc8_4_0-esp-2020r3-linux-amd64.tar.gz">xtensa-lx106-elf</a>。</p>
<p>注意将下载后的工具链路径加到 <code>PATH</code> 系统变量中。</p>
<p>接下来参考 <a href="https://docs.espressif.com/projects/esp-at/zh_CN/release-v2.2.0.0_esp8266/Compile_and_Develop/How_to_clone_project_and_compile_it.html">ESPRESSIF ESP-AT 用户指南</a>。</p>
<h2 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h2><p><code>NodeMCU</code> 内置 <code>USB</code> 到 <code>串口</code> 的转换电路（CP2102 或者 CH340 芯片），所以上传代码是非常简单的，不需要 <code>FTDI</code> 编程器或者其他额外电路 。</p>
<p><code>esptool</code>：针对ESP32和ESP8266芯片的固件制作和下载工具。</p>
<p><strong>写入命令：</strong><code>$ esptool.py --port &lt;serial-port-of-ESP8266&gt; write_flash -fm &lt;flash-mode&gt; 0x00000 &lt;nodemcu-firmware&gt;.bin</code></p>
<blockquote>
<p><code>flash-mode</code> is <code>qio</code> for most ESP8266 ESP-01&#x2F;07 (512 kByte modules) and <code>dio</code> for most ESP32 and ESP8266 ESP-12 (&gt;&#x3D;4 MByte modules). ESP8285 requires dout.</p>
</blockquote>
<p><strong>擦除命令</strong>： <code>$ espool.py --port &lt;serial-port-of-ESP8266&gt; erase_flash</code></p>
<p><strong>进入下载模式：</strong><br><strong>方法A：</strong> 首先按下 <code>FLASH</code> 按钮，然后按下 <code>RST</code> 按钮，等待2秒钟后，松开 <code>RST</code> 按钮，再等待2秒后松开 <code>FLASH</code> 按钮。</p>
<p>**方法B： **拉低 <code>GPIO0</code> 进入下载模式。使用 UART0（设置波特率为 <code>74880</code>）查看输出信息，可看到类似下面的信息：<code>ets Jan  8 2013,rst cause:2, boot mode:(1,6)␍</code> 。对于 NodeMCU dev kit(ESP-12)，当连接 USB 口时，<code>GPIO0</code> 自动被拉低。</p>
<p>如果要烧录 ESPRESSIF 的官方 AT 固件，参考 <a href="https://docs.espressif.com/projects/esp-at/zh_CN/release-v2.2.0.0_esp8266/Get_Started/Downloading_guide.html">ESP-AT 下载指导</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://nodemcu.readthedocs.io/en/release/">NodeMCU 官方文档</a></li>
<li><a href="https://github.com/nodemcu">NodeMCU Github</a></li>
</ul>
]]></content>
      <categories>
        <category>开源硬件</category>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>Flask网络框架介绍</title>
    <url>/2021/01/22/Flask%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;Flask是一个轻量级、灵活和高度可扩展的web应用框架。它由一个健壮的核心来提供web需要的基础功能，然后将期望的其他功能由第三方扩展模块提供，这与python语言的特性相似。</p>
<span id="more"></span>


<h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><p>&emsp;&emsp;路由（routes）机制是指为每一个http请求的URL映射（map）处理函数（handler），具体实现则使用python的修饰符或者app.add_url_rule()方法。下面的代码例子非常简单直接，它为根路径指定index()处理函数，该函数直接返回一段HTML语句到客户端，这种处理函数称之为视图（view）函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>这很少的几行代码已经可以运行一个web服务器！<br>&emsp;&emsp;Flask通过route修饰符的语法可以支持三种类型的URLs。route修饰符将URL看作由静态部分与动态部分组成，动态部分由&lt;&gt;标记，用作视图函数的参数。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello World %s!&lt;/h1&gt;&#x27;</span> % name</span><br></pre></td></tr></table></figure>
<p>所以user可以处理所有静态部分为’&#x2F;user&#x2F;‘的URL。另外route修饰符的参数也可以设置Request的类型，如GET型或者POST型。</p>
<p>&emsp;&emsp;Flask使用context机制来提供一些变量，这些变量被看作是全局（global）的，可以直接访问，比如Http请求的一些信息可以访问request变量获得。context分为Application context和Request context，前者包括一些面向整个应用的变量（如g, current_app）,后者包括一些仅面向某次http请求的变量（如reauest、session）。同时也不难理解，前者的变量只能在应用启动激活后才能访问，后者只能在某次来自客户端的request请求期间才可以访问。</p>
<p>&emsp;&emsp;Flask使用Request Hooks机制来绑定一些函数，这些函数可以在http请求被分发（dispatching）到视图函数之前或者之后执行，这些函数可以执行一些通用的任务，可以避免相同的任务代码必须包含在所有的视图函数中，以此增加代码的重用性。</p>
<p>&emsp;&emsp;app.config字典是一个通用的地方来存放配置变量。其中SECRET_KEY变量被Flask或第三方模块用作加密key，例如保护网站免受CSRF攻击的Flask-WTF模块。</p>
<p>&emsp;&emsp;Blueprint机制是Flask为了支持动态生成应用实例（Application Instance）以及应用工厂（Application Factory）模式而产生的。app实例不再在全局代码的开头生成，而是由外部模块调用函数生成，因此view函数不能再使用app修饰符，因为此时app实例还不存在。Blueprint类似于Application，但它所定义的route处于休眠状态直到该Blueprint在Application中注册，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main = Blueprint(<span class="string">&#x27;main&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@main.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;....&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>():</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.register_blueprint(main)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>每一个Blueprint实际上生成了一个自己的命名空间（Namesapce），因此在不同的Blueprint中可以包含同名的view函数。</p>
<h3 id="Jinja2模板引擎"><a href="#Jinja2模板引擎" class="headerlink" title="Jinja2模板引擎"></a>Jinja2模板引擎</h3><p>&emsp;&emsp;Flask支持将业务逻辑（business logic）与表示逻辑（presentation logic）分离。对数据库的操作是最常见的业务逻辑，而生成返回到客户端的HTML代码称为表示逻辑，将表示逻辑使用模板（template）可以提高应用的可维护性。<br>&emsp;&emsp;模块文件包含静态部分和一些动态变量，这些动态变量的值由具体的Request context决定，将变量替换为实际的值并返回最后的Response的过程称之为渲染（rendering）。render_template方法是Jinja2引擎的主要接口。<br>&emsp;&emsp;Jinja2支持任何类型的动态变量，包括list、dictionaries或者object等。Jinja2支持过滤器（filer），例如，其中capitalize将name的首字母转换成大写字母。其中safe过滤器可以防止特殊字符串比如HTML代码中被解析，否则恶意用户可以在最后的response中插入被执行的恶意代码。Jinja2支持控制结构，如if、for等，也支持宏（macro）功能，它类似于python的函数功能。Jinja2支持在任何地方引用另一个模块文件，来增加代码重用性，也支持模块继承功能。<br>&emsp;&emsp;在模板文件中直接写入某些Link的URL地址会导致非常大的不灵活性，因此Flask提供url_for()方法从URL map中生成实际的URL地址。<br>&emsp;&emsp;从另外一种角度看，模块引擎实际上是一种嵌入在HTML代码中的另外一种语言，它要在静态页面中增加动态内容的目的是和其他语言，如PHP，JSP等是相同的。从语言的角度理解模板引擎更能认识到它所带来的便利性，以及它本身不可避免地的带来的复杂性。</p>
<h3 id="Flask-WTF表单处理模块"><a href="#Flask-WTF表单处理模块" class="headerlink" title="Flask-WTF表单处理模块"></a>Flask-WTF表单处理模块</h3><p>&emsp;&emsp;Form类或其子类来表示web表单，该类定义了一系列域来表示表单中的对象，并通过validators函数来对域进行合法性检查。例如表单中的Text对象可以用StringField类表示，并使用Required()来检测非空合法性。表单的这种封装形式便于使用模板渲染。<br>&emsp;&emsp;Post&#x2F;Redirect&#x2F;Get 模式是为了防止客户端刷新页面时发送重复的Post请求的机制。服务端首先处理Post请求，将Post请求中的表单数据存入session变量（Request context变量）中，然后返回Redirect报文；客户端接受到Redirect报文后发送Get请求，服务端会读取session变量中的数据并生成最后的包含HTML代码的Response。</p>
<h3 id="数据库模块"><a href="#数据库模块" class="headerlink" title="数据库模块"></a>数据库模块</h3><p>&emsp;&emsp;在选择数据库的问题上，ORMs和ODMs是一种值得注意的模型。它们可以将在对象（object）的操作转换为底层的数据库SQL命令，开发者可以不用自己编写SQL命令代码。这种机制可能会影响一些程序的性能，但在易用性、可移植性等方面却有着优势。<br>&emsp;&emsp;Flask-SQLAlchemy模块是Flask对SQLAlchmy ORM的一种扩展。Model类可以被python的类继承来表示一个表，类中的属性（attributes）会转换为表的schema的属性（Column）。这些类的属性可以设置表名，也可以设置约束，如主键约束、外健引用、值域等，对应于编写数据库表定义的DDT文件。ForeignKey类和relationship方法可以表示数据库表与表的关系，如一对多（one-to-many）、多对一（many-to-one）和多对多（many-to-many）。插入、删除、查询和更新等操作都可以通过flask-sqlachemy提供的API完成，它们在运行过程中会执行底层的SQL命令，如果出现错误，也会抛出异常给用户。这些API可以直接在view函数中使用，来完成相应的业务逻辑。另外Pagination类支持分页功能。<br>&emsp;&emsp;数据库迁移（database migration）框架Flask-Migrate用来跟踪数据库表schema的变化。在应用开发过程中，Model类的属性可能会增加、减少或更新，这导致数据库表的schema定义也要发生变化，而且要保证原有的数据不能丢失，migrate被用来帮助开发者有效率地解决这样的问题。</p>
<h3 id="Werkzeug模块"><a href="#Werkzeug模块" class="headerlink" title="Werkzeug模块"></a>Werkzeug模块</h3><p>&emsp;&emsp;Werkzeug的security模块可以提供基于HASH的安全密码(secure password hashing)。<br>Werkzeug 是WSGI模块</p>
<h3 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h3><p>Flask-script模块为Flask增加了命令行解析器。<br>Flask-Moment模块提高时间和日期的本地化（Localization）。<br>Flask-login模块可以完成用户登陆、认证和保存登陆状态的功能。<br>itsdangerous模块提供加密token，可以用于身份认证。<br>Flask-pagedown模块支持MarkDown文本编辑器。<br>Flask-HTTPAuth模块提供RESTful的用户认证功能。</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>&emsp;&emsp;对于RIA（Rich Internet Application）架构，客户端承担更多的业务逻辑，而服务端主要任务是提供数据访问和存储。RIA和服务端通信的协议可以使用RPC，如XML-RPC或者SOAP，REST(Representational State Transfer)也是一个流行的选择。Flask可以容易地实现RESTful的web服务器。REST架构的风格：</p>
<ol>
<li>将客户端与服务端分开</li>
<li>无状态（Stateless）：即服务端不保存任何客户端在不同的Request间传递的状态信息，而客户端的每次Request必须包含所有必要的信息。</li>
<li>缓存化（Cache）：服务端的Response可以被标记是否缓存。</li>
<li>统一接口（Uniform Interface）：客户端和服务端的通信协议必须一致、良好定义和标准化。</li>
<li>分层系统：客户端和服务器间可以插入代理（Proxy），来提高性能、可用性和可扩展性。</li>
<li>Code-On-Demand：客户端可以从服务端下载代码并在自己的上下文中执行。</li>
</ol>
<p>在REST中，资源（Resource）是核心概念，每一个资源URL必须与唯一的一个资源相互对应。资源的集合也可以对应一个URL，这个URL一般以’&#x2F;‘结尾，来表达这些资源集合在一个文件夹中。另外，在REST架构中，GET请求用来获取单个资源或者资源集合；POST请求新增一个资源并把它加入某个集合中；PUT请求更新一个资源；DELETE请求删除一个资源或者资源集合。REST不严格要求资源的编码格式，客户端和服务端可以通过HTTP协商，常用的格式包括JSON和XML。REST的资源架构类似于WWW，在那里 ，一个资源中会包含许多指向其他资源的链接，整个WWW就是资源作为节点形成的巨大网络。<br>&emsp;&emsp;在REST中，Versioning指REST服务端的接口可以版本化，并且在URL中包含版本号，这样做可以使得服务端根据版本号服务不同的客户端，这些客户端可能使用了最新的API，而另外一些却没有。<br>&emsp;&emsp;由于REST是无状态的，因此它不能按照传统的方法来进行用户认证和访问控制。REST中，客户端的每一个请求都必须携带必要的认证信息，比如可以包含在HTTP的Authorization头部中。基于Token的认证可以避免将敏感信息频繁地出现在来往的报文中，客户端首先发送携带口令的请求，得到带有Token的回复，然后后续请求都只需要携带这个token来进行认证，token如果超期，客户端重新携带口令请求一个新的token。另外，服务端返回到客户端的资源不一定要和数据库的资源完全相同，有些安全敏感但对客户端无用的信息可以不包含在Response中。</p>
<h3 id="应用开发结构"><a href="#应用开发结构" class="headerlink" title="应用开发结构"></a>应用开发结构</h3><p>&emsp;&emsp;Flask鼓励开发者按照自己的需求设定自己的项目文件和结构布局。<br>&emsp;&emsp;工厂模式（Factory Pattern）。<br>&emsp;&emsp;requirements.txt文件中记录应用所有的包依赖（Package Dependencies），它可以由pip自动生成，也就可以作为pip的install文件来自动安装所有的依赖包。<br>&emsp;&emsp;单元测试（UnitTests）,可以使用python unittest库。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>FreeRTOS+TCP介绍</title>
    <url>/2022/07/11/FreeRTOS-TCP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp; FreeRTOS+TCP实现了可扩展、开源和线程安全的TCP&#x2F;IP协议栈。它的特性如下：</p>
<ul>
<li><strong>Berkeley 套接字API</strong></li>
<li>可选支持TCP滑动窗口</li>
<li>API完全可重入和线程安全</li>
<li>包括 ARP, DHCP, DNS, LLMNR, NBNS等协议</li>
<li>免费ARP（Gratuitous ARP）</li>
</ul>
<span id="more"></span>


<ul>
<li>静态、DHCP和Auto-IP地址分配</li>
<li>可以被用作 <strong>UDP only stack</strong></li>
<li>可选的回调接口</li>
<li>可选的输出包分段</li>
</ul>
<blockquote>
<p>详细资料请参看<a href="https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/index.html">官方文档</a> 。</p>
</blockquote>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>&emsp;&emsp;网络接口层位于IP协议栈和硬件驱动层之间：</p>
<img src="https://www.freertos.org/fr-content-src/uploads/2018/07/network_interface.png" width=40%>

<p>注意: <strong>FreeRTOS+TCP协议栈的实现是依赖于FreeRTOS 内核的，这与FreeRTOS Core不同。</strong></p>
<p>注意：在FreeRTOS+TCP的所有函数中，<em>FreeRTOS_IPInit</em> API必须首先被调用，它会生成FreeRTOS+TCP任务，该任务会初始化网络接口，并根据配置回调 * vIPNetworkEventHook*函数。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>FreeRTOS Socket的用法和通常的Berkeley Socket的用法基本相同。</p>
<ul>
<li>客户端：<ol>
<li>FreeRTOS_socket -&gt; FreeRTOS_setsockopt-&gt; FreeRTOS_bind -&gt; FreeRTOS_connect</li>
<li>FreeRTOS_send &lt;&#x3D;&gt; FreeRTOS_recv</li>
<li>FreeRTOS_shutdown -&gt; FreeRTOS_closesocket</li>
</ol>
</li>
<li>服务端：<ol>
<li>FreeRTOS_socket -&gt; FreeRTOS_setsockopt -&gt; FreeRTOS_bind -&gt; FreeRTOS_listen -&gt; FreeRTOS_accept</li>
<li>FreeRTOS_recv &lt;&#x3D;&gt; FreeRTOS_send</li>
<li>FreeRTOS_shutdown -&gt; FreeRTOS_closesocket</li>
</ol>
</li>
</ul>
<p>服务端可以采用多线程并发模式，为每个客户端连接新建一个任务，由该任务负责后续服务。</p>
<p><strong>注意</strong>：在调用FreeRTOS_closesocket前，需调用FreeRTOS_shutdown API，然后调用FreeRTOS_recv循环等待，直到返回**-pdFREERTOS_ERRNO_EINVAL<strong>，表明socket连接已经断开。从安全的角度讲，socket的不正常关闭很可能造成服务器的资源泄漏，而引发崩溃或者拒绝服务。<br><strong>提示：</strong> UDP的用法与TCP的用户大都相同，UDP的发送可以采用</strong>零拷贝(zero-copying)技术**。</p>
<h3 id="网络数据缓存-Network-data-buffer"><a href="#网络数据缓存-Network-data-buffer" class="headerlink" title="网络数据缓存(Network data buffer)"></a>网络数据缓存(Network data buffer)</h3><ul>
<li><p>BufferAllocation_1.c</p>
</li>
<li><p>BufferAllocation_2.c</p>
</li>
</ul>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>&emsp;&emsp;<strong>FreeRTOSIPConfig.h</strong>的主要配置项：</p>
<ul>
<li>影响TCP&#x2F;IP栈任务行为的常量</li>
<li>调试、跟踪和日志设置</li>
<li>针对硬件和驱动的设置</li>
<li>针对TCP的设置</li>
<li>针对UDP的设置</li>
<li>影响Socket行为的常量</li>
<li>影响ARP行为的常量</li>
<li>影响DHCP和名字服务的常量</li>
<li>影响IP和ICMP行为的常量</li>
<li>提供支持目标板的常量</li>
</ul>
<h3 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h3><h3 id="QEMU示例"><a href="#QEMU示例" class="headerlink" title="QEMU示例"></a>QEMU示例</h3>]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>GMP库的使用</title>
    <url>/2023/03/18/GMP%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <a href="ttps://gmplib.org">GMP</a> 是一个执行<strong>任意精度</strong>数值计算的可移植 C&#x2F;C++ 库，它支持整数、有理数和浮点数。无论是对于低精度还是高精度计算，GMP 都可以提供很好的性能。</p>
<p>&emsp;&emsp; GMP 的高性能来自于以下几点特性：使用字符串(<code>fullword</code>)作为基础数据类型；使用精心设计的算法；在底层，针对通用内部循环使用精心优化的汇编代码（支持不同的 CPU ）。</p>
<blockquote>
<p>参考 <a href="https://gmplib.org/manual">GMP Manual</a>。</p>
</blockquote>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="头文件和库"><a href="#头文件和库" class="headerlink" title="头文件和库"></a>头文件和库</h3><p>主要头文件（支持C&#x2F;C++编译器）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 C++，也可直接使用&lt;gmpxx.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmpxx.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果需要使用带有<code>FILE*</code>参数的函数，需要增加<code>&lt;stdio.h&gt;</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmp.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果需要使用支持带有<code>va_list</code>参数的函数（如<code>gmp_vprintf</code>），需要增加 <code>&lt;stdarg.h&gt;</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmp.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>编译应用程序时的链接选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc test.c -lgmp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于 C++</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ test.cpp -lgmpxx -lgmp</span></span><br></pre></td></tr></table></figure>

<h3 id="术语和类型"><a href="#术语和类型" class="headerlink" title="术语和类型"></a>术语和类型</h3><p>对于<em>多精度整数</em>，使用<code>mpz_t</code>类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">mpz_t</span> x, y, z;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">mpz_t</span> x;&#125;;</span><br><span class="line"><span class="type">mpz_t</span> vec[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>

<p>对于<em>多精度分数</em>（即有理数），使用<code>mpq_t</code>类型。<br>对于<em>浮点数</em>，使用<code>mqf_t</code>类型。</p>
<p>浮点数函数的形参类型和返回类型是其<em>指数</em>， 用 C 类型表示为<code>mp_exp_t</code>。<code>mp_exp_t</code>类型通常等价于<code>long</code>，出于效率考虑，在一些系统上可能为<code>int</code>。</p>
<p><em>limb</em> 代表多精度数的一部分，该部分刚好可以填充到一个机器字中。对应的 C 类型为 <code>mp_limb_t</code>，它可能为 32 位或者 64 位。</p>
<p>一个多精度数的 <em>limb</em> 的个数使用<code>mp_size_t</code>类型表示。</p>
<p>一个多精度数的 <em>bit</em> 的个数使用 <code>mp_bitcnt_t</code>类型表示。</p>
<p><em>Random state</em> 代表选择的算法和当前的状态数据，使用<code>mp_randstate_t</code>类型表示。</p>
<h3 id="函数-API"><a href="#函数-API" class="headerlink" title="函数 API"></a>函数 API</h3><p>在 GMP 库中有 6 种类型的函数：</p>
<ol>
<li>对于<strong>有符号整数</strong>的计算，使用以<code>mpz_</code> 开头的函数；这一类函数大约有 150 个。</li>
<li>对于<strong>有理数</strong>的计算，使用以<code>mpq_</code>开头的函数；</li>
<li>对于<strong>浮点数</strong>的计算，使用以<code>mpf_</code>开头的函数；</li>
<li>对于操作底层的原生数值类型，使用以<code>mpn_</code>开头的函数，关联的数据类型是<code>mp_limb_t</code>的数组。</li>
<li>设置<em>custom allocation</em>的函数；</li>
<li>生成随机数的函数。</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在对一个 GMP 变量赋值前，用户需要首先使用对应的初始化函数对它进行初始化。当该变量不再使用时，用户需要使用对应的清除函数清除它。示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">mpz_t</span> n;</span><br><span class="line">    mpz_init(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        mpz_mul(n,...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mpz_clear(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>mpz_t</code>这样的 GMP 类型，底层实现为<em>单元素的数组</em>。相应的变量实际上是 <em>指针</em>，它指向实际的对象(object)。如果使用C++的术语的话，<em>变量</em>是<code>左值引用</code>，<em>对象</em>是<code>右值</code>。 出于效率和正确性的考虑，不建议作对象拷贝（或者说右值拷贝），其内部成员也不应该被用户访问。</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>在上一节，我们说 GMP 的变量实际上是<code>左值引用</code>，因此对于使用 GMP 变量作为其参数的函数，可以在函数体中修改其参数指向的数据内容。如果只是读参数指向的数据内容，可以将形参声明为<code>const</code>。示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(<span class="type">mpz_t</span> result, <span class="type">const</span> <span class="type">mpz_t</span> param, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>  i;</span><br><span class="line">  mpz_mul_ui (result, param, n);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    mpz_add_ui (result, result, i*<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">mpz_t</span>  r, n;</span><br><span class="line">  mpz_init (r);</span><br><span class="line">  mpz_init_set_str (n, <span class="string">&quot;123456&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  foo (r, n, <span class="number">20L</span>);</span><br><span class="line">  gmp_printf (<span class="string">&quot;%Zd\n&quot;</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-绑定"><a href="#C-绑定" class="headerlink" title="C++绑定"></a>C++绑定</h2><p>GMP 的 C++接口相对 C 接口来说，更加方便使用。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmpxx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    mpz_class a, b, c;</span><br><span class="line">    <span class="function">mpz_class <span class="title">d</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">12500</span>;</span><br><span class="line">    b = <span class="string">&quot;12300000000000&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    c = a+d;</span><br><span class="line">    c = <span class="built_in">sqrt</span>(c);</span><br><span class="line">    </span><br><span class="line">    <span class="function">mpf_class <span class="title">f</span><span class="params">(<span class="string">&quot;1.23e12&quot;</span>)</span></span>;</span><br><span class="line">    f = f * f;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -o cpp_binding_test cpp_binding_test.cpp -lgmp -lgmpxx</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./cpp_binding_test</span></span><br><span class="line">12500 12300000000000 111 0</span><br><span class="line">1.5129e+24</span><br></pre></td></tr></table></figure>

<h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>&emsp;&emsp; 如果我们在 <code>MPI 编程</code>中需要发送或者接收 <code>mpz_class/mpf_class</code> 的数据结构,该如何做呢?<br>参考: <a href="https://gmplib.org/list-archives/gmp-discuss/2002-December/000194.html">https://gmplib.org/list-archives/gmp-discuss/2002-December/000194.html</a></p>
]]></content>
      <categories>
        <category>高性能计算</category>
      </categories>
  </entry>
  <entry>
    <title>GNU Unix/Linux下 常用工具</title>
    <url>/2022/04/14/GNU-Unix-Linux%E4%B8%8B-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="终端类"><a href="#终端类" class="headerlink" title="终端类"></a>终端类</h3><ul>
<li><code>tmux</code></li>
</ul>
<span id="more"></span>

<h3 id="网络工具类"><a href="#网络工具类" class="headerlink" title="网络工具类"></a>网络工具类</h3><ul>
<li><code>xchat</code>: IRC客户端</li>
<li><code>iproute2</code> : 网络及其流量控制工包</li>
<li><code>net-tools</code> : NET-3网络工具包</li>
<li><code>openssh-server</code>: OpenSSH SSH服务器端</li>
<li><code>wireshark</code>:强大的交互式网络抓包和分析工具</li>
<li><code>ufw</code>: 网络防火墙管理工具</li>
<li><code>nmap</code>: 网络嗅探工具</li>
<li><code>nslookup</code>: DNS交互式查询工具</li>
<li><code>telnet</code>:</li>
<li><code>netcat|nc</code>: 连接和监听TCP&#x2F;UDP端口工具</li>
<li><code>openssl</code>：SSL&#x2F;TLS网络加密协议的开源实现</li>
<li><code>urlview</code>：URL解析器</li>
<li><code>amule</code>：ed2k&#x2F;Kad 网络客户端</li>
<li><code>iw</code>：无线设备管理和配置工具</li>
<li><code>tcpdump</code>：抓包和包分析工具</li>
<li><code>axel</code>：CLI接口的网络下载加速器</li>
<li><code>aria2</code>：网络下载加速器</li>
<li><code>lynx</code> : 通用的Roguelike风格的WWW分布式网页浏览器</li>
<li><code>wscat</code>: 通过Websocket通信</li>
</ul>
<h3 id="多媒体类"><a href="#多媒体类" class="headerlink" title="多媒体类"></a>多媒体类</h3><ul>
<li><code>vlc</code>: VLC多媒体播放器</li>
<li><code>ffmpeg</code> : 一个功能强大的跨平台的音视频流处理工具</li>
<li><code>audacity</code> : 跨平台的音频编辑器</li>
<li><code>icotool</code> : 制作win32图标</li>
<li><code>sng</code>：一种编辑PNG图片的文本化标记语言</li>
<li><code>jpegoptim</code> ：优化&#x2F;压缩JPEG图片</li>
<li><code>pngcrush</code> ： PNG优化工具</li>
</ul>
<h3 id="编辑器和文件阅读器"><a href="#编辑器和文件阅读器" class="headerlink" title="编辑器和文件阅读器"></a>编辑器和文件阅读器</h3><h3 id="设计、开发和调试工具"><a href="#设计、开发和调试工具" class="headerlink" title="设计、开发和调试工具"></a>设计、开发和调试工具</h3><p>A. <em>Linux可执行文件分析工具：</em></p>
<ul>
<li><code>strip</code>：从object文件中去除符号表。</li>
<li><code>nm</code> ： 列出object文件的符号表。</li>
<li><code>readelf</code> : 分析ELF文件。</li>
<li><code>objdump</code> : 分析可执行文件（包括反汇编）。</li>
<li><code>ldd</code>：打印共享库依赖。</li>
<li><code>strace</code> : 跟踪系统调用和信号。</li>
<li><code>size</code>: 打印二进制文件各个段的大小。</li>
<li><code>pmap</code>: 打印进程的内存映射</li>
<li><code>ipcs</code> : 打印当前系统IPC机制的信息</li>
<li><code>ctags</code>: 为源代码文件生成tags</li>
<li><code>cxref</code>: 为C语言代码生成交叉引用表</li>
<li><code>cflow</code>：打印函数调用树</li>
<li><code>valgrind</code>：检测数组访问错误和内存泄漏</li>
</ul>
<h3 id="系统管理工具"><a href="#系统管理工具" class="headerlink" title="系统管理工具"></a>系统管理工具</h3><ul>
<li><code>top</code>：Roguelike风格的进程&#x2F;内存监控工具</li>
<li><code>iostat</code>：报告CPU和I&#x2F;O设备的统计信息</li>
<li><code>mpstat</code>：报告处理器统计信息</li>
<li><code>pidstat</code>：报告进程的统计信息</li>
<li><code>sar</code>：收集、报告、打印系统活动信息</li>
<li><code>sadf</code>：以多种格式输出sar的统计信息，包括SVG图片</li>
<li><code>iotop</code>：简单的top-like的I&#x2F;O监控工具</li>
<li><code>updatedb</code>：为mlocate更新数据库</li>
<li><code>locate</code>：基于数据库进行文件检索</li>
<li><code>extundelete</code> ：从ext3&#x2F;ext4文件系统中恢复文件</li>
<li><code>e2label</code>：改变ext2&#x2F;ext3&#x2F;ext4文件系统的Label</li>
<li><code>tune2fs</code>：调整ext2&#x2F;ext3&#x2F;ext4文件系统参数，使用<code>-l</code>参数可打印当前参数值</li>
<li><code>lsof</code> : 列出进程打开文件,包括socket</li>
</ul>
<h3 id="科学计算、自动化EDA"><a href="#科学计算、自动化EDA" class="headerlink" title="科学计算、自动化EDA"></a>科学计算、自动化EDA</h3><ul>
<li><code>octave</code>：Octave是一种科学计算软件，旨在提供与Matlab语法兼容的开放源代码科学计算及数值分析的工具。</li>
</ul>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ul>
<li><code>safecopy</code> : 安全拷贝，可用于数据备份</li>
<li><code>TestDisk</code>: 修复分区、引导等；找回删除文件；分区备份等</li>
<li><code>photorec &amp; fidentity</code>: 不依赖文件系统的完整性来恢复数据，默认支持400多种文件格式。但对于某些文件（例如数据库），当文件系统损坏后，可能无法完全恢复。</li>
<li><code>foremost</code>: 基于文件magic指纹进行修复，可自定义文件格式。</li>
<li><code>fsck &amp; e2fsck</code> : 检查和修复文件系统，<code>e2fsck</code>专门针对ext文件系统。在某些情况下，fsck相比前面的工具可以更有效地解决因文件系统损坏导致的重要文件无法访问的问题。</li>
</ul>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>GNU编译调试工具链手册</title>
    <url>/2022/04/29/GNU%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%93%BE%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp; GNU软件开发环境（GDE）提供了全功能的、协作式的开发环境。它包含众多了强大的开发工具，这些工具或者（标准）提供了开发高质量产品软件的高效的环境。另外，GDE的工具都可以免费获得下载，而且很多软件还关联着活跃的开源社区。GDE不等同于集成开发环境（IDE），它在工具的选择上有更多灵活性。</p>
<span id="more"></span>


<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><h3 id="Lex和Yacc"><a href="#Lex和Yacc" class="headerlink" title="Lex和Yacc"></a>Lex和Yacc</h3><h3 id="M4"><a href="#M4" class="headerlink" title="M4"></a>M4</h3><p>&emsp;&emsp; <code>M4</code>是通用Unix宏处理器，它接受输入流，并将输入流中的宏进行扩展后拷贝到输出。宏可以是内置的也可以是用户自定义的。M4作为微型语言，不仅仅可以完成宏扩展功能，它还可以通过内置函数完成命名文件、执行Unix命令、算术运算、操作文本字符和递归。M4不但可以作为宏处理器，也可以作为编译器的前端。某种程度上说，m4是完备图灵机。M4最大的使用场景是在<code>GNU Autoconf</code>工具中。<br>&emsp;&emsp;C语言提供了对于宏的支持，但一般认为要<strong>慎用</strong>宏。使用宏最然可以避免相比使用函数调用带来的开销，但却容易使程序变得<em>看起来</em>复杂，违背清晰和透明的原则。<br>&emsp;&emsp; 详细手册可以参看<code>info m4</code>或浏览在线资源 <a href="https://www.gnu.org/software/m4/manual/m4.html">M4 手册</a>。</p>
<blockquote>
<p><strong>Beware that m4 may be dangerous for the health of compulsive programmers.</strong></p>
</blockquote>
<ul>
<li><p><strong>基本格式</strong>： <code>define(宏名，宏体)</code>（宏本身也会被m4展开，不过展开为空字符）。宏也可以带参数，使用$1,%2,…,$9表示。m4 的宏名名规则是：只允许使用字母、数字以及下划线构造宏名，并且宏名只能以字母或下划线开头。只有符合宏名规则的宏，m4 才会将它视为真正的宏。<strong>m4 将一切没有引号的文本都视为宏。对于已定义的宏，m4 会将其展开；对于未定义的宏，m4 会按其字面将其输出。加了引号的文本，m4 不再检测它们是不是宏，而是将其作为普通文本按字面输出。</strong>需要注意的是，<code>define</code>本身就是宏，后面括号内是它的参数，从这点来说，它和用它定义的用户宏没有区别。</p>
</li>
<li><p><strong>条件宏</strong>：<br><code>ifdef(``a&#39;,b)，如果a是已定义的宏，则该条件宏被展开为b </code>ifdef(&#96;&#96;a’,b,c)，如果a是已定义的宏，则该条件宏被展开为b；如果未定义，则展开为c。<br><code>ifelse(a,b,c,d)</code> 比较字符串 a 与 b 是否相同，如果它们相同，这条语句的展开结果是字符串 c，否则展开为字符串 d。</p>
</li>
<li><p><strong>递归</strong>：</p>
</li>
<li><p><strong>执行shell命令</strong>：<code>esyscmd</code></p>
</li>
</ul>
<p>&emsp;&emsp;参看中文博客 <a href="https://segmentfault.com/a/1190000004104696?msclkid=4062645ccaa011ec839f701f4a18f0f6">M4简介</a> 。<strong>牢记：宏是用来缩写那些复杂但是又经常重复出现的文本模式的。</strong></p>
<h3 id="Autoconf"><a href="#Autoconf" class="headerlink" title="Autoconf"></a>Autoconf</h3><p>&emsp;&emsp; Autoconf工具致力于保证程序的<code>可移植性</code>，使得不需要为不同的系统开发不同的源程序，特别是当系统之间的差异比想象中的大的情况下。首先，源程序会按照一个理想的机器模型（POSIX）编程；然后，当源程序拷贝到用户系统时，autoconf会尽力假装用户系统时满足POSIX的标准的。<strong>Autoconf会帮助源程序的维护者学习用户的系统，诊断该系统不满足POSIX标准的地方，然后提供变通的方法。</strong>审核程序可以直接使用shell来编写，但shell本身的兼容性使得编写脚本非常复杂，就像编写汇编语言。<strong>Autoconf则使得不需要专门写shell脚本来对系统进行审核。</strong><br>&emsp;&emsp; Autoconf可以基本上认为是一个M4的宏库，但m4代码太过底层，且Autoconf要生成shell脚本，因此Autoconf是工作在m4变体<code>m4sh</code>之上的高层代码。<br>&emsp;&emsp; 任何Autoconf脚本必须以<code>AC_INIT</code>开头，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AC_INIT(Auditor, 1.0)</span><br><span class="line">AC_PROG_CC                                       # 检测C编译器</span><br><span class="line">AC_CONFIG_FILES([Makefile], [chmod +x Makefile]) # 模板文件</span><br><span class="line">AC_OUTPUT</span><br></pre></td></tr></table></figure>
<h3 id="Automake"><a href="#Automake" class="headerlink" title="Automake"></a>Automake</h3><p>&emsp;&emsp;Automake是从Makefile.am(定义一系列make变量的文件)自动生成Makefile.in文件的工具。生成的Makefile.in符合GNU Makefile 标准。</p>
<h3 id="Libtool"><a href="#Libtool" class="headerlink" title="Libtool"></a>Libtool</h3><p>&emsp;&emsp;Libtool同样为解决软件<code>可移植性</code>问题而设计，不过它关注的是动态链接库。使用 GNU Libtool 可以容易的在不同的系统中建立动态链接库。</p>
<h3 id="Autotest"><a href="#Autotest" class="headerlink" title="Autotest"></a>Autotest</h3><h3 id="Gdb"><a href="#Gdb" class="headerlink" title="Gdb"></a>Gdb</h3><ul>
<li><p><strong>开始和停止</strong></p>
<p><code>quit</code> : 退出GDB<br><code>run [命令行参数]</code>： 运行程序（并给出命令行参数）<br><code>kill</code>：停止程序</p>
</li>
<li><p><strong>断点</strong></p>
<p><code>break sum</code>：在函数sum入口处设置断点<br><code>break *0x80483625</code>：在地址0x80483625处设置断点<br><code>delete 1</code>：删除断点1<br><code>delete</code>：删除所有断点<br><code>commands &lt;断点号&gt;</code>：在到达断点时执行命令</p>
</li>
<li><p><strong>执行</strong></p>
<p><code>stepi</code>：执行1条指令<br><code>stepi 4</code>：执行4条指令<br><code>nexti</code>：执行下一条指令<br><code>continue</code> : 继续执行<br><code>finish</code>：运行直到当前函数返回</p>
</li>
<li><p><strong>检查代码</strong></p>
<p><code>disas</code>：反汇编当前函数<br><code>disas sum</code>：反汇编sum函数<br><code>disas 0x8048397</code>：反汇编0x8048397附近的函数<br><code>disas 0xA 0xB</code>：反汇编指定地址范围内的代码<br><code>print /x $eip</code>：以16进制打印寄存器的值</p>
</li>
<li><p><strong>检查数据</strong></p>
<p><code>print $eip</code><br><code>print /t $eip</code><br><code>print 0x100</code><br><code>print /x 555</code><br><code>print /x ($ebp+8)</code><br><code>print *(int*) 0xfff076b0</code> ：输出地址0xfff076b0处的整数<br><code>print *(int*) ($ebp+8)</code> ：输出地址($ebp+8)处的整数<br><code>x/2w 0xfff076b0</code>：检查从0xfff076b0地址处开始的双字<br><code>x/20b sum</code>：检查函数sum的前20个字节<br><code>backtrace</code>：打印程序栈<br><code>list [行号或函数名]</code>：打印当前位置（或指定位置）处周围代码<br><code>@&lt;number&gt;</code>：打印指定数目的数组元素<br><code>display &lt;exp&gt;</code></p>
</li>
<li><p><strong>信息</strong></p>
<p><code>info frame</code>：打印当前栈帧<br><code>info registers</code>：打印寄存器<br><code>help</code>：帮助</p>
</li>
</ul>
<h3 id="Profiling-and-Optimising"><a href="#Profiling-and-Optimising" class="headerlink" title="Profiling and Optimising"></a>Profiling and Optimising</h3><ul>
<li>gprof</li>
<li>valgrind</li>
</ul>
<h3 id="ARM开发工具链"><a href="#ARM开发工具链" class="headerlink" title="ARM开发工具链"></a>ARM开发工具链</h3><p>&emsp;&emsp; 参考 <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">GNU Arm开发工具链</a></p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Gaussian Elimination Method For Flip Game</title>
    <url>/2024/12/26/Gaussian-Elimination-Method-For-Flip-Game/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Git版本控制系统结构和命令手册</title>
    <url>/2022/04/29/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp; Git作为一个强大的开源的分布式版本控制系统，在设计开发时为自己提出了一些目标：效率、简单设计、支持非线性开发、完全的分布式和高效地处理大型项目（如Linux内核），Git的最终实现完成了大部分目标。</p>
<span id="more"></span>

<h3 id="核心模型"><a href="#核心模型" class="headerlink" title="核心模型"></a>核心模型</h3><p>&emsp;&emsp; Git是完全的<strong>分布式版本控制</strong>，即每一个客户端都保存项目的全部文件以及历史，即使服务器崩溃，它也可以从任何一个客户端那里获得镜像进行恢复。<br>&emsp;&emsp; Git将所有数据都抽象为 <strong>快照流</strong> （<code>Streams of Snapshots</code>）。</p>
<p><img src="/2022/04/29/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/git_data_model.png"></p>
<p>&emsp;&emsp;Git保证 <strong>文件完整性</strong>，它对每个文件会生成签名校验。<br>&emsp;&emsp;Git将文件的状态分为三种：<code>Modified</code> -&gt; <code>Staged</code> -&gt; <code>Commited</code></p>
<h3 id="分支功能"><a href="#分支功能" class="headerlink" title="分支功能"></a>分支功能</h3><p>&emsp;&emsp; Git的杀手级特性是它的分支功能。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p><strong>配置工具</strong></p>
<p><code>git config --global user.name &quot;[name]&quot;</code><br><code>git config --global user.email &quot;[email address]&quot;</code><br><code>git config --global color.ui auto</code><br><code>git config --global core.editor &quot;[vim|emacs]&quot;</code></p>
</li>
<li><p><strong>分支</strong></p>
<p><code>git branch [branch-name]</code> 创建新分支<br><code>git switch -c [branch-name]</code> 切换到指定分支并更新工作目录<br><code>git merge [branch-name]</code> 将指定分支的历史合并到当前分支，git会处理过程中可能会出现的冲突问题。<br><code>git branch -d [branch-name]</code> 删除指定分支<br><code>git stash</code> 储藏当前脏工作目录下的修改；该命令经常用于下面的场景：当想切换到另一个分支修复Bug，但又不想提交当前分支下的修改，这时候可以使用 <code>git stash</code> 来储存当前修改，后面可以使用<code>git stash pop</code> 恢复；另外其储存内容<strong>不会</strong> <code>git push</code> 到服务器。</p>
</li>
<li><p><strong>进行更改</strong></p>
<p><code>git log</code> 当前分支的历史<br><code>git log --follow [file]</code> 列出文件的版本历史，包括重命名<br><code>git diff [first-branch]...[second-branch]</code> 两个分支的内容差异<br><code>git show [commit]</code> 显示指定commit的元数据和内容变化<br><code>git add [file]</code> 将文件进行快照处理，即进入staged域<br><code>git commit -m &quot;[descriptive message]&quot;</code>将文件快照永久地记录在版本历史中</p>
</li>
<li><p><strong>重做提交</strong></p>
<p><code>git reset  [commit]</code> 撤销所有commit后的提交，在本地保存更改<br><code>git reset --soft [commit]</code> 保留历史，改回指定提交<br><code>git reset --hard [commit]</code> 放弃所有历史，改回指定提交<br><code>git commit --amend </code>对commit的反悔<br><code>git reset HEAD &lt;file&gt;...</code> 对add命令的撤回<br><code>git checkout -- &lt;file&gt;</code> 对一个Modified的文件撤回修改</p>
</li>
<li><p><strong>创建仓库</strong></p>
<p><code>git init</code> 创建新的仓库<br><code>git remote add origin [url]</code> 将本地仓库与远程仓库连接起来<br><code>git remote show [remote-name]</code><br><code>git remote rename</code> 改变远程仓库的名字<br><code>git clone [url]</code> 镜像远程仓库到本地</p>
</li>
<li><p><strong>标签tag</strong></p>
<p><code>git tag</code> 列出标签<br><code>git tag -a [tag-name]</code> 创建annotated类型的标签，该类型标签比较正式，它指向所有信息<br><code>git tag [tag-name]</code> 创建lightweight类型的标签，不正式，临时指向小部分信息<br><code>git show [tag-name]</code> 显示标签信息<br><code>git tag -a [tag-name] [commit-checksum]</code> 给某次提交添加tag</p>
</li>
<li><p><strong>同步更改</strong><br><code>git fetch</code> 下载远程跟踪分支的全部历史，它只获取本地没有的那部分数据，clone命令封装了fetch命令<br><code>git push</code> 将所有本地分支上传到远程服务器<br><code>git merge</code> 将远端跟踪分支合并到当前本地分支<br><code>git pull</code> 使用来自对应远端分支的所有新提交更新你当前的本地工作分支。git pull是 git fetch 和 git merge 的结合。</p>
</li>
<li><p><strong>子模块</strong> ：</p>
<blockquote>
<p>子模块允许用户将一个git仓库作为另一个git仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
</blockquote>
<p>  <code>git submodule add [url]</code><br>  <code>git submodule init</code> 初始化本地配置文件<br>  <code>git submodule update</code> 该项目中抓取所有数据并检出父项目中列出的合适的提交<br>  <code>git clone --recurse-submodules [url]</code> 自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。<br>  <code>git submodule update --remote --init</code></p>
</li>
<li><p><strong>Patching:</strong><br><code>git apply --stat xxxx.patch</code> 检查 patch 文件<br><code>git apply --check xxxx.patch</code> 检查能否应用成功<br><code>git am --signoff &lt; xxxx.patch</code> 应用补丁</p>
</li>
<li><p><strong>调试:</strong><br><code>git blame</code>: 追溯一个文件的历史修改记录。</p>
</li>
</ul>
<h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h3><p>参考<a href="https://git-scm.com/docs/gitignore">gitignore文件指导</a></p>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>使用 <code>wget</code> 下载 github 上的单个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -L https://raw.github.com/[user name]/[repositorty name]/[branch]/[file].</span></span><br></pre></td></tr></table></figure>

<p>如果遇到类似下面的错误报告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -L https://raw.github.com/[user name]/[repositorty name]/[branch]/[file].</span></span><br><span class="line">...</span><br><span class="line">正在解析主机 raw.githubusercontent.com (raw.githubusercontent.com)... 0.0.0.0, ::</span><br><span class="line">正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|0.0.0.0|:443... 失败：拒绝连接。</span><br><span class="line">正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|::|:443... 失败：拒绝连接。</span><br></pre></td></tr></table></figure>

<p>则可以修改 <code>/etc/hosts</code> 文件，使得对 <code>raw.github.com</code> 域名的解析指向国内可以访问的 IP 地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/hosts</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hong Kong</span></span><br><span class="line">151.101.76.133 raw.githubusercontent.com</span><br><span class="line">151.101.76.133 raw.github.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h3><ul>
<li><strong>commit 提交</strong>: 一个 Git 对象，是你整个仓库的快照的哈希值</li>
<li><strong>branch 分支</strong>: 一个轻型可移动的 commit 指针</li>
<li><strong>clone</strong>: 一个仓库的本地版本，包含所有提交和分支</li>
<li><strong>remote 远端</strong>: 一个 GitHub 上的公共仓库，所有小组成员通过它来交换修改</li>
<li><strong>fork</strong>: 一个属于另一用户的 GitHub 上的仓库的副本</li>
<li><strong>pull request 拉取请求</strong>: 一处用于比较和讨论分支上引入的差异，且具有评审、评论、集成测试等功能的地方</li>
<li><strong>HEAD</strong>: 代表你当前的工作目录。使用git checkout 可移动 HEAD 指针到不同的分支、标记(tags)或提交。</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://git-scm.com/docs">Git 参考手册</a><br><a href="https://git-scm.com/docs/giteveryday">Everyday Git</a></p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Go Language Tutorial</title>
    <url>/2024/12/15/Go-Language-Tutorial/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://golang.google.cn/">Go</a> 最初在 2007 年由工作在谷歌的 Robert Griesemer，Rob Pike 和 Ken Thompson（C语言和 Unix 的发明人）提出构想<br>，并在 2009 年正式发布。Go及其工具的目标致力于在编译、执行上的效率和表达能力，并致力于高效地编写可靠和健壮的程序。</p>
<p>Go 的特性包括：高并发、灵活的数据抽象和面向对象和垃圾收集。<br>Go 的哲学包括：</p>
<ul>
<li>简洁（Simplicity）:没有隐式数值转换、没有构造器和析构器、没有运算符重载、没有支持默认参数值、不支持继承、不支持范型、不支持异常、不支持宏、不支持函数注、不支持线程本地存储。</li>
</ul>
<span id="more"></span>


<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>设置代理（加速第三方模块的下载）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置代理</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查一下环境变量</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span> | grep GOPROXY</span></span><br><span class="line">GOPROXY=&#x27;https://goproxy.cn,direct&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go 语言</category>
      </categories>
  </entry>
  <entry>
    <title>Go 语言中的 Defer，Panic 和 Recover</title>
    <url>/2024/12/17/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-Defer%EF%BC%8CPanic-%E5%92%8C-Recover/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Go拥有一些通用的控制流机制：<code>if</code>，<code>for</code>，<code>switch</code>，<code>goto</code>。同时，Go可以使用 <code>go</code> 语句将代码运行在一个独立的 <code>goroutine</code> 中。但本文想要讨论一些不太常用的控制流机制：<code>defer</code>，<code>panic</code> 和 <code>recover</code>。</p>
<blockquote>
<p>翻译自 <a href="https://golang.google.cn/blog/defer-panic-and-recover">Defer, Panic, and Recover - Go Blog</a></p>
</blockquote>
<span id="more"></span>
]]></content>
      <categories>
        <category>Go 语言</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 简介和使用手册</title>
    <url>/2024/07/14/Hexo-%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个快速、简洁且高效的博客框架。它基于 NodeJs 开发，支持 MarkDown 等多种渲染引擎， 可以快速生成静态网页。<br>Hexo 也支持多种主题和插件。</p>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>详细信息可另行参考 <a href="https://hexo.io/zh-cn/docs/">Hexo 官方手册</a>。</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><ul>
<li><a href="http://nodejs.org/">NodeJS</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>
<li>Git</li>
</ul>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p><code>$ npm install -g hexo-cli</code></p>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>安装好 Hexo 后，需要使用 Hexo 的命令新建项目，生成项目文件夹，包括配置文件、脚本、辅助工具、模板、主题等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install</span></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 _config.yml 中配置 Markdown 属性，禁止将回车转换为 <code>&lt;br&gt;</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h3 id="支持数学表达式"><a href="#支持数学表达式" class="headerlink" title="支持数学表达式"></a>支持数学表达式</h3><p>更换 Hexo 的 markdown 渲染引擎，<code>hexo-renderer-kramed</code>引擎是在默认的渲染引擎<code>hexo-renderer-marked</code>的基础上修改了一些 bug，两者比较接近，也比较轻量级。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm uninstall hexo-renderer-marked --save  <span class="comment"># 卸载原引擎</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-renderer-kramed --save  <span class="comment"># 安装新引擎</span></span></span><br></pre></td></tr></table></figure>



<h3 id="生成和部署"><a href="#生成和部署" class="headerlink" title="生成和部署"></a>生成和部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo deploy</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web 应用</category>
      </categories>
  </entry>
  <entry>
    <title>IPsec Protocol Analysis</title>
    <url>/2024/12/19/IPsec-Protocol-Analysis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>IPv4</code> 是应用最为广泛的网络层协议，它组成了如今 Internet 的核心。IPv4 协议是无状态、无认证、无加密协议，也没有带宽控制支持，很容易收到多方面的攻击。  </p>
<p>为了解决 IPv4 存在的安全问题，IETF 设计了端到端的确保 IP 通信安全的机制，称为<code>IPSec (IP Security)</code>。</p>
<span id="more"></span>

<p>IPSec 标准之间的关系：<br><img src="/2024/12/19/IPsec-Protocol-Analysis/IPsec.png"></p>
<p>协议解释：</p>
<ul>
<li>认证头（AH）：为 IP 数据报提供<strong>无连接数据完整性</strong>、<strong>消息认证</strong>以及<strong>防重放攻击保护</strong>。</li>
<li>封装安全载荷（ESP）：提供机密性、数据源认证、无连接完整性、防重放和有限的传输流机密性。</li>
<li>安全关联（SA）：提供算法和数据包，提供 AH、ESP 操作所需要的参数。</li>
<li>密钥协议（IKE）：提供对称密钥的生成和交换。</li>
</ul>
<p>IPSec 的主要用途之一就是用来构建 <code>VPN</code>。</p>
<h2 id="IPSec-Security-Policy"><a href="#IPSec-Security-Policy" class="headerlink" title="IPSec Security Policy"></a>IPSec Security Policy</h2><p>IPSec 操作的基础是应用于每一个从源端到目标端传输的 IP 包上的安全策略。  </p>
<p>SA（Security Association） 安全关联。SA 是通信双方之间的单向逻辑连接，为通信数据流提供安全服务。所有经过同一 SA 的数据流会得到相同的安全服务。如果源端和目标端需要双向安全数据交换，则需要建立两个 SA，称为 “SA对”。  </p>
<h2 id="IPSec-Mode"><a href="#IPSec-Mode" class="headerlink" title="IPSec Mode"></a>IPSec Mode</h2>]]></content>
      <categories>
        <category>信息安全</category>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title>Keras 深度学习框架使用总结</title>
    <url>/2025/04/02/Keras-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>神经网络在 2012 年后被认为是机器学习领域最受关注的技术，而在神经网络的技术中，<code>深度卷积神经网络</code>已经成为所有计算机视觉任务的首选算法。<code>深度学习</code>利用在计算机视觉上的两个关键思想：<code>卷积神经网络</code>和<code>反向传播</code>，并在数据的学习上，通过渐进的、逐层的方式形成越来越复杂的表示，并对中间的渐进表示共同进行学习。</p>
<p>深度学习的框架包括<code>TensorFlow</code>、<code>PyTorch</code>和 <code>Keras</code>等，其中 <code>JAX</code>、<code>TensorFlow</code>和 <code>PyTorch</code>可以作为 <code>Keras</code> 的 <strong>后端(backend)</strong> 来进行张量处理、求微分等低层次的运算。本文就 <code>Keras</code> 的实践以及深度学习的一些理论进行总结。</p>
<span id="more"></span>

<blockquote>
<p>参考 《Deep Learning with Python》 By【美】弗朗索瓦·肖莱<br>参考 《Advanced Deep Learning with Python》By【保加利亚】伊凡·瓦西列夫</p>
</blockquote>
<h2 id="神经网络的数学基础"><a href="#神经网络的数学基础" class="headerlink" title="神经网络的数学基础"></a>神经网络的数学基础</h2><p>参考 《DLP》</p>
<h3 id="随机变量和概率分布"><a href="#随机变量和概率分布" class="headerlink" title="随机变量和概率分布"></a>随机变量和概率分布</h3><p>通常情况下，神经网络产生一些输出概率分布 $ Q(x) $，在训练中将其与目标分布 $ P(x) $ 进行比较。可以用<code>交叉熵</code>来定义两个分布的距离：<br>$$ H(P, Q) &#x3D; -\displaystyle\sum_{i&#x3D;1}^n P(X&#x3D;x_i)logQ(X&#x3D;x_i)$$</p>
<p><code>交叉熵损失</code>定义为：<br>$$ Loss &#x3D; - \displaystyle\sum_{i&#x3D;1}^n y_ilog{x_i} $$</p>
<p>其中，$ y_i $ 是训练标签值，$ x_i $ 是预测值。</p>
<h2 id="安装及初步使用"><a href="#安装及初步使用" class="headerlink" title="安装及初步使用"></a>安装及初步使用</h2><h3 id="安装依赖（可选）"><a href="#安装依赖（可选）" class="headerlink" title="安装依赖（可选）"></a>安装依赖（可选）</h3><ol>
<li>如果主机上配备有 <code>GPU</code>，确保驱动正常工作。如果没有 NVIDIA 的 GPU，而是使用 Intel 的集成显卡，需要下载 <code>oneAPI</code> 计算平台和 <code>oneDNN</code> 深度学习加速库。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install libdnnl2 libdnnl-dev</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果使用树梅派等平台，可以安装 GPU 加速库（<code>OpenCL</code>和<code>OpenCV</code>），参考<a href="https://blog.csdn.net/qq_38342510/article/details/143098708">树莓派5 gpu 加速</a>。</p>
<ol start="2">
<li><p>安装 <code>BLAS</code> 线性代数库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install libopenblas-dev liblapack-dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Python 科学计算套件：<code>Numpy</code>、<code>Scipy</code> 和 <code>matplotlib</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install python3-numpy python3-scipy python3-matplotlib</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 <code>HDF5</code>，用于将 <code>Keras</code> 模型快速高效地保存到磁盘：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install python3-h5py python3-h5py-serial</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 <code>CUDA</code>:<br>参考 <a href="/2023/04/12/CUDA-Tutorial/" title="CUDA Tutorial">[CUDA Tutorial]</a> 。</p>
</li>
</ol>
<h3 id="安装-keras"><a href="#安装-keras" class="headerlink" title="安装 keras"></a>安装 keras</h3><ol>
<li><p>新建虚拟环境并激活</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3 -m venv venv</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> venv/bin/activate</span></span><br><span class="line">(venv) $</span><br></pre></td></tr></table></figure></li>
<li><p>安装后端（默认使用 <code>TensorFlow</code>）:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(venv) $ pip3 install tensorflow</span><br></pre></td></tr></table></figure>
<p>在 <code>~/.keras/keras.json</code> 中可以修改使用的后端类型。</p>
</li>
<li><p>安装 <code>keras</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(venv) $ pip3 install keras</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keras</span><br><span class="line">...</span><br><span class="line">W0000 <span class="number">00</span>:<span class="number">00</span>:<span class="number">1743605807.792365</span>   <span class="number">17935</span> computation_placer.cc:<span class="number">177</span>] computation placer already registered. Please check linkage <span class="keyword">and</span> avoid linking the same target more than once.</span><br><span class="line">W0000 <span class="number">00</span>:<span class="number">00</span>:<span class="number">1743605807.792367</span>   <span class="number">17935</span> computation_placer.cc:<span class="number">177</span>] computation placer already registered. Please check linkage <span class="keyword">and</span> avoid linking the same target more than once.</span><br><span class="line"><span class="number">2025</span>-04-02 <span class="number">22</span>:<span class="number">56</span>:<span class="number">47.795267</span>: I tensorflow/core/platform/cpu_feature_guard.cc:<span class="number">210</span>] This TensorFlow binary <span class="keyword">is</span> optimized to use available CPU instructions <span class="keyword">in</span> performance-critical operations.</span><br><span class="line">To enable the following instructions: AVX2 AVX_VNNI FMA, <span class="keyword">in</span> other operations, rebuild TensorFlow <span class="keyword">with</span> the appropriate compiler flags.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keras.__version__</span><br><span class="line"><span class="string">&#x27;3.9.1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用 <a href="https://storage.googleapis.com/tensorflow/tf-keras-datasets/mnist.npz">MNIST</a> 数据集，它是机器学习领域的一个经典数据库，用于手写数字的自动识别（最先用于邮政业务中的邮编识别）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()</span><br></pre></td></tr></table></figure>

<p>如果没有下载 <code>MNIST</code>，上述代码会自动将其下载到 <code>~/.keras/datasets/</code> 目录中。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="软件栈和硬件栈"><a href="#软件栈和硬件栈" class="headerlink" title="软件栈和硬件栈"></a>软件栈和硬件栈</h3><p><img src="/2025/04/02/Keras-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/keras_stack.png"></p>
<p>Keras 具有的特性：</p>
<ul>
<li>相同的代码可以无缝切换到不同的后端，也就可以在 CPU 和 GPU 上无缝切换运行。</li>
<li>用户友好 API</li>
<li>支持任意网络架构</li>
</ul>
<h2 id="用户API"><a href="#用户API" class="headerlink" title="用户API"></a>用户API</h2><h3 id="激活器"><a href="#激活器" class="headerlink" title="激活器"></a>激活器</h3><blockquote>
<p>如果没有 <code>relu</code> 这样的激活函数（非线性函数），<code>Dense</code> 层只包含线性运算，这样就只能学习输入数据的 <code>线性变换（仿射变换）</code>。这种所有线性变换组成的<code>假设空间</code>非常有限，无法利用多个多个表示层的优势，因为多个线性层堆叠实现的仍然是线性运算。</p>
</blockquote>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>最常见的机器学习任务：<code>二分类问题</code>、<code>多分类问题</code>和<code>标量回归问题</code> 所使用的损失函数是不同的。<code>标量回归问题</code>的常用损失函数是 <code>均方误差（MSE）</code>。</p>
<p>同样，回归问题的评估指标与分类问题不同，常见的回归指标是<code>平均绝对误差（MAE）</code>。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习的分支很复杂，大致分为<code>监督学习</code>、<code>非监督学习</code>、<code>自监督学习</code>和<code>强化学习</code>。</p>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p><code>二分类问题</code>、<code>多分类问题</code>和<code>标量回归问题</code>都是<code>监督学习（supervised learning）</code>的例子。 监督学习的目标是学习训练输入和训练目标之间的关系，其中训练目标是由人工标注的<code>正确答案</code>。</p>
<p>监督学习的其他变体：</p>
<ul>
<li>序列生成</li>
<li>语法树预测</li>
<li>目标检测</li>
<li>图像分割</li>
</ul>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><blockquote>
<p><code>无监督学习</code>是指在没有目标的情况下寻找输入数据的变换，其目的在于<code>数据可视化</code>、<code>数据压缩</code>、<code>数据去噪</code>或更好地理解数据中的相关性。</p>
</blockquote>
<blockquote>
<p><code>降维（dimensionality）</code>和 <code>聚类（clustering）</code> 都是众所周知的无监督学习方法。</p>
</blockquote>
<p>对于没有标签的数据，<code>聚类（clustering）</code>算法可以将样本数据分为不同的数据簇。</p>
<h3 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h3><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><h4 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h4><p>泛化</p>
<p>数据集：<code>训练集</code>、<code>验证集</code>和<code>测试集</code>。</p>
<h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><blockquote>
<p>卷积层和密集连接层的区别在于，<code>Dense</code>层从输入特征空间中学到的是全局模式，而卷积层学到的是局部模式。<br>卷积神经网络的两个重要性质：<code>平移不变形</code>和<code>模式的空间层次结构</code>。</p>
</blockquote>
<p>卷积运算</p>
<blockquote>
<p>深度神经网络学到的表示的一个重要普遍特征：随着层数的加深，层所提取的特征变得越来越抽象。更高的层激活包含关于特定输入的信息越来越少，而关于目标的信息越来越多。深度神经网络可以有效地作为<code>信息蒸馏管道</code>，输入原始数据，反复对其进行变换，将无关信息过滤掉，并放大和细化有用的信息。</p>
</blockquote>
]]></content>
      <categories>
        <category>人工智能</category>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>LFS 0: LFS 项目介绍</title>
    <url>/2021/04/05/LFS-0-LFS-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;<a href="https://www.linuxfromscratch.org/">LFS（Linux From Scratch）</a>项目由Gerard Beekmans于1999年发起，它的目的是指导用户一步步从源代码构建整个Linux系统的所有组件，直到得到一个完全属于自己的 Working Linux 系统。LFS 项目充分体现了一种自己动手探索和学习的精神，也体现了 Linux 及相关开源社区的精神。</p>
<span id="more"></span>

<p>&emsp;&emsp;在 LFS 的作者看来，充分理解 Linux 系统的内部的各个组件以及它们的相互关系，可以使用户获得能力来定制化自己的操作系统；用户可以不依赖于一些现成的Linux 系统，自己可以更加灵活地掌握控制系统的各个层面。另外，用户可以获得更加小巧紧凑的系统，不用安装一些不需要或者不理解的软件，这样可以节省资源，特别对于一些资源敏感的嵌入式系统。最后，这样构建的系统更加安全，用户可以随时从源代码编译、测试和安装安全补丁，而不是依赖他人。</p>
<p>&emsp;&emsp;LFS 项目的主体是一份手册，现在最新版本是11.3（2023年3月1日），任何人都可以从官方网站 <a href="http://www.linuxfromscratch.org/">LinuxFromScratch</a> 获得，另外注意下载软件包时选择合适的镜像可以缩短下载时间。<br>&emsp;&emsp;BLFS、CLFS 和 ALFS 项目是由 LFS 项目扩展衍生出来的。</p>
<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>&emsp;&emsp;LFS <strong>尽可能</strong>遵循下面的标准（但软件包的最终选择还是由用户决定）：</p>
<ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/">POSIX.1-2008</a></li>
<li><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html">Filesystem Hierarchy Standard (FHS) Version 3.0</a></li>
<li><a href="https://refspecs.linuxfoundation.org/lsb.shtml">Linux Standard Base (LSB) Version 5.0 (2015)</a></li>
</ul>
<p>&emsp;&emsp;LFS 中包含的属于 LSB 的软件包：</p>
<ul>
<li><strong>LSB Core</strong>: <code>Bash</code>, <code>BC</code>, <code>Binutils</code>,<code>Coreutils</code>,<code>Diffutils</code>,<code>File</code>,<code>Findutils</code>,<code>Gawk</code>,<code>Grep</code>,<code>Gzip</code>,<code>M4</code>, <code>Man-DB</code>,<code>Ncureses</code>,<code>Procps</code>,<code>Psmisc</code>,<code>Sed</code>,<code>Shasow</code>,<code>Tar</code>,<code>Util-Linux</code>,<code>Zlib</code></li>
<li><strong>LSB Runtime Languages</strong>: <code>Perl</code>,<code>Python</code></li>
</ul>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>&emsp;&emsp;一个系统可以复制它自己，这如何做到呢？对于操作系统来说，如果它拥有关于自己的所有源代码，它如何一步步构建可以移植到不同处理器架构的机器上的自己呢？</p>
<p>&emsp;&emsp;Linux 系统与 Unix 传统相同，它的内核及大部分组件（一些来源于 GNU 项目）由 C 语言编写（ Linux  内核中会部分包含一些汇编代码），即它可以通过 C 编译器移植到任何硬件平台上。</p>
<p>&emsp;&emsp;交叉编译（Cross Compilation）是指我们在一个系统平台上（如 x86 ）编译可以在其他系统平台（如 ARM ）上运行的可执行代码，那么它在什么情况下最经常使用呢？</p>
<p>&emsp;&emsp;首先，在很多情况下，目标平台由于资源限制，没有现成的编译器及开发测试环境，甚至没有操作系统，而用于开发的系统要使用更快速性能更高的完全不同的平台。</p>
<p>&emsp;&emsp;另外，交叉编译可以使用一个编译环境来生成针对不同目标平台的系统，（例如 <a href="https://launchpad.net/">Launchpad平台</a> 就提供了帮助开发者交叉编译、打包和发布的功能）。</p>
<p>&emsp;&emsp;最后，交叉编译可以针对系统模拟器生成可执行代码，这些模拟器所模拟的硬件平台可能是非常老的系统，原来的编译环境（native compiler）已经很难搭建。</p>
<p>&emsp;&emsp;LFS Book 中介绍了 Canadian Cross 交叉编译模式，它假设了三个机器A，B 和 C。慢机器 A 安装有 ccA 原生编译器，快机器 B 没有编译器，目标是生成在慢机器 C 上运行的软件。</p>
<p>第一步：使用 ccA 生成目标 (Target) 为机器 B 的交叉编译器 cc1，注意 cc1 运行在(Host)机器 A 上，但它生成的是针对机器 B 的可执行代码。</p>
<p>第二步：使用 cc1 生成目标为机器 C 的交叉编译器 cc2，注意 cc2 运行在(Host)在机器 B上，但它生成的是针对机器 C 的可执行代码。</p>
<p>第三步：在机器 B 上运行 cc2，使用它来生成 ccC 原生编译器，它将运行在(Host)机器 C上，机器 C 上的其他程序也可以在机器 B 上通过 cc2 编译生成。</p>
<p>&emsp;&emsp;LFS Book 中使用伪交叉编译(Fake Cross Compilation)，因为对于大多数读者来说，构建LFS的系统和运行LFS的是同一系统。LFS首先使用原生编译器 cc-pc 构建交叉编译器 cc1，cc1 的 Host 系统为 pc，Target 系统是 lfs ；第二步是使用 cc1 生成原生编译器 cc-lfs，cc-lfs 则用在 chroot 环境构建整个 lfs 系统。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p><strong>a. 创建新分区</strong></p>
<p>&emsp;&emsp;将 LFS 安装到单独的分区是一种良好的实践，我们可以简单使用 <code>fdisk</code>或<code>parted</code> 分配一个10G-30G（根据需要增加）容量的新分区。除了主分区，其他分区（如<code>swap分区</code>）可以简单使用 Host 上已经有的分区。关于分区的具体知识，参考 <a href="http://1.117.83.246/index.php/archives/28/">关于计算机操作系统启动引导的总结</a>。</p>
<p><strong>b. 格式化文件系统</strong></p>
<p><code>mkfs -v -t ext4 /dev/xxx</code></p>
<p>**c. 设置 <code>$LFS</code> 环境变量 **</p>
<p><code>export LFS=/mnt/lfs</code><br>另外也可以将上述命令写入 <code>~/.bash_profile</code> 或 <code>~/.bashrc</code> 文件。</p>
<p><strong>d. 挂载分区</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -pv $LFS</span><br><span class="line">mount -v -t ext4 /dev/xxx $LFS</span><br></pre></td></tr></table></figure>
<p>如果有其他新建分区，也要在 $LFS 中创建挂载点并进行挂载。<br>为了在系统重启后不需要再次手动执行挂载，可以在 <code>/etc/fstab</code> 中添加：</p>
<p><code>/dev/xxx     /mnt/lfs     ext4    default</code></p>
<p>如果使用 <code>swap</code> 分区，请确定它已经激活：<br><code>/sbin/swapon -v /dev/zzz</code></p>
<h3 id="获取软件包"><a href="#获取软件包" class="headerlink" title="获取软件包"></a>获取软件包</h3><p>下载软件包：<a href="https://mirrors.ustc.edu.cn/lfs/lfs-packages/">中国境内的镜像地址</a></p>
<p>解压到 <code>$LFS/source</code>目录， 并设置 <code>sticky</code> 标志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -v $LFS/source</span><br><span class="line">chmod -v a+wt $LFS/source </span><br></pre></td></tr></table></figure>
<p>如果上诉步骤使用非 root 用户操作，则所有文件的 UID 和 GID 都是该用户的 UID 和 GID。当后面 <code>chroot</code> 进入没有创建该用户的 lfs 系统，GID 和 UID就无效了，所以我们提前将所有文件的 owner 和 group 设置为 <code>root</code>:</p>
<p><code>chown root:root $LFS/source/*</code></p>
<h3 id="最后的准备工作"><a href="#最后的准备工作" class="headerlink" title="最后的准备工作"></a>最后的准备工作</h3><p><strong>a. 以 <code>root</code> 用户创建根目录结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -pv $LFS/&#123;etc,var&#125; $LFS/usr/&#123;bin,lib,sbin&#125;</span><br><span class="line">for i in bin lib sbin; do</span><br><span class="line">    ln -sv usr/$i $LFS/$i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">case $(uname -m) in</span><br><span class="line">x86_64) mkdir -pv $LFS/lib64 ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>中间过程会生成一些交互编译工具链，这些工具应该与最后的根目录中的程序隔离，因此创建 <code>tool</code> 目录：<br><code>mkdir -pv $LFS/tool</code></p>
<p>**b.创建 <code>lfs</code> 用户和 <code>lfs</code>用户组 **<br>为了获得更加干净的工作环境，建议新建 lfs 用户和用户组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd lfs</span><br><span class="line">useradd -s /bin/bash -g lfs -m -k /dev/null lfs</span><br></pre></td></tr></table></figure>
<p>设置口令（可选）：<br><code>passwd lfs</code></p>
<p><strong>c. 将<code>lfs</code>设置为 $LFS 根目录的 owner:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -v lfs $LFS/&#123;usr&#123;,/*&#125;,lib,var,etc,bin,sbin,tools&#125;</span><br><span class="line"></span><br><span class="line">case $(uname -m) in</span><br><span class="line">x86_64) chown -v lfs $LFS/lib64 ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>注意不包括 <code>$LFS/source</code></p>
<p><strong>d. 切换到 <code>lfs</code> 用户：</strong><br><code>su - lfs</code></p>
<p><strong>e. 设置环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; ~/.bash_profile &lt;&lt; &quot;EOF&quot;</span><br><span class="line">exec env -i HOME=$HOME TERM=$TERM PS1=&#x27;\u:\w\$ &#x27; /bin/bash</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>注意目前的 <code>~</code> 现在代表 lfs 的<code>home</code> 目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; ~/.bashrc &lt;&lt; &quot;EOF&quot;</span><br><span class="line">set +h         ## 关闭 bash 的 Hash 功能</span><br><span class="line">umask 022</span><br><span class="line">LFS=/mnt/lfs   ## 重要!!!</span><br><span class="line">LC_ALL=POSIX</span><br><span class="line">LFS_TGT=$(uname -m)-lfs-linux-gnu   ## 重要!!!</span><br><span class="line">PATH=/usr/bin</span><br><span class="line">if [ ! -L /bin ]; then PATH=/bin:$PATH; fi</span><br><span class="line">PATH=$LFS/tools/bin:$PATH           ## 重要 !!!</span><br><span class="line">CONFIG_SITE=$LFS/usr/share/config.site</span><br><span class="line">export LFS LC_ALL LFS_TGT PATH CONFIG_SITE</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>生效：<br><code>source ~/.bash_profile</code></p>
<h2 id="构建工具链和临时工具"><a href="#构建工具链和临时工具" class="headerlink" title="构建工具链和临时工具"></a>构建工具链和临时工具</h2><h3 id="编译交叉工具链-Pass-1"><a href="#编译交叉工具链-Pass-1" class="headerlink" title="编译交叉工具链 Pass 1"></a>编译交叉工具链 Pass 1</h3><p>&emsp;&emsp;该节所生成的程序和库都会安装到特定的目录<code>$LFS/tool</code>中，以便将交叉编译工具与其他程序分开。</p>
<p>&emsp;&emsp;首先是 Binutils 包的第一次编译(Pass1)，它会生成交叉汇编器 (cross-as)、交叉链接器(cross-ld)等，这些工具在对 gcc 和 glibc 编译时使用。</p>
<p>&emsp;&emsp;然后是 gcc 包的第一次编译(Pass1)，特别注意 configure 脚本的配置选项。因为 GCC 依赖一个内部库 libgcc，它需要链接 glibc 才能具有全部的功能，而此时我们还没有 glibc，另外 C++ 库(libstdc++)也依赖 glibc。对这个“蛋-&gt;鸡-&gt;蛋”问题的解决方法是生成退化的(degraded) libgcc（当然此时生成的 <code>cc1</code> 也是退化的），它缺少一些功能（例如线程和异常处理）。然后使用 <code>cc1</code> 编译 glibc（glibc 不是退化的）。接着编译libstdc++（缺少一些 libgcc 的功能）。最后当我们获得 cc-lfs 后再生成完全的 libstdc++ 库（<code>Pass 2</code>）。这个阶段的配置选项要避免对 libc 和 libstdc++ 的依赖，以及避免编译一些不需要的组件。</p>
<p>&emsp;&emsp;安装Linux API 头文件，它们在编译 glibc 时会使用。</p>
<p>&emsp;&emsp;编译 glibc，configure 脚本中的 –host 和 –build 选项要特别注意：要保证使用我们上述生成的交叉工具链而不是 Host 系统中的工具。注意 glibc 库不是交叉工具链，所以其安装目录是 <code>/usr</code>，通过 <code>--prefix=/usr</code> 设置。另外，这里的 <code>/usr</code> 是相对路径。（因为 <code>make DESTDIR=$LFS install</code>，glibc 被安装到 <code>$LFS/usr</code>。）</p>
<p>&emsp;&emsp;libstdc++ 第一次编译(Pass1)，生成 C++ 库。安装路径同样是 <code>$LFS/usr</code>。</p>
<h3 id="交叉编译临时工具和-Pass-2"><a href="#交叉编译临时工具和-Pass-2" class="headerlink" title="交叉编译临时工具和 Pass 2"></a>交叉编译临时工具和 Pass 2</h3><p>&emsp;&emsp;这些临时工具安装到最后的位置，但还不能使用，因为它们还依赖于 Host 系统上的一些工具，但它们可以链接已经安装的库，比如 glibc。</p>
<p>&emsp;&emsp;在进入 chroot 环境时，这些临时工具是必要的，而不是在 chroot 之后再编译它们，比如 bash。它们的依赖关系是怎样的以及为什么选择它们呢？</p>
<p>&emsp;&emsp;M4 包被用于编译工具，Ncurses 包被 Bash 包依赖，Bash 包是进入 chroot 的必要工具。Coreutils 包含一些基本工具，例如操作文件和获得系统基本特性的工具。Diffutils、File、Findutils、Gawk、Grep、Gzip、Make、Patch、Sed、Tar、Xz包提供另外的常用基本工具。</p>
<p>&emsp;&emsp;Binutils包第二次编译(Pass2)，这次编译生成原生汇编器、原生链接器等，它们被原生编译器 <code>cc-lfs</code> 所依赖。注意在 <code>configure</code> 配置选项上和 Pass1 的区别，此时我们不需要设置 <code>--target</code>，因为我们要获得的是原生工具链，只需要设置 <code>--host=$LFS_TGT</code>。</p>
<p>&emsp;&emsp; gcc 包第二次编译(Pass2)，这次编译生成 <code>cc-lfs</code>。注意<code>--with-build-sysroot=$LFS</code>选项；<code>--target=$LFS_TGT</code>选项确保此次构建使用 Pass1 中的库（如 glibc），因此生成的 libgcc 库也不再是退化的。<code>LDFLAGS_FOR_TARGET=-L$PWD/$LFS_TGT/libgcc</code>选项允许 libstdc++ 使用此次构建的（共享的） libgcc 而不是 Pass1 中静态的（退化的） <code>libgcc</code>。</p>
<h3 id="进入-chroot-环境原生编译其他临时工具"><a href="#进入-chroot-环境原生编译其他临时工具" class="headerlink" title="进入 chroot 环境原生编译其他临时工具"></a>进入 chroot 环境原生编译其他临时工具</h3><p>&emsp;&emsp;在进入 chroot 环境前要更改整个 LFS 文件目录的权限：设置为 root。然后，挂载虚拟内核文件系统(Virtual Kernel File System)，包括&#x2F;dev、&#x2F;proc、&#x2F;run、&#x2F;sys。内核文件系统不占用任何磁盘空间，它可以使得用户空间与内核空间通信以及用于内核自身的通信。在进入 chroot 环境前为什么要这么做呢？以 procps 包为例，它包含获取当前运行进程信息的工具，如果没有挂载 &#x2F;proc 这些工具就无法测试和使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R root:root $LFS/&#123;usr,lib,var,etc,bin,sbin,tools&#125;</span><br><span class="line">case $(uname -m) in</span><br><span class="line">x86_64) chown -R root:root $LFS/lib64 ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">mkdir -pv $LFS/&#123;dev,proc,sys,run&#125;</span><br><span class="line">mount -v --bind /dev $LFS/dev</span><br><span class="line">mount -v --bind /dev/pts $LFS/dev/pts</span><br><span class="line">mount -vt proc proc $LFS/proc</span><br><span class="line">mount -vt sysfs sysfs $LFS/sys</span><br><span class="line">mount -vt tmpfs tmpfs $LFS/run</span><br></pre></td></tr></table></figure>

<p>进入 <code>chroot</code> 环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot &quot;$LFS&quot; /usr/bin/env -i \</span><br><span class="line">HOME=/root \</span><br><span class="line">TERM=&quot;$TERM&quot; \</span><br><span class="line">PS1=&#x27;(lfs chroot) \u:\w\$ &#x27; \</span><br><span class="line">PATH=/usr/bin:/usr/sbin \</span><br><span class="line">/bin/bash --login</span><br></pre></td></tr></table></figure>

<p>进入 chroot 环境后，生成一些目录和文件，例如&#x2F;boot、&#x2F;home、&#x2F;mnt、&#x2F;opt和&#x2F;srv等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -pv /&#123;boot,home,mnt,opt,srv&#125;</span><br></pre></td></tr></table></figure>
<p>新建基本的配置文件（如<code>/etc/passwd</code>、<code>/etc/group</code>、 <code>/etc/mtab</code>和<code>/etc.host</code>等）和文件符号链接。</p>
<p>&emsp;&emsp;libstdc++ 第二次编译(Pass2)，此次编译将生成完全的 libstdc++ 库，从而可以编译使用 C++ 编写或者部分编写的软件。(<code>11.3版本中无此步骤，10.1版本中包括该步骤</code>。)</p>
<p>&emsp;&emsp;对 <code>gettext</code>,<code>bison</code>,<code>perl</code>,<code>python</code>,<code>texinfo</code>,<code>util-linux</code>包的编译。</p>
<h2 id="构建-LFS-的基本系统软件"><a href="#构建-LFS-的基本系统软件" class="headerlink" title="构建 LFS 的基本系统软件"></a>构建 LFS 的基本系统软件</h2><p>&emsp;&emsp;我们已经有了编译环境和足够的临时工具，因此可以开始构建LFS系统。<br>&emsp;&emsp;前面的一些临时工具也会被重新编译并被覆盖(override)，这些系统软件会被测试，然后安装，并且兼容 FHS 和 LSB 标准。每一个系统软件都值得去亲自编译、测试和安装：<em>The key to learning what makes a Linux system work is to know what each package is used for and why you (or the system) may need it.</em></p>
<p>&emsp;&emsp;Bash、Python 等包的编译和第一次编译有些不同，这次编译会设置一些依赖，这些依赖的包已经安装到系统上，而不是像第一次编译那样使用自己内部的包。</p>
<h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><h2 id="启动引导"><a href="#启动引导" class="headerlink" title="启动引导"></a>启动引导</h2><h3 id="etc-fstab文件"><a href="#etc-fstab文件" class="headerlink" title="/etc/fstab文件"></a><code>/etc/fstab</code>文件</h3><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><p>&emsp;&emsp;内核编译命令比想象的要简单一些，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make mrproper          # Clean the kernel tree</span><br><span class="line">$ make menuconfig        # Configure kernel options </span><br><span class="line">$ make                   # Compile kernel image and modules</span><br><span class="line">$ make modules_install   # install modules</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译内核需要一些软件工具，这些工具前面几节已经安装到指定的最后位置，但弄清楚需要依赖哪些软件包可以帮助我们在其他平台构造编译环境。</p>
<p>&emsp;&emsp;除了 make、gcc，还主要包括bash、coreutils、diffutils、e2fsprogs、findutils、grep、gzip、hostname、glibc、ncurses、perl、sed、sysvinit、tar和 util-linux。在 Ubuntu 平台这些软件包和工具列表由 build-essential 包维护。另外，Ubuntu 使用 Debian 包管理系统，因此它会使用一些额外的包，如 kernel-package、fakeroot、initramfs-tools和 module-init-tools。</p>
<h3 id="设置-GRUB-引导"><a href="#设置-GRUB-引导" class="headerlink" title="设置 GRUB 引导"></a>设置 <code>GRUB</code> 引导</h3><p>##过程记录<br><strong>对于多次编译的包,一定要重新解压源码包,然后进入新解压的包目录进入编译,不要在先前编译的基础上重新配置、编译和安装。</strong></p>
<p>M4编译错误?为什么在chroot环境下会由getopt中的变量名冲突?</p>
<p>为什么没有自动创建$LFS&#x2F;usr&#x2F;lib目录?</p>
<p>为什么出现””Assumed value of MB_LEN_MAX wrong”错误? Answer: 修改tools&#x2F;gcc&#x2F;x86_64-lfs-linux-gnu&#x2F;10.2.0&#x2F;include-fixed&#x2F;limits.h 中的MB_LEN_MAX</p>
<p>Patch包中PATH_MAX变量<br>无法进入chroot的问题,bash无法找到libncursesw.so.6? Answer: 将libncursesw.so.6复制到lib64。对于libopcodes.so、libbfd.so、libctf.so也是同样的解决方法。</p>
<p>编辑&#x2F;etc&#x2F;ld.so.conf</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>LFS Project</category>
      </categories>
  </entry>
  <entry>
    <title>LFS 1: 构建 BLFS 系统</title>
    <url>/2021/04/19/LFS-1-%E6%9E%84%E5%BB%BA-BLFS-%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;LFS 虽然”五脏俱全”，但还很难“飞得很高”，与很多现代的 linux 发行版系统相比,它还是一个基础系统。<a href="https://www.linuxfromscratch.org/blfs/">BLFS</a> 项目于是在 LFS 的基础上继续前行，它为构建稳定、安全和现代化的操作系统提供了详细的指导。</p>
<span id="more"></span>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h3 id="文件系统和磁盘管理"><a href="#文件系统和磁盘管理" class="headerlink" title="文件系统和磁盘管理"></a>文件系统和磁盘管理</h3><h4 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h4><p>FUSE 称为用户空间文件系统(Filesystem in Userspace)，它可以允许用户在用户空间定制实现自己的文件系统或者挂载其他网络文件系统。例如它可以用来支持挂载使用MTP模式的android 文件系统(需要libmtp库的包装器,如mtpfs或者gvfsd-fuse)。要注意区分 MTP 模式和 USB 存储模式。</p>
<h3 id="通用库"><a href="#通用库" class="headerlink" title="通用库"></a>通用库</h3><p>ICU <code>./configure</code>需要设置<code>--with-data-packaging=files</code>，否则中途编译会失败。</p>
<h3 id="通用工具-系统工具"><a href="#通用工具-系统工具" class="headerlink" title="通用工具&#x2F;系统工具"></a>通用工具&#x2F;系统工具</h3><p><code>telepathy</code>框架，<code>empathy</code>： 即时聊天软件</p>
<p><code>acpid</code> : 监控 acpi event。</p>
<p><code>Autofs</code>: AutoFs 服务程序与 <code>mount</code> 命令不同之处在于它是一种守护进程，只有检测到用户试图访问一个尚未挂载的文件系统时才自动的检测并挂载该文件系统。</p>
<p><code>Bubblewrap</code>： 轻量级沙盒应用。</p>
<p><code>lm_sensors</code>： 监控硬件温度,电压,扇出等。</p>
<p><code>Logrotate</code>： 自动轮换(并压缩)日志文件。</p>
<p><code>Midnight Commander</code>： 可视化文件管理器。</p>
<p><code>pm-utils</code>： 提供工具使得计算机休眠(hibernate或者suspend to RAM)。</p>
<p><code>UPower</code> : 为访问电源设备提高接口。</p>
<h3 id="X系统"><a href="#X系统" class="headerlink" title="X系统"></a>X系统</h3><p><code>xdrinfo</code> 包的安装需要注意,树莓派 pi3 官方预编译的图形库中没有 <code>libGL.so</code>，所以先跳过此包的安装。</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>LFS Project</category>
      </categories>
  </entry>
  <entry>
    <title>LFS 2: PiLFS项目</title>
    <url>/2021/12/30/LFS-2-PiLFS%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p><a href="https://intestinate.com/pilfs/">PiLFS</a> 是从 <a href="http://linuxfromscratch.org/lfs">Linux From Scratch</a>项目中针对 Raspberry Pi 平台衍生出来的，它在原有项目的基础的上针对 Pi 增加了一些小的调整和构建时的技巧。</p>
<span id="more"></span>

<h3 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h3><p>PiLFS 11.0与LFS-11.0版本相比，增加了一些特定的针对树梅派的 patch、脚本、内核和固件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc-9.1.0-rpi1-cpu-default.patch</span><br><span class="line">gcc-9.1.0-rpi2-cpu-default.patch</span><br><span class="line">gcc-9.1.0-rpi3-cpu-default.patch</span><br><span class="line">gcc-9.1.0-rpi4-cpu-default.patch</span><br><span class="line">expect5.45-aarch64-fix.patch</span><br><span class="line">ch5-build.sh</span><br><span class="line">ch7-build.sh</span><br><span class="line">rpi-5.10.y.tar.gz</span><br><span class="line">master.tar.gz</span><br><span class="line">v2021.04.29.-138a1.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>使用构建脚本ch5-build.sh [运行时间约 13小时21分钟]</p>
<p>然后运行构建脚本ch7-build.sh [运行时间约15小时]</p>
<p>在构建 Binutils 时对内存的消耗会显著增加,如果在 pi3 上运行,其系统内存会耗尽并导致整个构建过程终止退出。去掉 configure 参数 <code>--enable-gold</code> 后则可以解决该问题。<code>--enable-gold</code>参数用于构建和安装 <code>ld.gold</code> 链接器，该<code>ld.gold</code>与默认的<code>BFD ld</code>链接器相比会提高链接效率。</p>
<p>内核和固件可以使用 Raspberry Pi 官方预编译好的包也可以自己从源代码编译。</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>LFS Project</category>
      </categories>
  </entry>
  <entry>
    <title>LLVM 0: 构建步骤及目录结构</title>
    <url>/2023/02/16/LLVM-0-%E6%9E%84%E5%BB%BA%E6%AD%A5%E9%AA%A4%E5%8F%8A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <a href="https://llvm.org/">LLVM</a> 项目包括多个组件，并以核心组件 <strong>LLVM</strong> 的名字作为项目名。这些组件包括了处理 <strong>IR</strong> 和生成目标代码的工具、库和头文件。其中 <strong>clang</strong> 作为C&#x2F;C++&#x2F;Object-C的前端，其本质上是使用 LLVM 核心库的驱动程序，这得益于 LLVM 优秀的模块化特性。</p>
<blockquote>
<p>参考 《<a href="https://llvm.org/docs/GettingStarted.html">Getting Started with the LLVM System</a>》 From <a href="https://llvm.org/docs/">LLVM Document</a>.<br>参考 《Learn LLVM 12》 by Kai Nacke.</p>
</blockquote>
<span id="more"></span>

<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>a. 工具包:<br>&emsp;&emsp;编译 LLVM 需要的软件包包括 <code>cmake</code>, <code>GCC</code>, <code>python</code> 等, 如果在通用的 Linux 系统上，大部分软件包已经预先安装。编译工具链可以不使用 GCC，也可以使用 <code>clang</code> 等。</p>
<p>b. 克隆仓库：<br><code>$ git clone https://github.com/llvm/llvm-project.git</code></p>
<p>或者直接下载压缩包并解压后获得源代码。</p>
<h3 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h3><p><code>$ cd llvm-project</code></p>
<p>可先构建库及部分工具：<br><code>$ cd llvm</code></p>
<p>切换到目标分支（<strong>可选</strong>，以 <em>llvmorg-12.0.0</em> 为例）<br><code>$ git checkout  -b llvmorg-12.0.0</code></p>
<p>执行 cmake 并创建构建目录：<br><code>$ cmake -B build -DCMAKE_BUILD_TYPE=Release</code></p>
<p>如果要使用 <strong>clang</strong> 工具链，可执行下面的命令：<br><code>$ CC=clang CXX=clang++  cmake -B build -DCMAKE_BUILD_TYPE=Release</code></p>
<p>编译：<br><code>$ cd build &amp;&amp; make -j2</code></p>
<p><code>注意</code>：上述cmake命令默认使用<em>Makefile生成器</em>, 使用 <em>Ninja 生成器</em> 可增加命令选项 <code>-G Ninja</code>。</p>
<h3 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h3><ul>
<li><p><strong>CMAKE_INSTALL_PREFIX</strong> : 如果要将编译好的 llvm 安装到 &#x2F;opt&#x2F;llvm 目录， 则需要在cmake命令选项中指定 <code>-DCMAKE_INSTALL_PREFIX=/opt/llvm</code>，这样当执行 <code>make install</code> 后库、工具和头文件将分别安装到 &#x2F;opt&#x2F;llvm&#x2F;lib 、&#x2F;opt&#x2F;llvm&#x2F;bin 和 &#x2F;opt&#x2F;llvm&#x2F;include。</p>
</li>
<li><p><strong>CMAKE_BUILD_TYPE</strong>:</p>
<ul>
<li><code>DEBUG</code>: 使用调试符号构建；</li>
<li><code>RELEASE</code>: 以速度优化为主的构建；</li>
<li><code>RELWITHDEBINFO</code>: 使用调试符号的发布构建；</li>
<li><code>MINSIZEREL</code>: 以优化生成文件大小为主的构建；默认的构建类型是 DEBUG (<code>会占用相当大的磁盘空间</code>)。<br>要构建为发布版本，必须指定<code>-DCMAKE_BUILD_TYPE=RELEASE</code>。</li>
</ul>
</li>
<li><p><strong>CMAKE_C_FLAGS</strong>： 指定 C 编译器的编译选项，初始值为 <code>CFLAGS</code> 环境变量。</p>
</li>
<li><p><strong>CMAKE_FLAGS</strong>：指定 C++ 编译器的编译选项，初始值为 <code>CXXFLAGS</code> 环境变量。</p>
</li>
<li><p><strong>LLVM_ENABLE_PROJECTS</strong>: 指定额外构建的子项目列表（以分号分隔），例如 clang、clang-tools-extra、lldb、compiler-rt、lld、polly、cross-project-tests 或用户自定义项目。</p>
</li>
<li><p><strong>LLVM_ENABLE_RUNTIMES</strong>：指定需要构建的运行时库，例如 libcxx;libcxxabi。</p>
</li>
<li><p><strong>LLVM_TARGETS_TO_BUILD</strong>：指定目标机器，默认为 <code>LLVM_ALL_TARGETS</code>，也可以单独指定某种目标机器，例如 <code>AArch64</code>、<code>AMDGPU</code>、<code>ARM</code>、<code>AVR</code>、<code>BPF</code>、<code>Hexagon</code>、<code>Lanai</code>、<code>Mips</code>、<code>MSP430</code>、<code>NVPTX</code>、<code>PowerPC</code>、<code>RISCV</code>、<code>Sparc</code>、<code>SystemZ</code>、<code>WebAssembly</code>、<code>X86</code>、<code>XCore</code>等。</p>
</li>
<li><p>其他</p>
</li>
</ul>
<p>可以使用下面的帮助命令查询某个配置选项：<br><code>$ cmake --help-variable CMAKE_BUILD_TYPE</code></p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="llvm-核心库"><a href="#llvm-核心库" class="headerlink" title="llvm 核心库"></a>llvm 核心库</h3><ul>
<li><strong>llvm&#x2F;cmake</strong> : 主要分为 <em>modules</em> 和 <em>platforms</em>两个文件夹，当用户基于 LLVM 开发自己的项目时，可以引入这些 cmake 模块，达到复用和快速构建的目的。这些 cmake 模块也会随库一起安装和发布，位于<code>&lt;安装目录的PREFIX&gt;/lib/cmake/llvm</code> 目录。</li>
<li><strong>llvm&#x2F;example</strong>：示例项目</li>
<li><strong>llvm&#x2F;include</strong>: 公共头文件</li>
<li><strong>llvm&#x2F;lib</strong>：包含大部分源代码，每个子模块都会生成对应的库。这些子模块包括 <code>IR</code>、<code>AsmParser</code>、<code>Bitcode</code>、<code>Analysis</code>、<code>Transforms</code>、<code>Target</code>、<code>CodeGen</code>、<code>MC</code>、<code>ExecutionEngine</code>和<code>Support</code>。</li>
<li><strong>llvm&#x2F;bindings</strong>：对非C&#x2F;C++语言的绑定，包括 <code>go</code>, <code>python</code>和<code>ocaml</code>。</li>
<li><strong>llvm&#x2F;projects</strong>：该目录不是 LLVM 本身的一部分，但可以放置用户的二次开发项目，并可以直接使用 LLVM 现有的构建系统，达到快速开发部署的目的。</li>
<li><strong>llvm&#x2F;test</strong>：</li>
<li><strong>llvm&#x2F;tools</strong>：基于 lib 中的库开发的工具，主要的包括 <code>llvm-ar</code>、<code>llvm-as</code>、<code>llvm-link</code>、<code>lli</code>、<code>llc</code>、<code>llvm-dis</code>和<code>opt</code>等。</li>
<li><strong>llvm&#x2F;utils</strong>：</li>
</ul>
<h3 id="Polly"><a href="#Polly" class="headerlink" title="Polly"></a>Polly</h3><h3 id="MLIR"><a href="#MLIR" class="headerlink" title="MLIR"></a><a href="https://mlir.llvm.org/">MLIR</a></h3><p>&emsp;&emsp;MLIR 是一种新型的用于构建可复用、可扩展的编译器框架。</p>
<h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><p>&emsp;&emsp; C&#x2F;C++&#x2F;Object-C 前端。</p>
<h3 id="flang"><a href="#flang" class="headerlink" title="flang"></a>flang</h3><p>&emsp;&emsp; Fortran前端。</p>
<h3 id="lld"><a href="#lld" class="headerlink" title="lld"></a>lld</h3><h3 id="lldb"><a href="#lldb" class="headerlink" title="lldb"></a>lldb</h3><h3 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h3><ul>
<li><strong>compiler-rt</strong>：提供独立于编程语言的支持库，它包括泛型函数，例如：可在 32 位 (i386) 机上使用的 64 位除法、各种 sanitizer、模糊库和分析库。</li>
<li><strong>libunwind</strong>：提供了基于 DWARF 标准的堆栈展开帮助函数。这通常用于 C++ 等语言的异常处理。该库用 C 编写，函数没有绑定到特定的异常处理模型上。</li>
<li><strong>libcxxabi</strong>： 在 libunwind 上实现了 C++ 的异常处理，并为其提供了标准的 C++ 函数。</li>
<li><strong>libclc</strong>：OpenCL 的运行时库。</li>
<li><strong>libcxx</strong>: C++ 标准库实现。</li>
<li><strong>libc</strong>：C 库支持。</li>
<li><strong>OpenMP</strong>：对 OpenMP API 的支持。</li>
</ul>
<h2 id="clang-简单使用"><a href="#clang-简单使用" class="headerlink" title="clang 简单使用"></a>clang 简单使用</h2><p><strong>预处理</strong>：</p>
<p><code>cland -E main.c</code></p>
<p><strong>词法分析</strong>：</p>
<p><code>clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c</code></p>
<p>其中<code>-fmodules</code>，指启动<strong>模块</strong>语言功能；<code>-fsyntax-only</code> 运行预处理器；<code>-Xclang &lt;arg&gt;</code> 将参数传递给<code>clang</code>；<code>-dump-tokens</code> 转储 <strong>tokens</strong> 内部表示。</p>
<p><strong>语法分析和语义分析</strong>：</p>
<p><code>clang -fmodules -fsyntax-only -Xclang -ast-dump main.c</code></p>
<p><strong>代码生成和优化</strong>：</p>
<p><code>clang -emit-llvm -S main.c -o main.ll</code><br><code>llvm-as main.ll -o main.bc</code><br><code>llvm-dis main.bc -o main.ll</code></p>
]]></content>
      <categories>
        <category>编译器</category>
        <category>LLVM Project</category>
      </categories>
  </entry>
  <entry>
    <title>LLVM 2: Backend</title>
    <url>/2023/02/24/LLVM-2-Backend/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; 在 <a href="http://1.117.83.246/index.php/archives/235/">LLVM 项目介绍</a> 中我们说 LLVM 的后端代码生成器是由 一系列 Pass 组成的，本篇文章会进一步描述一些重要的 Pass：例如<code>指令选择</code>及其所使用的<strong>目标描述语言（.td文件）</strong>的细节。如果需要一个新的后端，在大多数情况下，我们都可以通过移植已经存在的后端来完成。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://llvm.org/docs/WritingAnLLVMBackend.html">Writing an LLVM Backend</a><br>参考 <a href="http://jonathan2251.github.io/lbd/">Creating an LLVM Backend for the Cpu0 Architecture</a>。<br>参考 <a href="https://llvm.org/docs/CodeGenerator.html#introduction">The LLVM Target-Independent Code Generator</a>。<br>参考 <a href="http://www.aosabook.org/en/llvm.html">The Architecture of Open Source Applications</a> by Chris Lattern.<br>参考 《Learn-LLVM-12》 by Kai Nacke.</p>
</blockquote>
<h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><p>后端的工作流程大致如下图所示：</p>
<p><img src="/2023/02/24/LLVM-2-Backend/flow.png"></p>
<p>后端的主要工作任务总结如下:</p>
<ul>
<li>指令选择</li>
<li>基于 SSA 的机器代码优化</li>
<li>寄存器分配</li>
<li>Prolog&#x2F;Epilog 代码插入</li>
<li>后期机器代码优化</li>
<li>代码 Emission</li>
</ul>
<p>所有这些步骤都是由 <code>MachineFucntionPass</code>类派生的子类实现的，它自己是 <code>FunctionPass</code>的子类。在整个过程中，LLVM 指令会进行一系列的转换，首先对于输入 IR 中的每个指令在代码层对应 <code>Instruction</code> 类的实例；在 <strong>指令选择Pass</strong> 完成后，它转换为 <code>MachineInstr</code>类的实例，它更接近于实际机器表示，但仍使用虚拟寄存器；后面的 Pass 会对其继续进行转换，直到最后生成 <code>MCInstr</code>类的实例，它是真实机器指令的表示。</p>
<p>我们以下面的 LLVM IR code 作为例子（sum.ll）：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i16</span> <span class="title">@sum</span>(<span class="type">i16</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i16</span> <span class="variable">%b</span>) &#123;</span><br><span class="line">    <span class="variable">%res</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i16</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i16</span> <span class="variable">%res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>llc</code> 编译，并输出中间 Pass 列表：</p>
<p><code>$ llc -mtripe=mips-linux-gnu -debug-pass=Structure &lt; sum.ll</code></p>
<p>后端的 Pass 大多数不是在 LLVM IR 上运行，而是在 MIR 上运行，它是依赖于目标指令的表示。但它仍可以包含虚拟寄存器，所以并不是纯粹的 目标CPU 指令。我们可以在每个 Pass 完成后停止，并打印 MIR 的文本表示，如下所示：</p>
<p><code>$ llc -mtripe=mips-linux-gnu -stop-after=finalize-isel &lt; sum.ll</code></p>
<p>它指示 <code>llc</code> 在 <strong>指令选择 Pass</strong> 后转储 MIR ，部分内容如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">name:</span> sum</span><br><span class="line">...</span><br><span class="line"><span class="symbol">body:</span>             |</span><br><span class="line">  bb.<span class="number">0</span> (<span class="variable">%ir-block.0</span>):</span><br><span class="line"><span class="symbol">    liveins:</span> $a<span class="number">0</span><span class="punctuation">,</span> $a<span class="number">1</span></span><br><span class="line">   </span><br><span class="line">    <span class="variable">%1</span>:gpr<span class="number">32</span> <span class="operator">=</span> COPY $a<span class="number">1</span></span><br><span class="line">    <span class="variable">%0</span>:gpr<span class="number">32</span> <span class="operator">=</span> COPY $a<span class="number">0</span></span><br><span class="line">    <span class="variable">%2</span>:gpr<span class="number">32</span> <span class="operator">=</span> ADDu <span class="variable">%0</span><span class="punctuation">,</span> <span class="variable">%1</span></span><br><span class="line">    $v<span class="number">0</span> <span class="operator">=</span> COPY <span class="variable">%2</span></span><br><span class="line">    RetRA implicit $v<span class="number">0</span></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MIR 中的细节可以参考文档 <a href="https://llvm.org/docs/MIRLangRef.html">MIR 语言参考</a>。</p>
<h2 id="指令选择"><a href="#指令选择" class="headerlink" title="指令选择"></a>指令选择</h2><p>&emsp;&emsp;指令选择可以使用<code>树重写（Tree Coverage）</code>方法或者 <code>DAG</code>方法来完成。其中，DAG 表示方法可以生成更好的代码，但匹配更加复杂。即使如此，LLVM 使用 <code>SelectionDAG</code> 作为基础的<code>指令选择器（Instruction Selector）</code>。该指令选择器的一部分是由 <code>.td</code>文件生成的，虽然 LLVM 正致力于在未来完全使用<code>.td</code>文件来生成指令选择器，但目前仍需要直接使用部分特定的 C++ 代码。<a href="https://llvm.org/docs/GlobalISel/index.html">GlobalISel</a> 致力于替换<code>SelectionDAG</code>和<code>FastISel</code>，提供更高性能、更加模块化的指令选择器。</p>
<p>&emsp;&emsp;<code>树重写</code>方法首先需要为当前目标 ISA 中的指令构建 <strong>模板树</strong>，其中树的叶子可以是寄存器、常量或者内存地址（可能会带有附加的语义约束信息）。接下来需要进行<strong>树模式匹配</strong>，例如如果 IR 以 <em>输入树</em> 的形式表示，我们将 <strong>输入树</strong> 中的子树与树模板匹配，一旦成功，就输出对应的指令并替换 <strong>输入树</strong> 中的对应节点。重复该匹配过程，直到<strong>输入树</strong>归约为单个节点。另外，作为核心的<strong>树模式匹配</strong>的具体实现是如何呢？一种方法是：可以将输入树转换为<strong>基于前缀的文本串</strong>，模板树转换为<strong>上下文无关文法的产生式</strong>，那么接下来只需要使用 LR 语法分析技术就可以完成模式匹配了。</p>
<p>&emsp;&emsp;<strong>SelectionDAG</strong>是一种代码表示的抽象方法，它不仅适合以自动化技术进行指令选择，而且适合其他子流程，例如基本块的底层优化（常量折叠、公共子表达式消除、死代码消除等）。<a href="https://llvm.org/doxygen/classllvm_1_1SelectionDAG.html">SelectionDAG</a> 由 <a href="https://llvm.org/doxygen/classllvm_1_1SDNode.html">SDNode</a> 类型的节点组成，该节点表示的操作称为 OpCode，除了操作外，该节点还存储操作数及其生成的值。节点的值和操作数形成<strong>数据依赖关系</strong>，另外使用“链边”表示<strong>控制流依赖关系</strong>，这使得保留具有副作用的指令的顺序称为可能，例如：<code>load</code>、<code>store</code>、<code>call</code>和<code>return</code>等。</p>
<p>使用<code>SelectionDAG</code>进行指令选择的步骤如下：</p>
<ol>
<li><strong>构建初始化 DAG</strong> ： 该阶段将输入的 LLVM IR code 转换为合法的 <strong>SelectionDAG</strong>。</li>
<li><strong>优化 SelectionDAG</strong>：</li>
<li><strong>检查 SelectionDAG 中类型的合法性</strong>：该阶段会转换&#x2F;消除一些节点，这些节点对应的类型在目标机器中不支持。</li>
<li><strong>优化 SelectionDAG</strong>：</li>
<li><strong>检查 SelectionDAG 中操作的合法性</strong>：该阶段会转换&#x2F;消除一些节点，这些节点对应的操作在目标机器中不支持。</li>
<li><strong>优化 SelectionDAG</strong>：</li>
<li><strong>指令选择</strong>：目标指令选择器会将 DAG 中的操作节点匹配到目标指令。该阶段最终会将<strong>与目标无关的输入DAG</strong>转换为另一个<strong>目标指令DAG</strong>。</li>
<li><strong>调度和重排</strong>：</li>
</ol>
<p>上面所有步骤完成后，<strong>SelectionDAG</strong> 会被销毁，然后运行剩下的其他 <strong>Pass</strong>。</p>
<p>我们可以使用 <code>llc</code> 的部分命令行选型来查看指令选择各个阶段的细节。另外，还可以在 <code>Graphviz</code> 软件的帮助下生成 <strong>SelectionDAG</strong> 的可视化：</p>
<ul>
<li><code>-view-dag-combine1-dags</code>：显示第1步中构建的 初始化DAG。</li>
<li><code>-view-legalize-dags</code>：显示第3步前的 DAG。</li>
<li><code>-view-dag-combine2-dags </code>：显示第3步后的 DAG。</li>
<li><code>-view-isel-dags</code> ：显示第7步指令选择前的 DAG。</li>
<li><code>-view-sched-dags</code>：显示第7步指令选择后的 DAG。</li>
</ul>
<p>上面的命令行选项可能只包含在 Debug 版本的 <code>llc</code>中。</p>
<p>在 <strong>指令选择</strong> 阶段，其输入是已经进行合法性转换后的 <strong>SelectionDAG</strong>，然后进行模式匹配，最后输出目标代码的 DAG。以下面的一个代码片段为例：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%t1</span> <span class="operator">=</span> <span class="keyword">fadd</span> <span class="type">float</span> <span class="variable">%W</span><span class="punctuation">,</span> <span class="variable">%X</span></span><br><span class="line"><span class="variable">%t2</span> <span class="operator">=</span> <span class="keyword">fmul</span> <span class="type">float</span> <span class="variable">%t1</span><span class="punctuation">,</span> <span class="variable">%Y</span></span><br><span class="line"><span class="variable">%t3</span> <span class="operator">=</span> <span class="keyword">fadd</span> <span class="type">float</span> <span class="variable">%t2</span><span class="punctuation">,</span> <span class="variable">%Z</span></span><br></pre></td></tr></table></figure>

<p>上面的 LLVM IR 代码对应的 <strong>SelectionDAG</strong> 的前缀表示形式：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">fadd</span>:f<span class="number">32</span> (<span class="keyword">fmul</span>:f<span class="number">32</span> (<span class="keyword">fadd</span>:f<span class="number">32</span> W<span class="punctuation">,</span> X)<span class="punctuation">,</span> Y)<span class="punctuation">,</span> Z)</span><br></pre></td></tr></table></figure>

<p>对于支持 <code>multiply-and-add</code> 的 PowerPC 机器来说，模式匹配后的 DAG 如下所示：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">(FMADDS (FADDS W<span class="punctuation">,</span> X)<span class="punctuation">,</span> Y<span class="punctuation">,</span> Z)</span><br></pre></td></tr></table></figure>

<p>其中 <code>FMADDS</code> 在 <code>.td</code> 文件中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def FMADDS : AForm_1&lt;59, 29,</span><br><span class="line">                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),</span><br><span class="line">                    &quot;fmadds $FRT, $FRA, $FRC, $FRB&quot;,</span><br><span class="line">                    [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),</span><br><span class="line">                                           F4RC:$FRB))]&gt;;</span><br></pre></td></tr></table></figure>

<p>其中，4-5行代表匹配该指令的模式，其中<code>fadd</code>和<code>fmul</code>在 <code>include/llvm/Target/TargetSelectionDAG.td</code>中定义，<code>F4RC</code>代表寄存器类。<code>llvm-tblgen</code>会根据<code>.td</code>文件生成模式匹配器。</p>
<p>关于 <code>tblgen</code> 更多的信息参看第8节 <a href="#8">TableGen 语言</a>。</p>
<p>特别注意的是，<strong>SelectionDAG</strong> 的节点和选择的指令之间没有一一对应的关系。一个 DAG 节点可能扩展为多个指令，而多个节点也可能合并成一条指令。</p>
<p>对于 IR 中的每个函数，<code>SelectionDAG</code> 类的一个实例由 <code>SelectionDAGBuilder</code>填充。但目标需要一些回调函数来进行降级调用、参数处理、返回跳转等，它为此，必须实现<code>targetlower</code>接口。<code>targetlower</code> 接口的实现提供指令选择过程所需的所有信息，例如：目标上支持哪些数据类型和哪些操作。</p>
<p>在 <strong>类型合法化</strong>阶段，目标上不支持的类型将被支持的类型替换，例如：如果目标机只支持 32 位范围的整数，那么较小的值将被<strong>符号扩展</strong>或者<strong>零扩展</strong>为32位，较大的值会被分隔。<code>vector</code>类型也会做类似的处理。</p>
<p>在 <strong>调度和重排</strong> 阶段，会将 DAG 进行序列化，也就是说指令需要按照顺序排列。即使在满足数据流和控制流依赖关系的情况下，仍然存在多种排列方案，我们需要选择最能充分利用硬件的顺序。开发者可以将调度模型添加到目标描述文件中（.td文件）。</p>
<h2 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h2><h2 id="TableGen-语言"><a href="#TableGen-语言" class="headerlink" title="TableGen 语言"></a>TableGen 语言</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>&emsp;&emsp; 后端 Pass 需要一种通用的方式获取目标机器的一些属性信息，例如**寄存器分配 Pass **需要知道目标的寄存器类型和数量、指令间约束和寄存器操作符。LLVM 使用一种专门的声明式语言来进行目标描述，这个描述文件将被 <code>tblgen</code>工具进行处理。以 x86 目标为例：</p>
<p><img src="/2023/02/24/LLVM-2-Backend/X86Target.png"></p>
<p>从上图可知，目标描述被 <code>tblgen</code>生成多个源片段，这些源片段可以被其他工具或代码使用。</p>
<p>简单示例（来自 <code>llvm/Target/Target.td</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Register&lt;string n, list&lt;string&gt; altNames = []&gt; &#123;</span><br><span class="line">    string Namespace = &quot;&quot;;</span><br><span class="line">    string AsmName = n;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def R0 : Register &#123;</span><br><span class="line">    let AsmName = &quot;R0&quot;;</span><br><span class="line">    string altName = &quot;$0&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TableGen 是静态类型的，它必须指定每个值的类型。另外，<code>TableGen</code>工具本身也是模块化的，你可以使用 <code>TableGen库</code>实现自己的<strong>TableGen生成器</strong>。</p>
<p>在 <code>.td</code> 文件中，类似于 C++，<code>class</code> <strong>描述</strong> 了数据的布局结构，<code>def</code><strong>创建</strong>了类的一个<code>实例</code>。<code>class</code>之间可以存在<code>继承（包括多种继承）</code>关系，子类会继承父类的所有数据成员，并且可以使用<code>let</code>关键字重写某个数据成员的值。类也可以声明带有模板形参。</p>
<p>一些支持的类型如下：</p>
<ul>
<li><code>bit</code>：一个位</li>
<li><code>bits&lt;n&gt;</code>：由 <strong>n</strong> 位组成的整数类型</li>
<li><code>int</code>：整数值</li>
<li><code>string</code>：字符串</li>
<li><code>list&lt;t&gt;</code>：类型为<strong>t</strong>的元素列表</li>
<li><code>dag</code>：DAG（在<code>指令选择</code>中使用）</li>
<li><code>class 类</code>：由<code>class</code>声明的类也可以用作类型。</li>
</ul>
<p>另外，<code>tblgen</code> 支持使用 <code>include</code>包含其他文件，也支持<code>#define</code>、<code>#if</code>和<code>#endif</code>等预处理指令。</p>
<h3 id="顶层描述"><a href="#顶层描述" class="headerlink" title="顶层描述"></a>顶层描述</h3><h3 id="寄存器描述"><a href="#寄存器描述" class="headerlink" title="寄存器描述"></a>寄存器描述</h3><p>&emsp;&emsp; CPU 的体系结构通常会定义一组寄存器，这些寄存器的特性可以有很大的不同。比如有些是<strong>通用寄存器</strong>、<strong>浮点寄存器</strong>和<strong>向量寄存器</strong>，有些可以是特殊寄存器，例如<strong>状态寄存器</strong>、<strong>控制寄存器</strong>等。</p>
<p>&emsp;&emsp;在具体后端实现中，可以首先定义一个<strong>超类</strong>，该类继承自<code>Register</code>类；然后为不同类型的寄存器定义子类。注意，所有的寄存器定义都应该放在对应后端的命令空间中（<code>let Namesapce = &quot;&lt;my-backend&gt;&quot;</code>）。然后，可以定义<strong>寄存器分组</strong>，它实例化自<code>RegisterClass</code>类（当然也可以先定义<code>RegisterClass</code>的子类，做一些定制化，再实例化<strong>寄存器分组</strong>）。最后也可以定义基于寄存器类的操作数，它可以由<code>RegisterOperand&lt;寄存器分组&gt;</code> 类实例化。</p>
<h3 id="指令描述"><a href="#指令描述" class="headerlink" title="指令描述"></a>指令描述</h3><p>&emsp;&emsp; 在<strong>指令描述</strong>中一般分为定义<strong>位编码</strong>的类和指令的具体定义类。首先定义一个基类，该基类继承自<code>Instruction</code>类。这个类最重要的字段是 <code>Inst</code>，它保存了指令的编码，其他字段大部分都是对<code>Instruction</code>类的数据成员进行赋值。</p>
<p>&emsp;&emsp;定义<strong>位编码</strong>的类可以有多种类型，它们都定义为上述基类的子类。例如对于 MIPS，它包含<code>R型</code>、<code>L型</code>和<code>J型</code>指令，这三种类型指令的编码是不同的。特别对于跳转指令，由于它是<code>基本块</code>的最后一条指令，需要设置<code>isTerminator=1</code>，另外由于控制流不能通过这条指令，需要设置 <code>isBarrier=1</code>，对于分支指令，也要设置<code>isBranch=1</code>。</p>
<h3 id="调用规则描述"><a href="#调用规则描述" class="headerlink" title="调用规则描述"></a>调用规则描述</h3><p>&emsp;&emsp;调用规则定义了如何将参数传递给函数以及如果由函数返回值。这些规则包含在 CPU 体系结构的 <strong>ABI</strong> 规范中。以 MIPS 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def CC_MipsN_VarArg : CallingConv&lt;[</span><br><span class="line">  ...</span><br><span class="line">  // All integers are promoted to 64-bit.</span><br><span class="line">  CCIfType&lt;[i8, i16, i32], CCPromoteToType&lt;i64&gt;&gt;,</span><br><span class="line">  CCIfType&lt;[f32], CCAssignToReg&lt;[A0, A1, A2, A3, T0, T1, T2, T3]&gt;&gt;,</span><br><span class="line">  CCIfType&lt;[i64, f64], CCAssignToReg&lt;[A0_64, A1_64, A2_64, A3_64,</span><br><span class="line">                                      T0_64, T1_64, T2_64, T3_64]&gt;&gt;,</span><br><span class="line"></span><br><span class="line">  // All stack parameter slots become 64-bit doublewords and are 8-byte aligned.</span><br><span class="line">  CCIfType&lt;[f32], CCAssignToStack&lt;4, 8&gt;&gt;,</span><br><span class="line">  CCIfType&lt;[i64, f64], CCAssignToStack&lt;8, 8&gt;&gt;</span><br><span class="line">]&gt;;</span><br><span class="line"></span><br><span class="line">def RetCC_MipsN : CallingConv&lt;[</span><br><span class="line">  ...</span><br><span class="line">  CCIfType&lt;[i64], CCAssignToReg&lt;[V0_64, V1_64]&gt;&gt;,</span><br><span class="line">  CCIfType&lt;[f32], CCAssignToReg&lt;[F0, F2]&gt;&gt;,</span><br><span class="line">  CCIfType&lt;[f64], CCAssignToReg&lt;[D0_64, D2_64]&gt;&gt;</span><br><span class="line">]&gt;;</span><br></pre></td></tr></table></figure>
<p>其中，在<code>CC_MipsN_VarArg</code>中<code>CCPromoteToType</code> 用于将将小的值提升到 64 位；<code>CCAssignToReg</code>定义了传递参数的寄存器；<code>CCAssignToStack</code>定义了附加参数在栈上分配时的对齐方式。另外，在 <code>RetCC_MipsN</code> 中定义了如何将结果传递给调用函数。</p>
<p>还可以使用 <code>CalleeSavedRegs</code> 类定义<strong>被调用函数</strong>负责保存的寄存器。</p>
<h3 id="调度模式描述"><a href="#调度模式描述" class="headerlink" title="调度模式描述"></a>调度模式描述</h3><p>&emsp;&emsp; 在<strong>调度模式描述</strong>中一般会包含和 CPU 相关的底层信息,例如功能单元和流水线级数等。它可以用于<strong>指令调度和重排</strong>，以获得相对最优的代码顺序。以 MIPS 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def MipsGenericModel : SchedMachineModel &#123;</span><br><span class="line">  int IssueWidth = 1;</span><br><span class="line">  int MicroOpBufferSize = 0;</span><br><span class="line"></span><br><span class="line">  // These figures assume an L1 hit.</span><br><span class="line">  int LoadLatency = 2;</span><br><span class="line">  int MispredictPenalty = 4;</span><br><span class="line"></span><br><span class="line">  let CompleteModel = 1;</span><br><span class="line">  let PostRAScheduler = 1;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>IssueWidth</code>定义了同时发射指令的个数，<code>LoadLatency</code>定义了<code>load</code>指令的延迟，<code>MispredictPenalty</code>定义了分支预测失败的代价。</p>
<h2 id="实现-DAG-指令选择类"><a href="#实现-DAG-指令选择类" class="headerlink" title="实现 DAG 指令选择类"></a>实现 DAG 指令选择类</h2><p>&emsp;&emsp; DAG 指令选择的大部分代码都可以使用<code>tblgen</code>工具生成，但目前仍需要使用手写代码创建类，并将所有内容放在一起。</p>
<h3 id="初始化目标机器"><a href="#初始化目标机器" class="headerlink" title="初始化目标机器"></a>初始化目标机器</h3><h3 id="添加-SelectionDAG-的实现"><a href="#添加-SelectionDAG-的实现" class="headerlink" title="添加 SelectionDAG 的实现"></a>添加 SelectionDAG 的实现</h3><h3 id="目标-Lowering"><a href="#目标-Lowering" class="headerlink" title="目标 Lowering"></a>目标 Lowering</h3>]]></content>
      <categories>
        <category>编译器</category>
        <category>LLVM Project</category>
      </categories>
  </entry>
  <entry>
    <title>LLVM 项目介绍</title>
    <url>/2022/11/06/LLVM-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp; <a href="https://llvm.org/">LLVM</a> 是一套开源的编译器基础设施项目, 它包含了一系列模块化的编译器组件和工具链。</p>
<blockquote>
<p>参考 《<a href="http://www.aosabook.org/en/llvm.html">The Architecture of Open Source Applications</a>》 by Chris Lattern.<br>参考 《<a href="https://llvm.org/pubs/2008-10-04-ACAT-LLVM-Intro.html">Introduction to the LLVM Compiler System</a>》 by Chars Lattern.</p>
</blockquote>
<span id="more"></span>

<h3 id="为什么需要-LLVM-？"><a href="#为什么需要-LLVM-？" class="headerlink" title="为什么需要 LLVM ？"></a>为什么需要 LLVM ？</h3><p>GCC 耦合度太高，其组件很难复用；其他编译器实现之间也同样难以共享代码。</p>
<p>对于 LLVM：<br>构建高度模块化的编译组件集合 :</p>
<ul>
<li>减少构造一个专用编译器的成本（包括时间成本）</li>
<li>组件可以复用和共享</li>
<li>允许针对不同的任务选择不同的组件</li>
</ul>
<p>构建C&#x2F;C++等主流语言的编译器：</p>
<ul>
<li>更好的编译性能</li>
<li>生成更加优化的代码</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>经典三段式编译器设计:</p>
<p><img src="/2022/11/06/LLVM-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/SimpleCompiler.png"></p>
<ul>
<li>前端：前端主要负责语言的词法、语法和语义分析，并生成 AST 或其他 IR。</li>
<li>优化器：将前端输出的 IR 作为输入，对 IR 进行一系列转换来优化代码，包括局部优化和全局优化等。</li>
<li>后端：生成目标代码，它主要包括指令选择、寄存器分配和指派、指令调度等过程。</li>
</ul>
<p>&emsp;&emsp;这种架构具有灵活性及可扩展性，当开发一个新语言时，几乎只需要构造一个前端，中间优化器及后端代码生成器则可以复用，如下图所实示：</p>
<p><img src="/2022/11/06/LLVM-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/RetargetableCompiler.png"></p>
<p>&emsp;&emsp;另外，这种架构有利于开源协作和维护，可以更大程度发挥开源社区的作用。</p>
<p>&emsp;&emsp; Java 的成功一定程度上得益于该模型，Java的字节码 IR 与具体目标机器解耦，使得 Java 兼容各个平台。解释和运行字节码的 Java 虚拟机则可以作为后端支持各种目标机器和平台。</p>
<p>&emsp;&emsp; GCC 的架构也类似于该经典模型，它支持多种语言前端和支持多种后端目标机器。</p>
<p>&emsp;&emsp; 但不管 Java 还是 GCC 都被设计成<em>单一应用程序</em>(monolithic applications)，它们的代码很难被其他应用程序复用。另外，GCC 的代码受分层设计及缺乏抽象的困扰，不同组件间耦合性较强，很难将各个组件单独作为<strong>库</strong>来使用。</p>
<p><strong>LLVM 三段式设计的实现</strong>:</p>
<p><img src="/2022/11/06/LLVM-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/LLVMCompiler1.png"></p>
<p>&emsp;&emsp; LLVM IR 可以表示为文本格式（<strong>因此提高了透明性</strong>），而且它是与中间优化器交互的<strong>唯一</strong>接口。可以说，LLVM IR 是 <strong>完备的(Complete)</strong> 和 <strong>自包含的(self-contained)</strong> 。前端生成的LLVM IR 可以通过管道(Pipe)发送给优化器和后续代码生成器。相比而言，GCC 的 <strong>GIMPLE</strong> 中间表示形式却不是自包含的，它仍然引用源码树的某些信息。</p>
<p>&emsp;&emsp;另外重要的是，<code>LLVM 是一系列库的集合</code>，而不是像 GCC 那样的单一命令行编译器，也不是像不透明的 JAVA 或 .NET 虚拟机。LLVM 是基础设施框架，它的一系列非常有用的编译技术可以灵活地被应用于特定的问题。这是它最强大的特性，同时也是最少被理解的设计点。</p>
<p>&emsp;&emsp; LLVM 的优化器被组织成一系列 <strong>优化 Pass</strong>的<strong>流水线</strong>，这个流水线的任意一个Pass都有机会对 IR 进行更新。不同的<strong>优化级别</strong>会选择不同种类和数量的优化 Pass。这些 Pass 可以被打包成单个或多个静态库(在Unix环境下的<code>.a</code>文件)，库之间尽可能保持松耦合，如果有依赖关系，这些关系信息也会被显式地声明。</p>
<p>&emsp;&emsp;这种设计使得特定问题的解决（例如开发图像处理语言的 JIT 编译器）可以灵活的复用上述编译技术。实现者可以根据需求对 Pass 的种类进行取舍或者编写自己的 Pass，因为 LLVM 不是魔法，它不能解决所有的优化问题。</p>
<p>&emsp;&emsp; LLVM 的库具有丰富的能力，但<strong>它们本身</strong>实际上不能做任何事情。这取决于库的用户在开发应用（如 <strong>Clang C 编译器</strong>）时如何将它们更好地加以利用。这种精心设计的层次性和可分解性是使得 LLVM 优化器在不同的环境中应用到如此多不同的应用的原因。</p>
<h3 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h3><p>&emsp;&emsp; LLVM IR 有以下设计目标：</p>
<ul>
<li>轻量级的 runtime 优化</li>
<li>跨函数或过程间优化</li>
<li>全局优化</li>
<li>激进的重构转换</li>
</ul>
<p>以下面的 C 代码为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">add1</span><span class="params">(<span class="type">unsigned</span> a, <span class="type">unsigned</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perhaps not the most efficient way to add two numbers.</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">add2</span><span class="params">(<span class="type">unsigned</span> a, <span class="type">unsigned</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">return</span> add2(a<span class="number">-1</span>, b+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换为 LLVM IR：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@add1</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span>) &#123;</span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">  <span class="variable">%tmp1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="variable">%b</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%tmp1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@add2</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span>) &#123;</span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">  <span class="variable">%tmp1</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">eq</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%tmp1</span><span class="punctuation">,</span> <span class="type">label</span> <span class="variable">%done</span><span class="punctuation">,</span> <span class="type">label</span> <span class="variable">%recurse</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">recurse:</span></span><br><span class="line">  <span class="variable">%tmp2</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">%tmp3</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%b</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">%tmp4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@add2</span>(<span class="type">i32</span> <span class="variable">%tmp2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%tmp3</span>)</span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%tmp4</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">done:</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp; LLVM IR 是一个底层的 RISC-like 指令集，每个指令为三地址格式。LLVM IR 支持标签，所以它看起来像汇编语言。<br>&emsp;&emsp;另外，它也是 SSA IR 的一种，即它使用无限多的虚拟寄存器，其主要特征是每个变量只赋值一次。SSA 通过简化程序中变量的特性，可以同时达到两种目的：第一，可以简化很多编译优化方法的过程；第二，对很多编译优化方法来说，可以获得更好的优化结果。</p>
<p>更多详细信息参考<a href="http://127.0.0.1/index.php/archives/261/">LLVM 1: IR 汇编语言参考</a>。</p>
<h3 id="LLVM-IR-优化"><a href="#LLVM-IR-优化" class="headerlink" title="LLVM IR 优化"></a>LLVM IR 优化</h3><p>&emsp;&emsp; 大多数优化遵循一个三段式结构：</p>
<ul>
<li>寻找可以转换的模式(Pattern)</li>
<li>对于匹配的实例验证转换是安全和正确的</li>
<li>执行转换，更新代码</li>
</ul>
<p>示例：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%example1</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="variable">%a</span></span><br><span class="line">⋮    ⋮    ⋮</span><br><span class="line"><span class="variable">%example2</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i32</span> <span class="variable">%b</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">⋮    ⋮    ⋮</span><br><span class="line"><span class="variable">%tmp</span> <span class="operator">=</span> <span class="keyword">mul</span> <span class="type">i32</span> <span class="variable">%c</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line"><span class="variable">%example3</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i32</span> <span class="variable">%tmp</span><span class="punctuation">,</span> <span class="variable">%c</span></span><br></pre></td></tr></table></figure>
<p>针对上诉 IR 的优化函数可以如下示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// X - 0 -&gt; X</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">match</span>(Op1, <span class="built_in">m_Zero</span>()))</span><br><span class="line">  <span class="keyword">return</span> Op0;</span><br><span class="line"></span><br><span class="line"><span class="comment">// X - X -&gt; 0</span></span><br><span class="line"><span class="keyword">if</span> (Op0 == Op1)</span><br><span class="line">  <span class="keyword">return</span> Constant::<span class="built_in">getNullValue</span>(Op0-&gt;<span class="built_in">getType</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// (X*2) - X -&gt; X</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">match</span>(Op0, <span class="built_in">m_Mul</span>(<span class="built_in">m_Specific</span>(Op1), <span class="built_in">m_ConstantInt</span>&lt;<span class="number">2</span>&gt;())))</span><br><span class="line">  <span class="keyword">return</span> Op1;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Nothing matched, return null to indicate no transformation.</span></span><br></pre></td></tr></table></figure>


<h3 id="LLVM-代码生成器"><a href="#LLVM-代码生成器" class="headerlink" title="LLVM 代码生成器"></a>LLVM 代码生成器</h3><p>&emsp;&emsp; 和优化器类似，LLVM 的代码生成器也被组织成 Pass 的集合。虽然可以为每种 target都编写专用的代码生成器，但这些生成器实际上都在解决相同的问题。解决这些问题的算法是可以共享的。</p>
<p>&emsp;&emsp; 代码生成器的 Pass 包括几类：指令选择、寄存器分配、调度、代码布局优化和生成汇编语言等，许多内置的 Pass 被设置为默认执行。代码生成器的作者可以在这些 Pass中进行选择，可以覆盖默认的 Pass 或者完成编写自己特定的 Pass。</p>
<p><strong>LLVM <code>.td</code> 文件</strong></p>
<p>其他详细内容参看 <a href="http://1.117.83.246/index.php/archives/262/">LLVM 2: Backend</a>。</p>
]]></content>
      <categories>
        <category>编译器</category>
        <category>LLVM Project</category>
      </categories>
  </entry>
  <entry>
    <title>Landscape 源码分析</title>
    <url>/2024/12/22/Landscape-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://ubuntu.com/landscape">Landscape</a> 是一个集群监控管理软件，它可以作为 web 服务来使用或者直接使用 API。<code>Landscape Server</code> 可以通过 Canonical 作为托管解决方案或者 Software-as-a-Server 模型，也可以自行托管。<code>Landscape Client</code> 安装在 Ubuntu 上，并向 Server 注册。<br>Landscape 自动化了整个 Ubuntu 系统的安全补丁、审计、访问管理和合规性任务。</p>
<p>Landscape 源代码使用了 <a href="https://twisted.org/">Twisted</a> 事件驱动网络引擎。</p>
<span id="more"></span>

<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>在 landscape 包的<code>init.py</code>中我们看到定义了一些变量，这些变量几乎都和版本号有关，这些变量类似于 C 语言中的全局宏定义。</p>
<h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h3><p>Landscape-client 可以<code>root</code>用户运行，进而可以使用一些高级管理特性，如果不需要使用这种特性时，可以使用<code>landscape</code>用户运行。通过修改<code>/etc/default/landscape-client</code>和<code>/etc/landscape/client.conf</code>文件可以办到（具体细节见项目代码<code>README</code>）。</p>
<h3 id="watchdog-模块"><a href="#watchdog-模块" class="headerlink" title="watchdog 模块"></a>watchdog 模块</h3><p>代码位置：<code>landscape/client/watchdog.py</code></p>
<p><strong>watchdog</strong> 是最高层的代码，它清理运行环境，载入配置文件，然后启动 <strong>ractor</strong> 循环。</p>
<p>a. <code>clean_environment()</code>：该函数清除一些危险和敏感的变量。<br>b. 载入配置文件 : 和配置文件相关的工作被抽象为一系列具有继承关系的类，有些类在不同的模块中被重用。</p>
<pre class="mermaid">classDiagram
    landscape_lib_BaseConfiguration <-- landscape_client_deployment_BaseConfiguration
    landscape_client_deployment_BaseConfiguration <-- landscape_client_deployment_Configuration
    landscape_client_deployment_Configuration <-- landscape_client_watchdog_WatchDogConfiguration</pre>

<p>c. 执行用户限制（只允许<code>landscape</code>或者<code>root</code>用户执行）；初始化 <code>logging</code>。<br>d. 实例化<code>WatchDogService</code>服务， 并成为application的子服务，启动<code>ractor</code>.</p>
<h4 id="WatchDogService"><a href="#WatchDogService" class="headerlink" title="WatchDogService"></a>WatchDogService</h4><p><code>WatchDogService</code>继承自<code>twisted.service</code>，实例化时传递<code>WatchDogConfiguration</code>配置参数到私有实例变量<code>_config</code>。</p>
<p>a. <code>resource</code>包来自于标准库，用来测试和控制系统资源的分配。<code>soft limit</code>与<code>hard limit</code>的区别，只有<code>root</code>进程可以提升<code>hard limit</code>（参考Linux&#x2F;Unix系统编程手册）。 资源类型包括 CPU 运行时间、可以生成文件的最大空间、进程堆&#x2F;栈的大小、打开文件描述符的数量（<code>RLIMIT_NOFILE</code>）等等。<br>b. <code>WatchDogService</code>的<code>startService</code>方法首先生成<code>BootStrapList</code>中的文件或者目录，然后设置资源限制，最后生成已经<code>callback</code>激发的<code>Defered</code>对象，<br>该对象增加的回调链:</p>
<p>watchdog.check_running() | past<br>start_if_not_running() | die()</p>
<p><code>watchdog</code>是在<code>WatchDogService</code>初始化时<code>WatchDog</code>类的实例对象。</p>
<p><code>start_if_not_running</code>方法会调用<code>_daemonize()</code>方法，该方法根据实际参数判断自己是否要成为一个<code>daemon</code>进程，如果是的话，就调用<code>daemonize function</code>，该函数会调用 os 的底层 API，调用两次<code>fork()</code>，并让父进程自杀，其他具体细节可参考 Linux&#x2F;Unix系统编程手册。 最后调用<code>watchdog</code>的<code>start</code>方法，它根据条件启动其他<code>daemons</code>并进行监控。</p>
<p>e. <code>stopService</code>方法<br>它主要工作是调用<code>watchdog</code>的<code>request_exit</code>方法，该方法会做比较精细复杂的工作来小心地让自己和其他<code>daemons</code>终止，比如避免重启。</p>
<p>f. 不管是<code>startService</code>还是<code>stopService</code>方法返回的都是<code>Defered</code>对象或者<code>DeferedList</code>对象，这些对象会被<code>Twisted</code>内部使用。</p>
<h4 id="WatchDog-类"><a href="#WatchDog-类" class="headerlink" title="WatchDog 类"></a>WatchDog 类</h4><p><code>WatchDog</code>类负责启动其他所有的<code>daemons</code>(包括<code>broker</code>，<code>Monitor</code>，<code>Manager</code>等)并确保它们运行。这些<code>daemons</code>运行在不同的<code>ractor</code>循环中，使用<code>AMP</code>协议通信。 <code>landscape_reactor</code>是<code>EventHandlingReactor</code>类的实例对象。</p>
<p>a. <code>EventHandlingReactor</code>类封装了<code>twisted.internet.reactor</code>，继承自<code>EventHandlingReactorMixin</code>类，增加事件处理特性。 其中<code>callInThread</code>来源于<code>Twisted</code>对于多线程的支持。<code>Twisted</code>更多应用于 I&#x2F;O 密集型应用，即任务的计算任务不会持续很长时间，但是如果有一个<br>任务很耗时的话，<code>Twisted</code>的<code>ractor</code>循环此时完全被该任务占用，其他任务会面临饥饿的问题。因此将该任务放到辅助线程中去执行，<code>reactor</code>主循环可以得到解放。<code>callFromThread</code>中的function可以立即在<code>reactor</code>线程中执行，但不保证线程安全，即<code>reactor</code>立即被切换？如果它正在执行任务如何？。如果该 function一直在运行，<code>reactor</code>被阻塞，其他任务会面临饥饿问题。参看链接2和3。</p>
<p>b. <code>EventHandingReactorMixin</code>类负责激活在被标识事件上绑定的<code>handlers</code>。重要的一点是这些事件的处理是同步的还是异步的？ <code>call_on</code>方法注册事件<code>handler</code>，一个事件类型可以绑定多个<code>handler</code>，并根据<code>handler</code>的优先级排序。 <code>fair</code>方法根据优先级顺序激发一个事件类型的所有<code>handler</code>，并返回所有<code>handler</code>的执行结果。 这些执行结果或许是<code>Defered</code>，即它的结果还不能立即得到。 <code>cancel_call</code>方法删除事件的某个<code>handler</code>绑定。</p>
<p>c. <code>EventID</code>类，对于每个<code>handler</code>只对应一种事件类型，因此（event_type， (handler， priority)）可以唯一标识一个<code>handler</code>。</p>
<p>d. <code>WatchDog</code>注册了<code>SIGUSR1</code>信号的<code>handler</code>，该<code>handler</code>会通知所有<code>daemons</code>调用<code>rotate_logs()</code>。</p>
<p>e. <code>check_running</code>方法检测哪些<code>daemons</code>正在运行，结果放在一个<code>List</code>中，但结果本身是一个<code>Defered</code>对象。<code>gather_results</code>将所有<code>Defereds</code>放到<code>DeferedList</code>对象中管理。<code>DeferdList</code>会等待所有其管理的<code>Defereds</code>回调链完成后再运行自己的回调链，这样正好实现异步形式的<code>check_running</code>方法。</p>
<p>f. <code>start</code>方法启动所有其他的<code>daemons</code>，并调用<code>start_minitoring</code>监控它们的进程状态。<code>start_monitoring</code>方法会启动一个回调<code>_check</code>方法，<code>_check</code>方法在完成一次<code>check</code>后增加自己到<code>reactor</code>回调链中，延时 5 秒。当检测到某个<code>daemon</code>在 5 次探测中均没有回复，<code>WatchDog</code>判断该<code>daemon</code>已经死掉，所以接下来就重启它，并清零探测失败计数器。</p>
<h4 id="Daemon类和其子类"><a href="#Daemon类和其子类" class="headerlink" title="Daemon类和其子类"></a>Daemon类和其子类</h4><h4 id="WatchedProcessProtocol类"><a href="#WatchedProcessProtocol类" class="headerlink" title="WatchedProcessProtocol类"></a>WatchedProcessProtocol类</h4><h3 id="amp-模块"><a href="#amp-模块" class="headerlink" title="amp 模块"></a>amp 模块</h3><h3 id="Service-相关模块和类"><a href="#Service-相关模块和类" class="headerlink" title="Service 相关模块和类"></a>Service 相关模块和类</h3><h3 id="Monitor模块"><a href="#Monitor模块" class="headerlink" title="Monitor模块"></a>Monitor模块</h3><h3 id="Manager模块"><a href="#Manager模块" class="headerlink" title="Manager模块"></a>Manager模块</h3><h3 id="Bootstrap相关的类"><a href="#Bootstrap相关的类" class="headerlink" title="Bootstrap相关的类"></a>Bootstrap相关的类</h3><h3 id="Configuration相关的类"><a href="#Configuration相关的类" class="headerlink" title="Configuration相关的类"></a>Configuration相关的类</h3><p><code>BootstrapList</code>类是其他类列表的分发器，这个列表中的元素甚至可以是它自己的实例对象，遵循闭包设计。<br><code>BootstrapPath</code>是<code>BootsrapFile</code>和<code>BootstrapDirectory</code>的父类，它通过模块生成文件路径（或文件或目录），并设置其用户属性<code>(chown)</code>和访问权限<code>(chmod)</code>。<br><code>BootstrapFile</code>对应文件，<code>BootstrapDirectory</code>对应目录。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>遵循分离设计，重要的是<code>watchdog</code>，<code>monitor</code>，<code>broker</code>，<code>manager</code>都有自己的<code>logger</code>，因此它们的日志可以分开处理，但仍然使用相同的<code>logging APIs</code>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Lex结构及简明参考手册</title>
    <url>/2022/04/14/Lex%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%80%E6%98%8E%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp; Lex为词法分析器生成器。在许多情况下，相比自己动手写专用的生成器代码，使用lex有很多优势：获得更健壮、更简单、更清晰、更易维护的代码。这也是<code>避免重复造轮子</code>原则的应用。<code>flex</code>是lex的变种。<br>&emsp;&emsp; 词法分析器也可以用来完成源程序的宏预处理（如使用 <code>gcc -E</code>）。词法分析器围绕 <code>词法单元</code>、<code>模式</code>、<code>词素</code>等概念。</p>
<span id="more"></span>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>&emsp;&emsp; lex的核心模型是围绕正则表达式展开的，从理论上说，生成器首先需要将正则表达式转换为<em>不确定有限自动机</em>，然后再转换为<em>确定有限自动机</em>。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>微型语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel  LKD3 阅读笔记</title>
    <url>/2021/04/07/Linux-Kernel-LKD3-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>《Linux Kernel Development.3rd.Edition》重读笔记。</p>
<blockquote>
<p>The most important step on the road to Linux development is the realization that the kernel is not something for fear.<br>Only through actually reading and experimenting with the code can you ever understand it. The source is freely available, use it!</p>
</blockquote>
<span id="more"></span>

<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程 &#x3D; 程序 + 环境</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p><strong>slab 分配器</strong>：通过预先分配和重复使用 <code>task_struct</code>，可以避免动态分配和释放所带来的资源消耗，可以加快进程创建的效率。<br>注意<code>写时拷贝</code>技术的作用是什么？（内核创建子进程时，并不复制整个进程地址空间，而是父子进程共享同一个拷贝。只有当子进程需要写入页的时候，才真正地进行拷贝）。fork 后父子进程的区别仅仅在于 PID、PPID、某些资源和统计量。<br>注意分析 fork 系统调用的流程：<code>fork/clone -&gt; do_fork -&gt; _do_fork -&gt; copy_precess</code>。</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>Linux CFS调度策略的特点：</p>
<ul>
<li>Nice值并不直接对应于进程的运行时间片（timeslices）。</li>
<li>Old approaches assign absolute timeslices yields a constant switching rate but variable fairness. <em>The approach taken by CFS  is a radical (for process schedulers) rethinking of timeslice allotment: Do away with timeslices completely and assign each process a proportion of the processor. CFS thus yields constant fairness but a variable switching rate.</em></li>
</ul>
<p>CFS不再依赖传统Unix系统的时间片机制，它实现了一种变化的、动态的公平策略而不是静态的不变的公平策略。调度器根据进程的nice值保证其占用处理器资源的比例（但实际比例因系统负载而定）而不是具体的timeslices，nice值作为分配占用CPU资源比例的权重值（weight），但不具有绝对意义，即对同一个进程不同的nice值可能分配相同的比例值。<strong>具体的比例分配要根据系统中所有进程的nice值的相对关系</strong>。<br><em>The nice value, instead of yielding additive increases to timeslices, yield geometric differences.</em><br>CFS计算实际timeslices的方法：CFS定义了目标延迟（targeted latency）的概念来接近完美的多任务系统，更小的target可以获得更好的交互性以及更接近完美的多任务系统，但意味着更昂贵的切换开销和降低系统吞吐率。CFS设置了timeslices的下限（minimum granularity）。<br>CFS is called a <em>fair scheduler</em> because it gives each process a fair share－a proportion－of the processor’s time. CFS不能实现绝对完美的公平，它是一种尽量接近完美的公平（CFS is perfectly fair!）。<br>CFS算法的具体实现要围绕vruntime变量，在一个理想的完美的多任务系统中，所有进程的vruntime值应该是相同的。那么可能要问不同优先级的进程怎么会有相同的运行时间呢？要明白的是vruntime的值是经过处理的（normalized or weighted），它并不代表实际的运行时间。CFS算法的核心就是每次选择vruntime值最小的进程来运行，它利用红黑树结构（rbtree）来管理所有可运行的进程列表，树中节点的key值就是进程的vruntime值，而最小key值的进程位于树中最左边的叶子上。vruntime会被不间断地更新，update_curr函数被调用来完成这项任务，而update_curr会被系统timer调用或者当某个进程任何时候状态发生变化时。<br>schedule()函数是进程调度的主入口。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>The existence of these interfaces and the fact that applications are not free to directly do whatever they want, is key to providing a stable system.<br>In Linux, system calls are the only means user-space has of interfacing with the kernel; they are the only legal entry point into the kernel other than exceptions and traps.<br>A meme related to interfaces in Unix is “Provide mechanism, not policy.”. In other words, Unix system calls exist to provide a special function in an abstract sense.<br>Linux实现系统调用的方式是利用软中断（software interrupt），在机器代码层面会利用一些特别异常指令，如MIPS的trap、syscall等指令，x86和arm也有类似的指令。在一些x86架构上，软中断的指令为<code>int $0x80</code>，后来提供了专门的<code>sysenter</code>指令。<em>Regardless of how the system call handler is invoked, however, the important notion is that somehow user-space causes an exception or trap to enter the kernel.</em> 然后进入内核空间执行异常Handler，这里的Handler也可以专门命名为syscall Handler。<br>接下来，自然要做的就是将系统调用号及调用参数传递给内核syscall Handler。x86上的做法是将调用号放入特殊的寄存器eax，其他架构类似。参数的传递可以通过寄存器，参数过多时可以使用某个寄存器指向用户空间，在那里可以获得参数。</p>
<p>Q1:  Are you needlessly limiting the function?<br><strong>Design the system call to be as general as possible.</strong><br><strong>The purpose of the system call will remain constant but its use may change.</strong></p>
<p>Q2: Is the system call portable?</p>
<p><strong><code>Provide mechanism, not policy.</code></strong></p>
<p>内核一定会对系统调用的参数进入检查，<em>Note kernel code must never blindly follow a pointer into user-space!</em> 其中之一是对指针的合法性检查，指针所指向的区域必须是用户空间，且是该进程的地址空间，该空间具有相应的操作权限；另外是对合法权限的检查，例如reboot系统调用会检查当前用户是否为root用户。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断控制器可以实现多路复用功能，因为连接到CPU芯片的中断信号线往往只有一条，而外围设备却有很多。<em>The important notion is that a specific interrupt is associated with a specific device, and the kernel knows this. The hardware then issues interrupts to get the kernel’s attention.</em><br>异常（Exception）往往又称为同步中断（synchronous interrupts），比如缺页（Page Fault）及上一节的软中断，它的处理机制和来自硬件的异步中断类似。<br>设备的中断处理程序（interrupt service routine，ISR）是设备驱动的一部分，设备驱动是内核中管理设备的代码。Interrupt Handler运行在一个特殊的context中，叫做interrupt context，在那里，代码不能被阻塞，代码会尽量保持小巧，并保证尽量短时间内完成任务。但当任务很重时，handler必须作出选择，Linux实现了Top Halves和Bottom Halves机制来提供这种选择。仔细思考这种机制，我们会发现它也是某种异步编程机制，繁重的任务Bottom Halves会延迟，并在合适的时候执行。<br>每一个中断类型都有一个中断号，且绑定零个、一个或者多个中断Handler，多个Handler可以共享某个中断线。request_irq负责注册Handler，特别注意的是它可能会睡眠或阻塞。<br>中断控制，便于进程间同步。local_irq_disable 和 local_irq_enable；local_irq_save 和 local_irq_store。中断屏蔽。<br><strong>特别注意中断系统与进程调度间的密切关系。</strong></p>
<h2 id="内核同步机制"><a href="#内核同步机制" class="headerlink" title="内核同步机制"></a>内核同步机制</h2><blockquote>
<p>不管是禁止中断还是禁止内核抢占，都没有提供任何保护机制来防止来自其他处理器的并发访问。Linux 支持 SMP，因此，内核代码一般都需要获取某种锁，防止来自其他处理器对共享数据的并发访问，获取这些锁的同时也伴随着禁止本地中断。</p>
</blockquote>
<h3 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h3><h2 id="定时器和时间管理"><a href="#定时器和时间管理" class="headerlink" title="定时器和时间管理"></a>定时器和时间管理</h2><p>内核为什么需要timer interrupt? 一个Tickless的操作系统可以起到降低功耗的作用!<br>Jiffies记录的是自启动后tick的个数，每一秒有HZ个jiffies，注意jiffies要标记为volatile变量。</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>Linux Kernel</category>
      </categories>
  </entry>
  <entry>
    <title>Linux Kernel: 内核数据结构</title>
    <url>/2023/04/19/Linux-Kernel-%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; Linux 内核内建了常用的数据结构，并鼓励开发者尽可能地重用这些数据结构，而不是重新发明轮子。这些数据结构包括<code>链表（list_head）</code>、<code>队列</code>、<code>散列表（hlist）</code>和<code>二叉树</code>。</p>
<span id="more"></span>

<blockquote>
<p>参考 《Understanding the Linux Kernel, Third Edition》 By Daniel P. Bovet &amp; Marco Cesati.<br>参考 《Linux Kernel Development, Third Edition》 By Robert Love.</p>
</blockquote>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表<code>list_head</code> 在头文件<code>include/linux/types.h</code> 中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>基本的处理函数和宏在头文件<code>include/linux/list.h</code> 中定义。</p>
<h3 id="初始化链表"><a href="#初始化链表" class="headerlink" title="初始化链表"></a>初始化链表</h3><p>初始化链表 <code>LIST_HEAD_INIT</code> 和 <code>LIST_HEAD</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">	struct list_head name = LIST_HEAD_INIT(name)</span></span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询操作最重要的不是获取<code>list_head</code>类型的指针，而是获得<code>list_head</code>所在的结构体的基地址。例如我们定义下面的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们如何根据一个<code>struct list_head *</code>指针类型获取其所在<code>struct person</code>结构体的基地址呢？<code>container_of</code>宏主要通过指针偏移运算来完成这个工作（<code>include/linux/kernel.h</code>）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;				\</span></span><br><span class="line"><span class="meta">	void *__mptr = (void *)(ptr);					\</span></span><br><span class="line"><span class="meta">	BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)-&gt;member) &amp;&amp;	\</span></span><br><span class="line"><span class="meta">			 !__same_type(*(ptr), void),			\</span></span><br><span class="line"><span class="meta">			 <span class="string">&quot;pointer type mismatch in container_of()&quot;</span>);	\</span></span><br><span class="line"><span class="meta">	((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>offsetof</code> 在<code>include/linux/stddef.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t)&amp;((TYPE*)0)-&gt;NUMBER)</span></span><br></pre></td></tr></table></figure>
<p>注意这里使用<code>TYPE*</code>类型的 <code>NULL(0)</code>指针并不会导致运行时错误，因为在编译阶段，编译器会将上诉代码翻译为<code>0+OFFSET</code>，其中<code>OFFSET</code>为<code>NUMBER</code>在类型<code>TYPE</code>中的偏移量。然后我们在<code>container_of</code>宏中将<code>struct list_head ptr</code>的地址减去该偏移量就可以获得其所在<code>TYPE</code>结构体的地址。</p>
<p>然后可以定义<code>list_entry</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">	container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @ptr : the list head to take the element from.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_first_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">	list_entry((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @ptr : the list head to take the element from.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_last_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">	list_entry((ptr)-&gt;prev, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_next_entry - get the next element in list</span></span><br><span class="line"><span class="comment"> * @pos:	the type * to cursor</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_next_entry(pos, member) \</span></span><br><span class="line"><span class="meta">	list_entry((pos)-&gt;member.next, typeof(*(pos)), member)</span></span><br></pre></td></tr></table></figure>

<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>直接遍历<code>struct list_head</code> 节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each	-	iterate over a list</span></span><br><span class="line"><span class="comment"> * @pos:	the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:	the head for your list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">	for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @n: another &amp;struct list_head to use as temporary storage</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">	for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</span></span><br><span class="line"><span class="meta">		pos = n, n = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>list_for_each_safe</code>可以用在遍历链表的过程中执行删除节点操作，它是通过增加一个额外的临时<code>hlist_node</code>指针<code>n</code>来实现的。</p>
<p>遍历 <strong>entry</strong> :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry	-	iterate over list of given type</span></span><br><span class="line"><span class="comment"> * @pos:	the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:	the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry(pos, head, member)				\</span></span><br><span class="line"><span class="meta">	for (pos = list_first_entry(head, typeof(*pos), member);	\</span></span><br><span class="line"><span class="meta">	     &amp;pos-&gt;member != (head);					\</span></span><br><span class="line"><span class="meta">	     pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>


<h3 id="边界检查"><a href="#边界检查" class="headerlink" title="边界检查"></a>边界检查</h3><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>进程链表是运用链表最重要的例子之一。在结构体<code>task_struct</code>中包含字段<code>struct list_head tasks</code>。</p>
<p>另外一个例子是<strong>等待队列</strong>。</p>
<h2 id="哈希链表"><a href="#哈希链表" class="headerlink" title="哈希链表"></a>哈希链表</h2><p>哈希链表由于自身特点的考虑，不使用双向链表。</p>
<p>定义如下（<code>include/linux/types.h</code>）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为什么头节点(<code>struct hlist_head</code>)不直接使用<code>struct hlist_node</code>，而是要重新定义一个结构体呢？<strong>答案是为了节省空间</strong>。</p>
<p>另外，使用二级指针<code>**pprev</code>在删除节点上的处理非常简单，无需关心是否是 head 节点。而使用单链表或双向链表时需要单独判断是否是 head 节点。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HLIST_HEAD_INIT &#123; .first = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HLIST_HEAD(name) struct hlist_head name = &#123;  .first = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_HLIST_NODE</span><span class="params">(<span class="keyword">struct</span> hlist_node *h)</span></span><br><span class="line">&#123;</span><br><span class="line">	h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	h-&gt;pprev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>向<code>hlist</code>链表添加节点时，可以直接添加到链表头部，也可以插入到中间位置。操作函数和宏在<code>include/linux/list.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hlist_add_head</span><span class="params">(<span class="keyword">struct</span> hlist_node *n, <span class="keyword">struct</span> hlist_head *h)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span> =</span> h-&gt;first;</span><br><span class="line">	n-&gt;next = first;</span><br><span class="line">	<span class="keyword">if</span> (first)</span><br><span class="line">		first-&gt;pprev = &amp;n-&gt;next;</span><br><span class="line">	WRITE_ONCE(h-&gt;first, n);</span><br><span class="line">	n-&gt;pprev = &amp;h-&gt;first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __hlist_del(<span class="keyword">struct</span> hlist_node *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span> =</span> n-&gt;next;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> **<span class="title">pprev</span> =</span> n-&gt;pprev;</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(*pprev, next);</span><br><span class="line">	<span class="keyword">if</span> (next)</span><br><span class="line">		next-&gt;pprev = pprev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hlist_del</span><span class="params">(<span class="keyword">struct</span> hlist_node *n)</span></span><br><span class="line">&#123;</span><br><span class="line">	__hlist_del(n);</span><br><span class="line">	n-&gt;next = LIST_POISON1;</span><br><span class="line">	n-&gt;pprev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>等待队列使用双向链表实现（<code>include/linux/wait.h</code>）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;</span><br><span class="line">	<span class="type">void</span>			*private;</span><br><span class="line">	<span class="type">wait_queue_func_t</span>	func;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __WAITQUEUE_INITIALIZER(name, tsk) &#123;					\</span></span><br><span class="line"><span class="meta">	.private	= tsk,							\</span></span><br><span class="line"><span class="meta">	.func		= default_wake_function,				\</span></span><br><span class="line"><span class="meta">	.entry		= &#123; NULL, NULL &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk)						\</span></span><br><span class="line"><span class="meta">	struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WAIT_QUEUE_HEAD_INITIALIZER(name) &#123;					\</span></span><br><span class="line"><span class="meta">	.lock		= __SPIN_LOCK_UNLOCKED(name.lock),			\</span></span><br><span class="line"><span class="meta">	.head		= &#123; &amp;(name).head, &amp;(name).head &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">	struct wait_queue_head name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br></pre></td></tr></table></figure>
<p>动态分配节点的初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_waitqueue_entry</span><span class="params">(<span class="keyword">struct</span> wait_queue_entry *wq_entry, <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	wq_entry-&gt;flags		= <span class="number">0</span>;</span><br><span class="line">	wq_entry-&gt;private	= p;</span><br><span class="line">	wq_entry-&gt;func		= default_wake_function;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_waitqueue_func_entry</span><span class="params">(<span class="keyword">struct</span> wait_queue_entry *wq_entry, <span class="type">wait_queue_func_t</span> func)</span></span><br><span class="line">&#123;</span><br><span class="line">	wq_entry-&gt;flags		= <span class="number">0</span>;</span><br><span class="line">	wq_entry-&gt;private	= <span class="literal">NULL</span>;</span><br><span class="line">	wq_entry-&gt;func		= func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>Linux Kernel</category>
      </categories>
  </entry>
  <entry>
    <title>Linux kernel User Guide</title>
    <url>/2023/03/09/Linux-kernel-User-Guide/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文对内核的使用方法（包括构建、编译等）作一些总结。</p>
<blockquote>
<p>参考 <a href="https://docs.kernel.org/admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a>。</p>
</blockquote>
<span id="more"></span>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><p>可以在 <a href="https://mirrors.edge.kernel.org/pub/linux/kernel">内核仓库</a> 中找到对应版本的源码压缩包、签名和补丁，也可以使用 git 克隆内核仓库。我们以 <code>5.4</code> 版本为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.tar.sign</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以使用国内的镜像源：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://mirror.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://mirror.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.tar.sign</span></span><br></pre></td></tr></table></figure>

<p>获取 <em>Greg Kroah-Hartman</em> 和 <em>Linus Torvalds</em> 的公钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg2 --locate-keys torvalds@kernel.org gregkh@kernel.org</span></span><br></pre></td></tr></table></figure>

<p>解压并验证签名：<br><code>$ xz -cd linux-5.4.tar.xz | gpg2 --verify linux-5.4.tar.sign -</code></p>
<p><code>$ tar xf linux-5.4.tar</code><br><code>$ cd linux-5.4</code></p>
<p>如果验证签名失败，并显示“缺少公钥”，可以根据提示的用户 ID 从密钥服务器导入公钥（前提是密钥服务器没有受到攻击）：</p>
<p><code>$ gpg2 --keyserver keyserver.ubuntu.com --recv-keys 0D3B3537C4790F9D</code></p>
<h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>编译环境所依赖的软件包列表：<a href="https://docs.kernel.org/process/changes.html#changes">Minimal requirements to compile the Kernel</a>。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="还原环境"><a href="#还原环境" class="headerlink" title="还原环境"></a>还原环境</h3><p><code>$ make mrproper</code><br>每次需要将内核源码树还原到刚解压时的状态，可运行该命令。</p>
<p><code>$ make clean</code><br>删除生成的目标文件（不会删除<code>.config</code>）</p>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p><code>make oldconfig</code> - 基于<code>Host</code>系统上的.config 进行配置，如<code>/boot/config-5.xx.xx-xx-generic</code></p>
<p><code>make defconfig</code> - 按默认选项进行配置（<strong>x86_64_defconfig</strong>）<br><code>make allnoconfig</code> - 除必须选项外，其他一律不选（常用于嵌入式系统）<br><code>make allyesconfig</code> -</p>
<p><code>make menuconfig</code> - 交互式界面</p>
<p>可以查看 <code>make help</code> 来获取更多信息。</p>
<p><strong>建议：</strong></p>
<ul>
<li>使用 <code>make defconfig</code> 获取默认配置</li>
<li>使用当前<code>Host</code>系统上的 config 文件，一般为 <code>/boot/config-xxxxxxxxx</code></li>
<li>其他发行版系统的配置文件</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><code>make -j&lt;N&gt;</code></p>
<p>可以使用 <code>ccache</code> 加速编译。</p>
<p>如果遇到下面的问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch/x86/entry/thunk_64.o: warning: objtool: missing symbol table</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://lkml.org/lkml/2021/1/14/387">https://lkml.org/lkml/2021/1/14/387</a></p>
<p>如果遇到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ld: arch/x86/boot/compressed/pgtable_64.o:(.bss+0x0): multiple definition of `__force_order&#x27;;</span><br><span class="line">arch/x86/boot/compressed/kaslr_64.o:(.bss+0x0): first defined here</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://lkml.org/lkml/2020/1/29/494">https://lkml.org/lkml/2020/1/29/494</a></p>
<p>如果遇到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc1: error: code model kernel does not support PIC mode</span><br></pre></td></tr></table></figure>
<p>则可以修改内核源码中的 <code>Makefile</code> 文件，添加<code>-fno-pie</code> 到变量 <code>KBUILD_CFLAGS</code> 。</p>
<p>很多编译问题都可以在<a href="https://lkml.org/">内核邮件列表</a>中查找到解决方法。</p>
<h2 id="其他架构"><a href="#其他架构" class="headerlink" title="其他架构"></a>其他架构</h2><p>如果要交叉构建基于 <code>vexpress-a9</code> 架构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig   <span class="comment"># 注意配置 DEBUG_PLL 和 EARLY_PRINTK</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j8</span></span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-bzImage"><a href="#安装-bzImage" class="headerlink" title="安装 bzImage"></a>安装 <code>bzImage</code></h3><p><code>bzImage</code> 是源码树根目录下生成的 <code>vmlinux</code> 的压缩版本。它的位置在<code>arch/x86/boot/bzImage</code>。</p>
<p>首先将它拷贝到<code>Host</code>系统的<code>/boot</code>目录中（可以重命名为<code>vmlinuz-5.4-xxx</code>，<code>xxx</code>为区分标记，可以设置为任意特定的字符串）<br><code>$ sudo cp arch/x86/boot/bzImage /boot/vmlinuz-5.4-xxx</code></p>
<p>然后修改 <code>grub</code> 配置文件</p>
<h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p><code>$ sudo make modules_install</code></p>
<h3 id="System-map-文件"><a href="#System-map-文件" class="headerlink" title="System.map 文件"></a>System.map 文件</h3><h2 id="内核命令行参数"><a href="#内核命令行参数" class="headerlink" title="内核命令行参数"></a>内核命令行参数</h2><p>我们将内核也看作一个单独的程序（带<code>main</code>函数）时，也可以给它传入命令行参数（例如由引导程序传递）。</p>
<h3 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h3><p>模块的参数可以通过内核命令行设置，例如：<br><code>usbcore.blinkenlights=1</code></p>
<p>也可以使用 <code>modprobe</code> ：<br><code>modprobe usbcore blinkenlights=1</code></p>
<p>使用 <code>modinfo info &lt;module_name&gt;</code> 可以获取可加载模块的参数列表。对于可加载模块，当被载入内核时，会将所有参数映射为 <code>/proc/modules/&#123;module_name&#125;/parameters/</code> 中的文件，这使得用户可以直接修改该文件来设置模块参数。</p>
<h3 id="命令行参数格式"><a href="#命令行参数格式" class="headerlink" title="命令行参数格式"></a>命令行参数格式</h3><ul>
<li><code>-</code> 与 <code>_</code> 是等价的，例如<code>log_buf=1M</code> 等价于 <code>log-buf=1M</code></li>
<li>对于带空格的字符串使用双引号，例如<code>param=&quot;spaces in here&quot;</code></li>
<li></li>
</ul>
<h2 id="设备列表"><a href="#设备列表" class="headerlink" title="设备列表"></a>设备列表</h2><h2 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h2><p>使用<code>/proc/sys</code>虚拟文件系统可以动态修改内核参数。直接修改该目录下的参数文件会立即生效，但重启后就失效了。如果需要永久生效，则需要修改<code>/etc/sysctl.conf</code>文件，并在修改后执行<code>sysctl -p</code>生效。使用<code>sysctl -a</code>查看所有可修改的变量名。</p>
<h2 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h2><blockquote>
<p>参考 <a href="https://blog.csdn.net/qq_19544957/article/details/129472898">跟踪分析Linux内核启动过程 - CSDN</a><br>参考 <a href="https://zhuanlan.zhihu.com/p/35180950">学习ulk3,搭建linux2.6内核的调试环境</a><br>参考 <a href="https://www.cnblogs.com/randyjang/p/14828909.html">使用GDB调试Linux Kernel</a><br>参考 <a href="https://www.kernel.org/doc/html/v6.13-rc6/dev-tools/gdb-kernel-debugging.html">Debugging kernel and modules via gdb</a></p>
</blockquote>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>安装 qemu 虚拟机：<code>$ sudo apt-get install qemu</code>  或者对于 ARM 架构：<code>$ sudo apt-get install qemu-system-arm</code><br>安装 gdb ：<code>$ sudo apt-get install gdb</code></p>
<h3 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h3><p><code>U-Boot</code> 主要用于嵌入式 Linux 系统的 <code>bootloader</code>，编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://gitee.com/mirrors/u-boot.git</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> u-boot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_ca9x4_defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j8</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>qemu</code> 虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-arm -M vexpress-a9 -m 256 -kernel u-boot -nographic</span></span><br><span class="line">U-Boot 2025.04-rc3-00052-g0fd7ee0306a8 (Mar 08 2025 - 17:55:54 +0800)</span><br><span class="line"></span><br><span class="line">DRAM:  256 MiB</span><br><span class="line">WARNING: Caches not enabled</span><br><span class="line">Core:  23 devices, 11 uclasses, devicetree: embed</span><br><span class="line">Flash: 128 MiB</span><br><span class="line">MMC:   mmci@5000: 0</span><br><span class="line">Loading Environment from Flash... *** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    uart@9000</span><br><span class="line">Out:   uart@9000</span><br><span class="line">Err:   uart@9000</span><br><span class="line">Net:   eth0: ethernet@3,02000000</span><br><span class="line">Hit any key to stop autoboot:  0</span><br><span class="line">=&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考 <a href="https://geekdaxue.co/read/barret@xhw7bc/dp7crb">基于 QEMU 的 ARM 仿真</a> 。<br>参考 <a href="https://chenlongos.com/raspi4-with-arceos-doc/chapter_1.1.html">支持树莓派4b的 Qemu 环境搭建</a></p>
</blockquote>
<h3 id="构建内核"><a href="#构建内核" class="headerlink" title="构建内核"></a>构建内核</h3><p>构建内核时，注意在<code>kernel hacking</code> 配置项中选择打开 <code>compile the kernel with debug info</code> 以及 <code>Provide GDB scripts for kernel debugging</code>。另外取消 <code>Kernel Features -&gt; Randomize the address of the kernel image</code> 配置项。</p>
<h3 id="制作根文件系统"><a href="#制作根文件系统" class="headerlink" title="制作根文件系统"></a>制作根文件系统</h3><p>使用 <a href="https://buildroot.org/">Buildroot 工具</a> 来制作根文件系统。官网下载源代码后，编译构建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make menuconfig  <span class="comment"># 选择架构和文件系统类型</span></span></span><br></pre></td></tr></table></figure>

<p>BuildRoot 会从源代码构建所以基础软件包，相对来说比较耗时。使用方法参考<a href="/2025/02/28/BuildRoot%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/" title="BuildRoot工具介绍">[BuildRoot 工具介绍]</a></p>
<p>如果只需要使用非常简单的根文件系统，可以直接使用 <a href="https://www.busybox.net/">busybox</a> 来制作。</p>
<h4 id="准备根目录镜像并初始化"><a href="#准备根目录镜像并初始化" class="headerlink" title="准备根目录镜像并初始化"></a>准备根目录镜像并初始化</h4><p>a. 创建并格式化 img 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=rootfs.img bs=4096 count=1024</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mke2fs rootfs.img</span></span><br></pre></td></tr></table></figure>

<p>b. 挂载镜像文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> rootfs</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mount -o loop rootfs.img rootfs</span></span><br></pre></td></tr></table></figure>

<p>c. 准备 dev 目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> rootfs/dev</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux 启动过程中会使用 console 设备</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">mknod</span> rootfs/dev/console c 5 1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另外需要一个 Linux 根设备</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">mknod</span> rootfs/dev/ram b 1 0</span></span><br></pre></td></tr></table></figure>

<p>d. 新建其他目录（可选）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> rootfs/&#123;proc,sys,var,run&#125;</span></span><br></pre></td></tr></table></figure>

<p>特别的，<code>/proc</code> 目录中包含了许多内核数据结构的映射，对于调试非常重要。一种方法是使用 qemu 进入 shell 后手动挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount -t proc none /proc</span></span><br></pre></td></tr></table></figure>

<p>也可以手动挂载 <code>sysfs</code> 文件系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount -t sysfs sysfs /sys</span></span><br></pre></td></tr></table></figure>

<p>特别注意的是，如果要支持设备热插拔（如<code>udev</code> 或者 <code>mdev</code>），需要挂载 <code>/dev</code> 和 <code>/dev/pts</code> 文件系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t devtmpfs devtmpfs /dev </span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br></pre></td></tr></table></figure>

<p>但重启后配置会消失。使用 <code>/etc/fstab</code> 或者 <code>/etc/init.d/rcS</code> 来自动挂载。</p>
<h4 id="构建-busybox"><a href="#构建-busybox" class="headerlink" title="构建 busybox"></a>构建 busybox</h4><p>下载 <a href="https://www.busybox.net/downloads/">BusyBox 源代码</a> 并验证数字签名后，进行构建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make menuconfig</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意修改配置：busybox settings -&gt; build options -&gt; build busybox as a static binary (no share libs)。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果生成的不是静态链接的可执行文件，那么 busybox 就会依赖宿主机上的一些动态链接库，而一个单 linux 内核无法提供这些库。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> make CONFIG_PREFIX=&lt;rootfs path&gt;/ install</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上述命令将 busybox 安装到已经挂载的 rootfs 根目录中</span></span><br></pre></td></tr></table></figure>

<p>最后卸载 rootfs 即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> umount rootfs</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-qemu-验证"><a href="#使用-qemu-验证" class="headerlink" title="使用 qemu 验证"></a>使用 qemu 验证</h4><p>在 树莓派5 ARM64 架构下验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意使用制作的 rootfs.img 镜像文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root=/dev/vda 使用 vda 关键字，而不是 ram 或者 sda</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">init=/bin/ash 这里使用 ash 作为内核启动后第一个运行的用户程序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> qemu-system-aarch64 -M virt -cpu cortex-a72 -kernel  <span class="built_in">arch</span>/arm64/boot/Image -drive format=raw,file=rootfs.img,media=disk -append <span class="string">&quot;root=/dev/vda init=/bin/ash&quot;</span> -serial stdio -display none</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">[    0.853700] EXT4-fs (vda): mounted filesystem without journal. Opts: (null)</span><br><span class="line">[    0.854244] VFS: Mounted root (ext4 filesystem) readonly on device 254:0.</span><br><span class="line">[    0.859716] devtmpfs: mounted</span><br><span class="line">[    0.893438] Freeing unused kernel memory: 5056K</span><br><span class="line">[    0.894555] Run /bin/ash as init process</span><br><span class="line">/bin/ash: can&#x27;t access tty; job control turned off</span><br><span class="line">~ # ls</span><br><span class="line">bin         linuxrc     proc        sbin        usr</span><br><span class="line">dev         lost+found  run         sys         var</span><br></pre></td></tr></table></figure>

<p>在 <code>vexpress-a9</code> 架构下验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-arm -M vexpress-a9 -m 512M -kernel <span class="built_in">arch</span>/arm/boot/zImage \</span></span><br><span class="line"><span class="language-bash">-dtb <span class="built_in">arch</span>/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic \</span></span><br><span class="line"><span class="language-bash">-append <span class="string">&quot;root=/dev/mmcblk0 rw console=ttyAMA0&quot;</span> -sd rootfs.img</span></span><br></pre></td></tr></table></figure>


<h3 id="qemu-gdb-调试内核"><a href="#qemu-gdb-调试内核" class="headerlink" title="qemu + gdb 调试内核"></a>qemu + gdb 调试内核</h3><p>在调试模式下启动 qemu，其中 “-s” 选项表示：使用 tcp 1234 端口；“-S” 选项表示只有在 gdb 连上 tcp 1234 端口后，CPU 才会继续执行。<code>nokaslr</code> 禁用 <strong>ASLR</strong> 安全机制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-x86_64 -s -S -kernel <span class="built_in">arch</span>/x86/boot/bzImage -append <span class="string">&quot;root=/dev/zero console=ttyS0 nokaslr&quot;</span> -serial stdio -display none</span></span><br></pre></td></tr></table></figure>
<p>如果是 <code>arm64</code> 架构： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-aarch64 -s -S -no-reboot -M virt -cpu cortex-a72 -smp 4 -kernel <span class="built_in">arch</span>/arm64/boot/Image --append <span class="string">&quot;root=/dev/vda2 console=ttyAMA0 nokaslr&quot;</span> -serial stdio -display none</span></span><br></pre></td></tr></table></figure>

<p>指定 rootfs 的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-aarch64 -s -S -no-reboot -M virt -cpu cortex-a72 -smp 4 -kernel <span class="built_in">arch</span>/arm64/boot/Image -drive format=raw,file=rootfs.img,media=disk --append <span class="string">&quot;nokaslr root=/dev/vda init=/bin/ash&quot;</span> -serial stdio -display none</span></span><br></pre></td></tr></table></figure>

<p>运行 gdb：<code>$ gdb vmlinux</code> 或者 <code>$ gdb vmlinuz</code><br>注意这里如果提示无法加载<code>vmlinux-gdb.py</code>，则根据提示在 gdb 配置文件中为 <code>add-auto-load-safe-path</code> 设置脚本绝对路径。该脚本中扩展了一些 gdb 命令，比如查看内核缓冲区、查看进程等。</p>
<p>然后在 gdb 中 输入 <code>target remote localhost:1234</code> 并设置断点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) target remote localhost:1234</span><br><span class="line">(gdb) break start_kernel</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, start_kernel () at init/main.c:576</span><br><span class="line">576	&#123;</span><br><span class="line"></span><br><span class="line">(gdb) lx-dmesg</span><br></pre></td></tr></table></figure>

<h3 id="构建模块并调试"><a href="#构建模块并调试" class="headerlink" title="构建模块并调试"></a>构建模块并调试</h3><blockquote>
<p>参考 <a href="https://docs.linuxkernel.org.cn/kbuild/modules.html">构建外部模块</a></p>
</blockquote>
<p>在编译完内核后，将内核模块安装到 rootfs 的 <code>lib/modules</code> 目录中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make INSTALL_MOD_PATH=rootfs/ modules_install</span></span><br></pre></td></tr></table></figure>

<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p>如果要关闭某个函数的编译优化，使用 <code>__attribute__((optimize(0)))</code> 编译器优化选项。如果要关闭某段代码的优化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    fun1();</span><br><span class="line"><span class="meta">#prama GCC push_options</span></span><br><span class="line"><span class="meta">#prama GCC optimize (0)</span></span><br><span class="line">    fun2();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="meta">#prama GCC pop_options</span></span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果进入根文件系统后，需要创建文件或者目录，需要在内核启动时设定根文件系统的读写权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.... --append &quot;nokaslr root=/dev/vda rw init=/bin/ash&quot; ...</span><br></pre></td></tr></table></figure>
<p>在 <code>root=/dev/vda</code> 后紧跟 <code>rw</code> 标志。</p>
<p>如果要 <code>init</code> 进程在进入 shell 前做一些其他任务，则启动参数<code>init</code>可以使用  <code>/linuxrc</code>，并在根文件系统中创建 <code>/etc/init.d/rcS</code> 可执行脚本，在脚本中可以编写启动其他用户进程。</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>Linux Kernel</category>
      </categories>
  </entry>
  <entry>
    <title>Linux内核的进程调度算法分析</title>
    <url>/2025/02/27/Linux%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>进程是操作系统的核心概念之一，也是自多任务（分时）处理系统出现以来最成功的抽象概念之一。在多任务并发系统中，对计算、存储、IO等资源的合理、高效分配是决定系统性能和稳定性的关键因素。在复杂的系统中，各种任务对资源的占用种类、时间、实时要求等有着很大的差异，对于执行任务的进程而言，这个问题就等价于如何高效、合理地对进程进行调度。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://zhuanlan.zhihu.com/p/460055814">玩转 Linux 内核-进程调度</a></p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Linux 2.6 以后的内核仍然存在<code>中断</code>、<code>软中断</code>、<code>自旋锁</code>等<code>原子上下文</code>进程无法抢占执行的情况，这是 Linux 内核本身只提供<code>软实时能力</code>的原因。</p>
<p>如果给 Linux 内核打上 <code>RT-Preempt</code> 补丁，则<code>中断</code>和<code>软中断</code>都被<strong>线程化</strong>了，<code>自旋锁</code>也被<code>互斥体</code>替换，Linux 内核变得能支持<code>硬实时</code>。</p>
<h2 id="调度算法的常用策略"><a href="#调度算法的常用策略" class="headerlink" title="调度算法的常用策略"></a>调度算法的常用策略</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><h3 id="基于优先级"><a href="#基于优先级" class="headerlink" title="基于优先级"></a>基于优先级</h3><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><h2 id="O-N-调度算法"><a href="#O-N-调度算法" class="headerlink" title="O(N) 调度算法"></a>O(N) 调度算法</h2><h2 id="O-1-调度算法"><a href="#O-1-调度算法" class="headerlink" title="O(1) 调度算法"></a>O(1) 调度算法</h2><h2 id="CFS-调度算法"><a href="#CFS-调度算法" class="headerlink" title="CFS 调度算法"></a>CFS 调度算法</h2><blockquote>
<p>任何进程所获得的处理器时间是由它自己和其他所有可运行进程 nice 值的相对差值决定的。nice 值对时间片的作用不再是算术加权，而是几何加权。任何 nice 值对应的绝对时间不再是一个绝对值，而是处理器的使用比。<br>—— LKD</p>
</blockquote>
<p>CFS 调度算法的核心：选择具有最小 vruntime 的任务。任务被组织成红黑树（rbtree）的结构，树上节点的键值就是可运行进程的 vruntime。</p>
<blockquote>
<p>CFS 的进程选择算法可简单总结为： “运行 rbtree 树中最左边叶子节点所代表的那个进程。”</p>
</blockquote>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="更换调度器模块"><a href="#更换调度器模块" class="headerlink" title="更换调度器模块"></a>更换调度器模块</h3>]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>Linux Kernel</category>
      </categories>
  </entry>
  <entry>
    <title>Linux内核性能优化</title>
    <url>/2025/03/03/Linux%E5%86%85%E6%A0%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 内核作为众多操作系统的核心，已经运行在大量设备上（包括服务器、桌面和嵌入式设备），其参数的调优对于性能的提升至关重要。性能的提升是系统性工程，它包括多个层面，如 CPU、文件系统、内存性能、网络性能等，这些不同方面也会相互制约。优化工程师需要根据不同的应用场景做出权衡才达到最好的效果。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://zhuanlan.zhihu.com/p/483681854">Linux 内核调优</a><br>参考 <a href="https://wenku.csdn.net/column/fxq31muf32#1.%20Linux%E5%86%85%E6%A0%B8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0">Linux 内核性能调优实战</a><br>参考 <a href="https://blog.csdn.net/ethnicitybeta/article/details/139917632">linux磁盘I&#x2F;O调度器详解</a><br>参考 <a href="https://zhuanlan.zhihu.com/p/686247554">Linux 性能调优必备：perf 使用指南</a></p>
</blockquote>
<h2 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h2><p>内核参数是 Linux 操作系统中用来调整和配置系统内核行为的关键变量。这些参数通常在系统启动时通过命令行传递给内核，或者在系统运行时动态地进行调整。内核参数可以影响系统的内存管理、网络配置、文件系统以及各种硬件设备的行为和性能。</p>
<h3 id="使用-Sysctl-命令"><a href="#使用-Sysctl-命令" class="headerlink" title="使用 Sysctl 命令"></a>使用 Sysctl 命令</h3><p><code>sysctl</code> 是一个用于运行时动态修改内核参数的工具。例如，如果要减少<strong>系统交换行为</strong>，可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w vm.swappiness=10</span><br></pre></td></tr></table></figure>

<h3 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h3><p>在<code>/etc/sysctl.conf</code>文件中添加或修改内核参数后，为了使新的设置立即生效，需要执行sudo sysctl -p。这将重新加载配置文件中的参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/sysctl.conf</span></span><br><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure>

<p>在 <code>mm/vmscan.c</code> 中，<code>vm.swappiness</code> 参数所对应的内核变量为 <code>vm_swappiness</code>，该变量被初始化为 <code>60</code>（内存使用到 40% 的时候就会发生内存交换）。通过调节该参数可以降低系统对 swap 的使用，提高内存性能。可以使用 <code>free -m</code> 命令查看当前 swap 分区的使用情况。</p>
<p>除了 <code>swappiness</code> 参数外，还可以设置和脏页相关的参数，如 <code>vm.dirty_ratio</code> （该参数可以增加被内核刷新到磁盘之前的脏页数量，默认值为 20）。为了设置合适的参数值，最好查看一下当前系统上脏页的数量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/vmstat  | egrep <span class="string">&quot;dirty|writeback&quot;</span></span></span><br><span class="line">nr_dirty 2</span><br><span class="line">nr_writeback 0</span><br><span class="line">nr_writeback_temp 0</span><br><span class="line">nr_dirty_threshold 32799</span><br><span class="line">nr_dirty_background_threshold 16399</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>常见误区：</p>
<ul>
<li><strong>过度调整</strong>：调整大量参数容易导致系统不稳定</li>
<li><strong>不理解参数含义</strong></li>
<li><strong>缺乏测试</strong>：尽量避免在生成环境直接进行参数调整</li>
</ul>
<p>所以应该注意：</p>
<ul>
<li>备份原始配置</li>
<li>逐步调整</li>
<li>使用性能监控工具</li>
<li>参考官方文档和社区经验</li>
</ul>
<h2 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h2><p>a. 可以配置和调整内存参数</p>
<p>b. 识别内存泄漏，使用 <code>valgrind</code> 工具</p>
<p>c. 优化程序代码，也可以开启内核的 slab 分配器调试功能，来诊断和优化内存使用。</p>
<h3 id="内存性能分析工具"><a href="#内存性能分析工具" class="headerlink" title="内存性能分析工具"></a>内存性能分析工具</h3><p><code>top</code> 、<code>htop</code> 和 <code>free</code> 命令，以及 <code>vmstat</code> 命令</p>
<h3 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h3><p>如果要增加交换分区大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> swapon -s           <span class="comment"># 查看当前 swap 分区</span></span></span><br><span class="line">Filename                                Type            Size            Used            Priority</span><br><span class="line">/var/swap                               file            524272          511392          -2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">touch</span> /var/swap2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 600 /var/swap2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/var/swap2 bs=1M count=512   <span class="comment"># dd 创建 swap 文件 512M</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> mkswap /var/swap2  <span class="comment"># 格式化为 swap 分区</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> swapon /var/swap2  <span class="comment"># 激活并挂载 swap2 分区</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> swapon -s          <span class="comment"># 重新查看 swap 分区总大小</span></span></span><br><span class="line">Filename                                Type            Size            Used            Priority</span><br><span class="line">/var/swap                               file            524272          461856          -2</span><br><span class="line">/var/swap2                              file            524272          0               -3</span><br></pre></td></tr></table></figure>

<h2 id="CPU-性能"><a href="#CPU-性能" class="headerlink" title="CPU 性能"></a>CPU 性能</h2><h3 id="CPU-调度器"><a href="#CPU-调度器" class="headerlink" title="CPU 调度器"></a>CPU 调度器</h3><h4 id="noop-调度器"><a href="#noop-调度器" class="headerlink" title="noop 调度器"></a>noop 调度器</h4><p><code>noop</code> 调度器是最简单的 I&#x2F;O 调度器，它只执行基本的合并操作，并按 FIFO（先来先服务）的顺序将请求发送到磁盘。这种调度器非常轻量,适用于以下场景：</p>
<ul>
<li>虚拟化环境：因为虚拟机通常会有自己的 I&#x2F;O 调度器。</li>
<li>高速固态硬盘（SSD）：因为 SSD 的寻道时间几乎为零，不需要复杂的调度算法。</li>
</ul>
<p>配置命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;noop&quot; | sudo tee /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>

<h4 id="Deadline-调度器"><a href="#Deadline-调度器" class="headerlink" title="Deadline 调度器"></a>Deadline 调度器</h4><p><code>deadline</code> 调度器试图在保证 I&#x2F;O 请求公平的同时，避免请求的长时间等待。它为每个请求设置一个截止时间，并尽量在截止时间内完成。这种调度器适用于以下场景：</p>
<ul>
<li>数据库和实时系统：需要低延迟和较高的吞吐量。</li>
</ul>
<p>配置命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deadline&quot; | sudo tee /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>

<h4 id="cfq-调度器"><a href="#cfq-调度器" class="headerlink" title="cfq 调度器"></a>cfq 调度器</h4><p><code>cfq</code> 调度器为每个进程分配一个时间片，轮流处理各进程的 I&#x2F;O 请求，从而实现了公平的 I&#x2F;O 调度。这种调度器适用于以下场景：</p>
<ul>
<li>桌面系统和多用户环境：需要在多个进程之间公平分配 I&#x2F;O 带宽。</li>
</ul>
<p>配置命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;cfq&quot; | sudo tee /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>

<h4 id="bfq-调度器"><a href="#bfq-调度器" class="headerlink" title="bfq 调度器"></a>bfq 调度器</h4><p><code>bfq</code> 调度器是 <code>cfq</code> 的增强版，特别适用于需要精细控制和高带宽利用率的场景。它按预算来分配 I&#x2F;O 带宽，确保不同进程能够获得稳定的I&#x2F;O 性能。这种调度器适用于以下场景：</p>
<ul>
<li>多媒体应用和流媒体服务器：需要稳定的带宽和低延迟。</li>
</ul>
<p>配置命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;bfq&quot; | sudo tee /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>

<h4 id="mq-deadline-调度器"><a href="#mq-deadline-调度器" class="headerlink" title="mq-deadline 调度器"></a>mq-deadline 调度器</h4><p><code>mq-deadline</code> 是 <code>deadline</code> 调度器的多队列版本，适用于多队列块设备。它保留了 deadline 的低延迟特性，并能够在多队列设备上实现更好的性能。这种调度器适用于以下场景：</p>
<ul>
<li>多队列设备和NVMe固态硬盘：需要高并发和低延迟。</li>
</ul>
<p>配置命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;mq-deadline&quot; | sudo tee /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>

<h4 id="kyber-调度器"><a href="#kyber-调度器" class="headerlink" title="kyber 调度器"></a>kyber 调度器</h4><p>在 <code>Multiqueue blocker layer</code> 在内核 3.13 版本合入之后，相应的 software queue(也叫soft-context) level 的调度器也相应的诞生，其中一个叫做<code>Kyber</code>调度器，该调度器主要是保证 IO 请求的延迟， 那么显然在某些情况下会牺牲带宽. 做法是通过调整异步 IO 的队列深度，提高同步 IO 的队列深度来保证同步 IO 不被异步 IO 严重阻塞，这里同步 IO 往往对应读,异步 IO 对应写。</p>
<p>·Kyber·中引入了所谓调度域(domain)的概念，所谓的调度域其实就是指不通类型的 IO 操作，比如 read, write, discard 等等。</p>
<p><code>Kyber</code>可以根据IO 请求的延迟的统计信息动态调整每个调度域在 software queue 里的深度，如果某个域的时延满足要求，则减少队列的深度，如果时延比较大，表示没有足够的这类请求被提交到 hardware queue，则增大该域队列深度。</p>
<p>配置命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;kyber&quot; | sudo tee /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡（Load Balancing）是一种优化策略，旨在合理分配 CPU 资源，以达到系统资源的最高效利用。在 Linux 中，可以通过调整<code>/sys/devices/system/cpu/cpu*/cpufreq/scaling_governor</code>文件来配置CPU的频率调节器（scaling governor），该调节器负责决定 CPU 的工作频率。</p>
<ul>
<li>ondemand：当 CPU 负载增加时，提升 CPU 频率；负载减少时降低频率。</li>
<li>conservative：与 ondemand 类似，但频率变化更平滑。</li>
<li>powersave：始终以最低频率运行，适合能耗敏感的环境。</li>
<li>performance：始终以最高频率运行，适合性能要求高的环境。</li>
</ul>
<h3 id="CPU-亲和性"><a href="#CPU-亲和性" class="headerlink" title="CPU 亲和性"></a>CPU 亲和性</h3><p>通过设置 CPU 亲和性，可以减少任务在多个 CPU 核心之间迁移的开销，从而提高性能。在 Linux 中，可以通过 <code>taskset</code> 命令设置进程的 CPU 亲和性，例如，将进程绑定到 CPU 核 0 和 核 1 上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tasklet -cp 0,1 &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h3 id="优化中断处理和内核抢占"><a href="#优化中断处理和内核抢占" class="headerlink" title="优化中断处理和内核抢占"></a>优化中断处理和内核抢占</h3><p>可以使用内核参数配置或者修改 <code>/proc/sys/kernel/preempt_disable</code> （该属性已经弃用）来关闭内核抢占，但关闭抢占对稳定性和实时性有负面影响。</p>
<p>也可以优化进程调度参数</p>
<h3 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h3><p>使用 <code>perf</code> 监视系统级性能问题，比如 CPU 缓存缺少、分支预测错误等。<br>安装 <code>perf</code> :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-perf</span><br></pre></td></tr></table></figure>

<p><strong>列出可用事件</strong><br>列出所有可用的性能事件。这些事件包括硬件事件（如 CPU 周期、缓存命中&#x2F;未命中等）和软件事件（如上下文切换、系统调用等）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perf list</span><br></pre></td></tr></table></figure>

<p><strong>记录性能数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> perf record -g -a -F 99  <span class="built_in">sleep</span> 6</span></span><br></pre></td></tr></table></figure>
<p><code>-g</code> 表示记录调用栈，<code>-a</code> 表示对所有 CPU 进行采样，<code>-F 99</code> 表示每秒采样 99 次，<code>sleep 6</code> 是要分析的程序。这会生成一个 <code>perf.data</code> 文件，它包含了采集的性能数据，也可以用 <code>-o</code> 来指定生成的文件名。</p>
<p><strong>分析性能数据</strong><br>使用 <code>perf report</code> 来分析记录的数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perf report</span><br></pre></td></tr></table></figure>

<p>使用 <code>pref top</code> 命令实时查看当前运行的函数热点。</p>
<p>使用 <code>vmstat</code> 和 <code>pidstat</code>。</p>
<h2 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h2><h3 id="配置文件系统参数以优化I-O性能"><a href="#配置文件系统参数以优化I-O性能" class="headerlink" title="配置文件系统参数以优化I&#x2F;O性能"></a>配置文件系统参数以优化I&#x2F;O性能</h3><p>文件系统参数调整是优化 I&#x2F;O 性能的关键步骤。这些调整可以通过挂载时参数或是在<code>/etc/fstab</code>中进行设置来实现。举例来说，可以调整<code>/etc/fstab</code>中的<code>noatime</code>参数，减少对文件访问时间的记录，从而减少写操作，提高性能。</p>
<p>此外，<code>/etc/fstab</code>提供了其他一些有用的参数，如<code>commit</code>控制磁盘写入操作的频率，<code>auto</code>或<code>noauto</code>指定是否自动挂载，以及<code>rw</code>或<code>ro</code>指定文件系统挂载为读写或只读模式。</p>
<p>其他内核参数：</p>
<ul>
<li><code>vm.dirty_writeback_centisecs</code>：控制脏页写回磁盘的频率。</li>
<li><code>vm.dirty_expire_centisecs</code>：控制脏页在内存中保留的时间。</li>
<li><code>fs.file-max</code> ： 系统中最大打开文件数</li>
</ul>
<p>对于写密集型应用，可以减少这两个值，减少数据丢失的风险。</p>
<h3 id="IO-调度器"><a href="#IO-调度器" class="headerlink" title="IO 调度器"></a>IO 调度器</h3><p>类似 CPU 调度器。另外，在<code>/etc/fstab</code>文件中也可以指定调度器类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/dev/sdb1 /var ext4 defaults,deadline 0 2</span><br></pre></td></tr></table></figure>

<h3 id="性能监控工具"><a href="#性能监控工具" class="headerlink" title="性能监控工具"></a>性能监控工具</h3><p>监控文件系统性能是及时发现性能瓶颈和故障的关键。常用的工具包括<code>iostat</code>和<code>iotop</code>，它们提供了磁盘 I&#x2F;O 的详细信息。</p>
<ul>
<li><code>iostat</code>提供了 CPU 和磁盘 I&#x2F;O 的统计信息，例如每秒的磁盘读写操作次数（r&#x2F;s 和 w&#x2F;s）以及每秒的传输量（kB_read&#x2F;s 和 kB_wrtn&#x2F;s）。</li>
<li><code>iotop</code>则显示了实时的 I&#x2F;O 使用情况，显示每个进程的 I&#x2F;O 使用率。</li>
</ul>
<h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="网络性能参数"><a href="#网络性能参数" class="headerlink" title="网络性能参数"></a>网络性能参数</h3><p>网络参数控制着操作系统如何处理网络流量。正确的参数设置可以提高数据吞吐量，降低网络延迟，甚至增强网络的鲁棒性。以下是一些关键的网络参数以及它们对性能的影响：</p>
<ul>
<li><p><strong>TCP窗口大小</strong>：控制数据包的发送速率和系统缓冲数据的能力。</p>
</li>
<li><p><strong>拥塞控制算法</strong>：影响数据在网络中传输的策略，如 TCP 的 CUBIC 或 TCP BBR。</p>
</li>
<li><p><strong>网络接口队列长度</strong>：调整队列长度可以影响数据包的排队和处理方式。</p>
</li>
<li><p><strong>IP碎片重组</strong>：影响处理网络数据包分片的方式，进而影响性能。</p>
</li>
<li></li>
</ul>
<p>使用 <code>stsctl</code> 查看当前的网络参数配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> sysctl -a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TCP 窗口大小</span></span><br><span class="line">net.core.rmem_default = 212992</span><br><span class="line">net.core.rmem_max = 212992</span><br><span class="line">net.core.wmem_default = 212992</span><br><span class="line">net.core.wmem_max = 212992</span><br><span class="line">net.ipv4.tcp_rmem = 16384       131072  6291456</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 2  # 允许重用 TIME_WAIT 状态的连接。对于高并发服务器，可以启用。</span><br><span class="line">net.core.somaxconn = 4096  # 控制系统每个监听套接字的连接队列的最大长度。</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 256 # 控制系统中 SYN 队列的最大长度。对于高并发服务器，可以增加该值，以防止 SYN Flood 攻击。</span><br><span class="line">net.ipv4.tcp_syncookies = 1 # 控制是否启用 SYN Cokkie 机制，用于防止 SYN Flood 攻击。</span><br><span class="line">net.ipv4.tcp_fin_timeout = 60 # 控制 TCP 连接在 FIN_WAIT_2 状态的超时时间，对于高并发服务器，可以减少该值，以快速释放资源。</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ul>
<li>使用 <code>iperf3</code> 进行网络吞吐量测试。</li>
<li>使用 <code>bmon</code>和 <code>iftop</code> 监控网络使用情况。</li>
<li>使用 <code>netstat</code> 和 <code>ss</code> 来收集网络连接和统计信息。</li>
</ul>
<p>a. 测试 TCP 吞吐量</p>
<p>在服务端（192.168.100.101）运行 <code>iperf3</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">iperf3 -s -p 5001</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Server listening on 5001 (test #1)</span><br><span class="line">-----------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>在客户端连接服务端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> iperf3 -c 192.168.100.101 -p 5001</span></span><br><span class="line">Connecting to host 192.168.100.101, port 5001</span><br><span class="line">[  5] local 192.168.100.102 port 49482 connected to 192.168.100.101 port 5001</span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Retr  Cwnd</span><br><span class="line">[  5]   0.00-1.00   sec  40.3 MBytes   338 Mbits/sec  1063   59.4 KBytes</span><br><span class="line">[  5]   1.00-2.00   sec  39.4 MBytes   330 Mbits/sec  1195   50.9 KBytes</span><br><span class="line">[  5]   2.00-3.00   sec  39.8 MBytes   334 Mbits/sec  1174   53.7 KBytes</span><br><span class="line">[  5]   3.00-4.00   sec  40.0 MBytes   336 Mbits/sec  1132   36.8 KBytes</span><br><span class="line">[  5]   4.00-5.00   sec  39.3 MBytes   329 Mbits/sec  1165   36.8 KBytes</span><br><span class="line">[  5]   5.00-6.00   sec  39.7 MBytes   333 Mbits/sec  1114   39.6 KBytes</span><br><span class="line">[  5]   6.00-7.00   sec  39.5 MBytes   332 Mbits/sec  1139   67.9 KBytes</span><br><span class="line">[  5]   7.00-8.00   sec  40.0 MBytes   335 Mbits/sec  1241   50.9 KBytes</span><br><span class="line">[  5]   8.00-9.00   sec  39.6 MBytes   332 Mbits/sec  1160   41.0 KBytes</span><br><span class="line">[  5]   9.00-10.00  sec  39.5 MBytes   331 Mbits/sec  1107   39.6 KBytes</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Retr</span><br><span class="line">[  5]   0.00-10.00  sec   397 MBytes   333 Mbits/sec  11490             sender</span><br><span class="line">[  5]   0.00-10.00  sec   396 MBytes   332 Mbits/sec                  receiver</span><br><span class="line"></span><br><span class="line">iperf Done.</span><br></pre></td></tr></table></figure>

<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="内核安全参数"><a href="#内核安全参数" class="headerlink" title="内核安全参数"></a>内核安全参数</h3><p><code>kernel.randomize_va_space</code> 控制地址空间布局随机化（ASLR）的级别：</p>
<ul>
<li>0 ： 关闭 ASLR</li>
<li>1 :  部分随机数（栈、共享库、堆）</li>
<li>2 ： 完全随机化（栈、共享库、堆、内存映射）</li>
</ul>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>Linux Kernel</category>
      </categories>
  </entry>
  <entry>
    <title>Mersenne Twister Algorithm Analysis</title>
    <url>/2024/12/22/Mersenne-Twister-Algorithm-Analysis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>梅森旋转算法（Mersenne Twister Algorithm）</strong> 是一个伪随机发生算法。由松本真和西村拓士在 1997 年开发，基于有限二进制字段上的矩阵线性递归。虽然在实现上，MT算法使用了<strong>反馈移位寄存器（FSR）</strong>，但注意其不能作为密码学意义上的伪随机数发生器。</p>
<p>最为广泛使用 Mersenne Twister 的一种算法变体是 <code>MT19937</code>，可以产生 32 位整数序列。</p>
<span id="more"></span>

<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="梅森素数"><a href="#梅森素数" class="headerlink" title="梅森素数"></a>梅森素数</h3><p>如果 p 是素数，我们将 $ 2^p - 1 $ 的一类数记为 $ M_p $，如果 $ M_p $ 也是素数，那么它就被称为 <strong>梅森素数（Mersenne Prime Number）</strong>。</p>
<p>首先，用因式分解法可以证明，若 $ 2^p - 1 $ 是素数，则 p 也一定是素数，证明如下：<br>首先，易知 k方差的因式分解如下：<br>$$ a^k - 1 &#x3D;  (a - 1)(a^{k-1} + a^{k-2} + … + a + 1) $$</p>
<p>我们假设 p 不是素数，其因式分解为 $ p &#x3D; sk (s &gt; 1, k &gt; 1)$，则：<br>$$ 2^p - 1 &#x3D; 2^{sk} - 1 &#x3D; ({2^s})^k - 1 &#x3D; (2^s - 1)[({2^s})^{k-1} + ({2^s})^{k-2} + … + 2^s + 1] $$</p>
<p>即 $ 2^p - 1 $ 可以因式分解为大于 1 的整数，这与其为素数的前提条件矛盾，故原假设不成立，所以 p 是素数。</p>
<p>但反过来，如果 p 为素数，则 $ 2^p - 1 $ 不一定为素数。目前已经发现 52 个梅森素数，最大的是 $ M_{136279841} $（即 $ 2^{136279841} - 1 $）。</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p><code>MT19937</code> 算法的周期为 $ 2^{19937}  - 1 $，该算法的优点如下：<br>a. 周期非常长，该周期为梅森素数<br>b. 在 1 &lt;&#x3D; k &lt;&#x3D; 623 都满足 k-分布<br>c. 产生速度快。</p>
<p>算法分为三个阶段：</p>
<ul>
<li>a. 初始化，获得基础的梅森旋转链</li>
<li>b. 对旋转链进行旋转算法</li>
<li>c. 对旋转算法所得结果进行处理，提取伪随机数</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化 state &#x3D; 0, 初始化向量 iv 含有 n 个元素，每一个元素为一个 word (32位或者64位) 长。其中将 seed 设置为 iv 中的第一个向量，剩下的 n - 1 个 word 按照如下的方式初始化：<br>$$ x_i &#x3D; f \times (x_{i-1} \bigoplus (x_{i-1} &gt;&gt; (w - 2))) + i $$<br>其中 f 为常数 <code>1812433253</code>。</p>
<p>从而得到一条初始化的梅森链。</p>
<h3 id="梅森旋转"><a href="#梅森旋转" class="headerlink" title="梅森旋转"></a>梅森旋转</h3><p>对于 k 从 0 到 n - 1:<br>$$ \vec x_k &#x3D; \vec x_{k+m} \bigoplus ((\vec x_k ^{(u)}||\vec x_{k+1} ^{(l)})A) $$<br>其中，$ \vec x_k ^{(u)} $ 代表第 k 个向量的高 $ w - r $ 位，$ \vec x_{k+1} ^{(l)} $ 代表第 k + 1 个向量的低 r 位。A 矩阵定义如下：</p>
<p>$$A &#x3D; \begin{pmatrix}<br>0&amp;I_{w-1}\\<br>a_{w-1}&amp;(a_{w-2},…,a_0)\\<br>\end{pmatrix}$$</p>
<p>因此，$ \vec xA $ 可以直接表示为：<br>$$ xA &#x3D; \begin{cases}<br>x &gt;&gt; 1 &amp; x_0 &#x3D; 0 \\<br>(x &gt;&gt; 1) \bigoplus a &amp; x_0 &#x3D; 1<br>\end{cases}$$</p>
<p>其中 $x_0$ 是向量 $\vec x$的最低位；a 为常量。</p>
<h3 id="获取随机数"><a href="#获取随机数" class="headerlink" title="获取随机数"></a>获取随机数</h3><p>首先，在梅森链中获取 state 位置的 word，赋值给 x，然后通过下面的方式获取最终的随机数：<br>$$\begin{align}<br>y \equiv x \bigoplus ((x &gt;&gt; u) &amp; d) \\<br>y \equiv y \bigoplus ((y &lt;&lt; s) &amp; b) \\<br>y \equiv y \bigoplus ((y &lt;&lt; t) &amp; c) \\<br>z \equiv y \bigoplus ((y &gt;&gt; l)) \\<br>\end{align}$$</p>
<p>获取完随机数后，state + 1。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>参考 <a href="https://blog.acdawn.cn/2024/02/08/Academic/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9B%B8%E5%85%B3/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95/">梅森旋转算法</a></p>
</blockquote>
<p>32位版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:  </span><br><span class="line">    <span class="comment"># w: word 大小  </span></span><br><span class="line">    <span class="comment"># n: 参与梅森旋转的随机数个数  </span></span><br><span class="line">    <span class="comment"># m: 中间词, 在[1,n)  </span></span><br><span class="line">    <span class="comment"># r: [0,w-1)    w, n, m, r = 32, 624, 397, 31  </span></span><br><span class="line">  </span><br><span class="line">    a = <span class="number">0x9908b0df</span>  </span><br><span class="line">    u, d = <span class="number">11</span>, <span class="number">0xffffffff</span>  </span><br><span class="line">    s, b = <span class="number">7</span>, <span class="number">0x9d2c5680</span>  </span><br><span class="line">    t, c = <span class="number">15</span>, <span class="number">0xefc60000</span>  </span><br><span class="line">    l = <span class="number">18</span>  </span><br><span class="line">    f = <span class="number">1812433253</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        seed = <span class="number">0</span>  </span><br><span class="line">        <span class="variable language_">self</span>.state = <span class="number">0</span>  </span><br><span class="line">        <span class="comment"># 初始化，生成n行w列的向量  </span></span><br><span class="line">        <span class="variable language_">self</span>.iv = [<span class="number">0</span>] * <span class="variable language_">self</span>.n  </span><br><span class="line">        <span class="variable language_">self</span>.iv[<span class="number">0</span>] = seed  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="variable language_">self</span>.n):  </span><br><span class="line">            prev = <span class="variable language_">self</span>.iv[i - <span class="number">1</span>]  </span><br><span class="line">            temp = <span class="variable language_">self</span>.f * (prev ^ (prev &gt;&gt; (<span class="variable language_">self</span>.w - <span class="number">2</span>))) + i  </span><br><span class="line">            <span class="variable language_">self</span>.iv[i] = temp &amp; <span class="number">0xffffffff</span>  <span class="comment"># 转换为int32  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twister</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="comment"># 梅森旋转  </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n):  </span><br><span class="line">            y = (<span class="variable language_">self</span>.iv[i] &amp; <span class="number">0x80000000</span>) + (<span class="variable language_">self</span>.iv[(i + <span class="number">1</span>) % <span class="variable language_">self</span>.n] &amp; <span class="number">0x7fffffff</span>)  </span><br><span class="line">            <span class="keyword">if</span> y % <span class="number">2</span>:  </span><br><span class="line">                y &gt;&gt;= <span class="number">1</span>  </span><br><span class="line">                y ^= <span class="variable language_">self</span>.a  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                y &gt;&gt;= <span class="number">1</span>  </span><br><span class="line">            <span class="variable language_">self</span>.iv[i] = <span class="variable language_">self</span>.iv[(i + <span class="variable language_">self</span>.m) % <span class="variable language_">self</span>.n] ^ y  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.state == <span class="number">0</span>:  <span class="comment"># 此处为效率优化，可以不进行判断，每次生成随机数都进行旋转</span></span><br><span class="line">            <span class="variable language_">self</span>.twister()  </span><br><span class="line">  </span><br><span class="line">        y = <span class="variable language_">self</span>.iv[<span class="variable language_">self</span>.state]  </span><br><span class="line">        y = y ^ (y &gt;&gt; <span class="variable language_">self</span>.u) &amp; <span class="variable language_">self</span>.d  </span><br><span class="line">        y = y ^ (y &lt;&lt; <span class="variable language_">self</span>.s) &amp; <span class="variable language_">self</span>.b  </span><br><span class="line">        y = y ^ (y &lt;&lt; <span class="variable language_">self</span>.t) &amp; <span class="variable language_">self</span>.c  </span><br><span class="line">        y = y ^ (y &gt;&gt; <span class="variable language_">self</span>.l)  </span><br><span class="line">  </span><br><span class="line">        <span class="variable language_">self</span>.state = (<span class="variable language_">self</span>.state + <span class="number">1</span>) % <span class="variable language_">self</span>.n  </span><br><span class="line">        <span class="keyword">return</span> y  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.generate()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    mt = MT19937()  </span><br><span class="line">    tank = <span class="built_in">set</span>()  </span><br><span class="line">    kLen = <span class="number">100000</span>  </span><br><span class="line">    odd = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(kLen):  </span><br><span class="line">        t = mt()  </span><br><span class="line">        odd += <span class="number">1</span> <span class="keyword">if</span> t % <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span>  </span><br><span class="line">        tank.add(t)  </span><br><span class="line">        <span class="built_in">print</span>(t)  </span><br><span class="line">    <span class="built_in">print</span>(odd / kLen)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;set: <span class="subst">&#123;<span class="built_in">len</span>(tank)&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;kLen: <span class="subst">&#123;kLen&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>64位版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937x64</span>:  </span><br><span class="line">    w, n, m, r = <span class="number">64</span>, <span class="number">312</span>, <span class="number">156</span>, <span class="number">31</span>  </span><br><span class="line">  </span><br><span class="line">    a = <span class="number">0xb5026f5aa96619e9</span>  </span><br><span class="line">    u, d = <span class="number">29</span>, <span class="number">0x5555555555555555</span>  </span><br><span class="line">    s, b = <span class="number">17</span>, <span class="number">0x71d67fffeda60000</span>  </span><br><span class="line">    t, c = <span class="number">37</span>, <span class="number">0xfff7eee000000000</span>  </span><br><span class="line">    l = <span class="number">43</span>  </span><br><span class="line">    f = <span class="number">6364136223846793005</span>  </span><br><span class="line">    upperMask = <span class="number">0xFFFFFFFF80000000</span>  </span><br><span class="line">    lowerMask = <span class="number">0x7FFFFFFF</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        seed = <span class="number">0</span>  </span><br><span class="line">        <span class="variable language_">self</span>.state = <span class="number">0</span>  </span><br><span class="line">        <span class="comment"># 初始化，生成n行w列的向量  </span></span><br><span class="line">        <span class="variable language_">self</span>.iv = [<span class="number">0</span>] * <span class="variable language_">self</span>.n  </span><br><span class="line">        <span class="variable language_">self</span>.iv[<span class="number">0</span>] = seed  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="variable language_">self</span>.n):  </span><br><span class="line">            prev = <span class="variable language_">self</span>.iv[i - <span class="number">1</span>]  </span><br><span class="line">            temp = <span class="variable language_">self</span>.f * (prev ^ (prev &gt;&gt; (<span class="variable language_">self</span>.w - <span class="number">2</span>))) + i  </span><br><span class="line">            <span class="variable language_">self</span>.iv[i] = temp &amp; <span class="number">0xffffffffffffffff</span>  <span class="comment"># 转换为int64  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twister</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="comment"># 梅森旋转  </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n):  </span><br><span class="line">            y = (<span class="variable language_">self</span>.iv[i] &amp; <span class="number">0x80000000</span>) + (<span class="variable language_">self</span>.iv[(i + <span class="number">1</span>) % <span class="variable language_">self</span>.n] &amp; <span class="number">0x7fffffff</span>)  </span><br><span class="line">            <span class="keyword">if</span> y % <span class="number">2</span>:  </span><br><span class="line">                y &gt;&gt;= <span class="number">1</span>  </span><br><span class="line">                y ^= <span class="variable language_">self</span>.a  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                y &gt;&gt;= <span class="number">1</span>  </span><br><span class="line">            <span class="variable language_">self</span>.iv[i] = <span class="variable language_">self</span>.iv[(i + <span class="variable language_">self</span>.m) % <span class="variable language_">self</span>.n] ^ y  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.state == <span class="number">0</span>:   <span class="comment"># 此处为效率优化，可以不进行判断，每次生成随机数都进行旋转</span></span><br><span class="line">            <span class="variable language_">self</span>.twister()  </span><br><span class="line">  </span><br><span class="line">        y = <span class="variable language_">self</span>.iv[<span class="variable language_">self</span>.state]  </span><br><span class="line">        y = y ^ (y &gt;&gt; <span class="variable language_">self</span>.u) &amp; <span class="variable language_">self</span>.d  </span><br><span class="line">        y = y ^ (y &lt;&lt; <span class="variable language_">self</span>.s) &amp; <span class="variable language_">self</span>.b  </span><br><span class="line">        y = y ^ (y &lt;&lt; <span class="variable language_">self</span>.t) &amp; <span class="variable language_">self</span>.c  </span><br><span class="line">        y = y ^ (y &gt;&gt; <span class="variable language_">self</span>.l)  </span><br><span class="line">  </span><br><span class="line">        <span class="variable language_">self</span>.state = (<span class="variable language_">self</span>.state + <span class="number">1</span>) % <span class="variable language_">self</span>.n  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> y  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.generate()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    mt = MT19937x64()  </span><br><span class="line">    tank = <span class="built_in">set</span>()  </span><br><span class="line">    kLen = <span class="number">100000</span>  </span><br><span class="line">    odd = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(kLen):  </span><br><span class="line">        t = mt()  </span><br><span class="line">        odd += <span class="number">1</span> <span class="keyword">if</span> t % <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span>  </span><br><span class="line">        tank.add(t)  </span><br><span class="line">        <span class="built_in">print</span>(t)  </span><br><span class="line">    <span class="built_in">print</span>(odd / kLen)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;set: <span class="subst">&#123;<span class="built_in">len</span>(tank)&#125;</span>&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;kLen: <span class="subst">&#123;kLen&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>MicroPython介绍</title>
    <url>/2023/04/25/MicroPython%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <a href="https://micropython.org/">MicroPython</a> 是为 MCU 等资源受限环境提供精简和高效的 <code>Python3</code> 实现。它包括了 <code>Python3</code> 标准库的一个子集并且针对 MCU 进行了优化。</p>
<p>&emsp;&emsp; MicroPython 提供了完全的 Python 解析器环境，用户可以在 <code>REPL</code> 中 直接执行命令，也可以导入并运行内置文件系统中的脚本。<code>REPL</code> 提供了命令行环境的通用特性，包括<code>自动补全</code>、<code>自动缩进</code>、<code>历史记录</code>和<code>复制粘贴</code>等。</p>
<span id="more"></span>

<h2 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h2><p>以 <code>ESP8266</code> 为例，参考<a href="/index.php/archives/226/">ESP8266 NodeMCU 介绍</a> 。</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>在启动时，会首先执行在内部<em>冻结模块</em>中的 <code>_boot.py</code> 脚本，该脚本会负责在<code>FlashROM</code>中挂载文件系统，如果文件系统不可用，它会进行模块的首次载入并创建文件系统。该部分的启动行为不能被用户修改（即使从源代码构建，也不要去修改它，除非你知道自己在做什么）。</p>
<blockquote>
<p>冷冻模块（frozen module）是用Python编写的模块，其编译字节代码对象由 Python 的<code>Freeze Utility</code>纳入了定制的 Python 解释器中。</p>
</blockquote>
<p>一旦文件系统被挂载，就可以找到其中的<code>boot.py</code>脚本并执行。它会负责启动<code>WebREPL</code> 后台服务（默认不启动）以及其他服务。该脚本可以被用户修改，例如用户可以修改一些参数或者增加其他后台服务。</p>
<p>未修改的 <code>boot.py</code>，类似下面的脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This file is executed on every boot (including wake-boot from deepsleep)</span></span><br><span class="line"><span class="comment">#import esp</span></span><br><span class="line"><span class="comment">#esp.osdebug(None)</span></span><br><span class="line"><span class="keyword">import</span> uos, machine</span><br><span class="line"><span class="comment">#uos.dupterm(None, 1) # disable REPL on UART(0)</span></span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> webrepl</span><br><span class="line">webrepl.start()</span><br><span class="line">gc.collect()</span><br></pre></td></tr></table></figure>

<p>最后，运行用户程序 <code>main.py</code>，如果该脚本存在于文件系统中 （并且由 boot.py 导入并执行入口函数）。</p>
<h2 id="REPL"><a href="#REPL" class="headerlink" title="REPL"></a>REPL</h2><h3 id="串口-REPL"><a href="#串口-REPL" class="headerlink" title="串口 REPL"></a>串口 REPL</h3><p>可以通过 UART0 （GPIO1-TX，GPIO0-RX）获得<code>REPL</code>，例如通过<code>USB-&gt;TTL</code>转换器连接到 UART0，并使用串口工具通信：</p>
<p><code>$ picocom /dev/ttyUSB0 -b115200</code></p>
<p>连接成功后，会得到类似下面的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MicroPython v1.20.0 on 2023-04-26; ESP module with ESP8266</span><br><span class="line">Type &quot;help()&quot; for more information.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span> </span><br></pre></td></tr></table></figure>
<h3 id="WebREPL"><a href="#WebREPL" class="headerlink" title="WebREPL"></a>WebREPL</h3><p><code>WebREPL</code> 允许用户通过连接 WiFi 后在浏览器中获得 Python 命令行。WebREPL 的客户端可以通过浏览器访问：<a href="http://micropython.org/webrepl">WebREPL Client</a>。</p>
<p>在此之前，用户需要使用 串口 REPL 启用<code>WebREPL</code>后台服务，并设置访问密码。在串口命令行中，执行下面的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> webrepl_setup</span><br></pre></td></tr></table></figure>
<p>并根据提示，进行相后续的相关配置（例如访问密码）。</p>
<p>配置完成并重新启动后，会得到下面类似的启动信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WebREPL server started on http://192.168.4.1:8266/</span><br><span class="line">Started webrepl in normal mode</span><br><span class="line"></span><br><span class="line">MicroPython v1.20.0 on 2023-04-26; ESP module with ESP8266</span><br><span class="line">Type &quot;help()&quot; for more information.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>192.168.4.1</code>是 MicroPython 启动的 AP（无线热点） 中的局部 IP 地址，因此用户需要连接 AP（MicroPython-xxxxx）后才能访问该地址。如果用户已经配置 ESP8266 连接上了一个路由器，则可以不需要再连接 MicroPython AP。</p>
<p>通过浏览器访问 WebREPL Server，会得到类型下面的界面：</p>
<p><img src="/2023/04/25/MicroPython%E4%BB%8B%E7%BB%8D/WebREPL.png"></p>
<p>输入前面配置的密码，就可以看到熟悉的命令行提示符 <code>&gt;&gt;&gt;</code>。</p>
<h3 id="连接-WiFi"><a href="#连接-WiFi" class="headerlink" title="连接 WiFi"></a>连接 WiFi</h3><p>连接 WiFi 的命令如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> network</span><br><span class="line">sta_if = network.WLAN(network.STA_IF)</span><br><span class="line">sta_if.active(<span class="literal">True</span>)</span><br><span class="line">sta_if.connect(<span class="string">&#x27;&lt;your SSID&gt;&#x27;</span>, <span class="string">&#x27;&lt;your key&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果 AP 不再使用，可以关闭它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ap_if = network.WLAN(network.AP_IF)</span><br><span class="line">ap_if.active(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>为了在启动时自动连接 WiFi，用户可以将下面的代码放到 <code>boot.py</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_connect</span>():</span><br><span class="line">    <span class="keyword">import</span> network</span><br><span class="line">    sta_if = network.WLAN(network.STA_IF)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sta_if.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;connecting to network...&#x27;</span>)</span><br><span class="line">        sta_if.active(<span class="literal">True</span>)</span><br><span class="line">        sta_if.connect(<span class="string">&#x27;&lt;ssid&gt;&#x27;</span>, <span class="string">&#x27;&lt;key&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> sta_if.isconnected():</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;network config:&#x27;</span>, sta_if.ifconfig())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>N-Body问题的数值模拟</title>
    <url>/2023/03/13/N-Body%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E5%80%BC%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <a href="https://encyclopedia.thefreedictionary.com/N-body+problem">N-Body 问题</a> 是一个非常著名的物理问题。在天文学上，它具体指对于<strong>多个</strong>可以通过引力（基于经典牛顿力学）相互作用的天体，预测其中任意一个天体的运动（即在任意时刻的位置和速度）。在化学中，则可以是预测多个相互作用的分子或原子的运动。<br>&emsp;&emsp;当 N&#x3D;2 时的<code>二体问题</code>已经完全解决；但对于 N&#x3D;3 时的<code>三体问题</code>，除了在一些特殊条件下可以得到解析解外，一般的三体问题依然没有解析解。<br>&emsp;&emsp;N-Body 问题的模拟(Solver) 是指对于一组输入初始状态（各粒子的质量、位置和速度），输出在用户指定时刻的状态。我们先关注<strong>牛顿力学下</strong>二维空间的 N-Body 问题，然后再扩展到三维空间。</p>
<span id="more"></span>

<p>&emsp;&emsp;从历史上看，第一个特殊研究的三体问题是<strong>太阳</strong>、<strong>地球</strong>和<strong>月亮</strong>间的运动。从现代意义上说，它可以指经典力学或量子力学中三个粒子运动的任何问题。</p>
<blockquote>
<p>参考 <a href="https://encyclopedia.thefreedictionary.com/N-body+problem">N-Body 问题 - wikipedia</a> 。<br>参考 《Introduction to ParallelProgramming》 by Peter Pacheco.</p>
</blockquote>
<h2 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h2><h3 id="通用公式"><a href="#通用公式" class="headerlink" title="通用公式"></a>通用公式</h3><p>假设在时刻 <code>t</code> ，行星 <strong>q</strong>  的位置为 $ s_q(t) $，行星 <strong>k</strong> 的位置为 $ s_k(t) $，则根据牛顿定律，行星 k 作用于行星 q 上的引力为：<br>$$ f_{qk}(t) &#x3D; -\frac {Gm_qm_k} { { ( s_q(t) - s_k(t) ) } ^ 3 } ( s_q(t) - s_k(t) ) $$</p>
<p>其中， <strong>G</strong> 为 万有引力常量（$ 6.673<em>10^{-11} m^3&#x2F;(kg</em>s^2) $），m 为 行星质量，<strong>s</strong> 和 <strong>f</strong> 均为带方向的<strong>向量</strong>。</p>
<p>进一步，我们可以计算所有其他行星作用于行星 q 上的引力和（向量和）：<br>$$ F_q(t) &#x3D; \sum_{k&#x3D;0,k\neq q}^{n-1}f_{qk} &#x3D; -Gm_q \sum_{k&#x3D;0,k \neq q} ^ {n-1} \frac {m_k} { { ( s_q(t) - s_k(t) ) } ^ 3 } [s_q(t) - s_k(t)] $$</p>
<p>最后，我们可以计算行星 q 在时刻 t 时的加速度：<br>$$ a_q(t) &#x3D; -G \sum_{j&#x3D;0,j \neq q}^{n-1} \frac {m_j} { { ( s_q(t) - s_j(t) ) } ^ 3 } [s_q(t) - s_j(t)] $$</p>
<p>实际上，也可以用下面的等式表示：<br>$$ a_q(t) &#x3D; {s_q}’’(t) &#x3D; \frac {F_q(t)} {m_q} $$</p>
<h3 id="数值模拟"><a href="#数值模拟" class="headerlink" title="数值模拟"></a>数值模拟</h3><p>如果要求 $ s_q(t) $，直接求解上节最后的<strong>微分公式</strong>是困难的，但是可以使用数值模拟方法来求得其近似值。我们使用最简单的<strong>欧拉方法</strong>，作为数值模拟方法。对于在定义域内连续的函数 $ g(t) $，在其曲线上有点$ (t_0, g(t_0)) $，那么当 $ t &#x3D; t_0 + \Delta{t} $时，<br>$$ y &#x3D; g(t_0) + g’(t_0)(\Delta{t}) $$</p>
<p>且当 $ \Delta{t} $足够小时：<br>$$ g(t_0 + \Delta(t)) \approx g(t_0) + g’(t_0)(\Delta{t}) $$</p>
<p>以此，我们可以模拟 $ s_q(t) $和$ v_q(t) $的值。假设，在时刻 0，行星 q 的位置和速度为 $ s_q(0) $ 和 $ v_q(0) $，那么，在时刻 $ \Delta{t} $，其位置和速度为：<br>$$ s_q(\Delta{t}) \approx s_q(0) + \Delta{t}s_q’(0) &#x3D; s_q(0) + \Delta{t}v_q(0) $$</p>
<p>$$ v_q(\Delta{t}) \approx v_q(0) + \Delta{t}v_q’(0) &#x3D; v_q(0) + \Delta{t}a_q(0) &#x3D; v_q(0) + \Delta{t}\frac{1}{m_q}F_q(0) $$</p>
<p>当我们求得$s_q(\Delta{t})$ 和 $v_q(\Delta{t})$后，我们可以使用相同的公式计算 $s_q(2\Delta{t})$ 和 $v_q(2\Delta{t})$，以此类推。</p>
<h2 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h2><h2 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h2><h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2>]]></content>
      <categories>
        <category>高性能计算</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Network Scanning Based on TCP</title>
    <url>/2024/12/16/Network-Scanning-Based-on-TCP/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>TCP 协议的很多特性可以被攻击者广泛利用，如进行网络扫描和端口嗅探。基于 TCP 的常用的端口扫描类型包括：TCP 连接扫描、TCP SYN扫描、TCP Xmas 扫描、TCP FIN 扫描、TCP Null 扫描等等。</p>
<p>我们将使用 <a href="https://pypi.org/project/scapy/">Scapy</a> 第三方库来做实际的扫描测试。Scapy 可以用来做 package 嗅探和伪造 package，并且它已经在内部实现了大量的网络协议。</p>
<span id="more"></span>

<h3 id="TCP-连接扫描"><a href="#TCP-连接扫描" class="headerlink" title="TCP 连接扫描"></a>TCP 连接扫描</h3><p>该方式尝试通过与目标主机上的待扫描 TCP 端口建立完整的 TCP 连接，根据连接的成败推断端口的工作状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line">from scapy.layers.inet import TCP, IP</span><br><span class="line"></span><br><span class="line">data = &#x27;hello, world&#x27;</span><br><span class="line"></span><br><span class="line">## 构造 package </span><br><span class="line">pkt = IP(src = &#x27;127.0.0.1&#x27;, dst = &#x27;127.0.0.1&#x27;)/TCP(sport=12345, dport=8088)/data</span><br><span class="line">resp = sr1(pkt, timeout=10)</span><br><span class="line">if str(type(resp)) == &#x27;&#x27;:</span><br><span class="line">    print(&quot;Closed&quot;)</span><br><span class="line">elif resp.haslayer(TCP):</span><br><span class="line">    if resp.getlayer(TCP).flags == 0x12:  # SYN+ACK</span><br><span class="line">        # 发送 ACK</span><br><span class="line">        sr(IP(src = &#x27;127.0.0.1&#x27;, dst = &#x27;127.0.0.1&#x27;)/TCP(sport=12345, dport=8088, flags=&quot;AR&quot;), timeout=10)</span><br><span class="line">        print(&quot;Opened&quot;)</span><br><span class="line">    elif resp.getlayer(TCP).flags == 0x14: # RST+ACK</span><br><span class="line">        print(&quot;Closed&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;Closed&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="TCP-SYN-扫描"><a href="#TCP-SYN-扫描" class="headerlink" title="TCP SYN 扫描"></a>TCP SYN 扫描</h3><p>该类型扫描是向主机上的待扫描端口发送一个 SYN 标志被设置为 1 的 TCP 报文， 此动作与 TCP 的三次握手中的第一阶段相同。如果被扫描的端口处于监听状态，它将返回 SYN+ACK，响应连接请求<br>源主机在收到响应报文后，发送 RST 标志为 1 的报文，中断与主机的连接。如果被扫描主机的端口是关闭的，则会回复 RST 为 1 的报文。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line">from scapy.layers.inet import TCP, IP</span><br><span class="line"></span><br><span class="line">pkt = IP(src = &#x27;127.0.0.1&#x27;, dst = &#x27;127.0.0.1&#x27;)/TCP(sport=12345, dport=8088, flags=&quot;S&quot;)</span><br><span class="line">resp = sr1(pkt, timeout=10)</span><br><span class="line">if str(type(resp)) == &quot;&quot;:</span><br><span class="line">    print(&quot;Filtered&quot;)</span><br><span class="line">elif resp.haslayer(TCP):</span><br><span class="line">    if resp.getlayer(TCP).flags == 0x12:  # SYN+ACK</span><br><span class="line">        # 发送 ACK</span><br><span class="line">        sr(IP(src=&#x27;127.0.0.1&#x27;, dst=&#x27;127.0.0.1&#x27;) / TCP(sport=12345, dport=8088, flags=&quot;R&quot;), timeout=10)</span><br><span class="line">        print(&quot;Opened&quot;)</span><br><span class="line">    elif resp.getlayer(TCP).flags == 0x14:  # RST + ACK</span><br><span class="line">        print(&quot;Closed&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;Filtered&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="TCP-Xmas-扫描（圣诞树扫描）"><a href="#TCP-Xmas-扫描（圣诞树扫描）" class="headerlink" title="TCP Xmas 扫描（圣诞树扫描）"></a>TCP Xmas 扫描（圣诞树扫描）</h3><p>在该扫描类型中，源主机会向目标主机发送设置 PSH、FIN、URG 标识的数据包。判断逻辑如下：</p>
<ul>
<li>如果目标主机的端口是开放的，不会有任何响应</li>
<li>如果目标主机返回了 RST 报文，那么说明端口处于关闭状态</li>
<li>如果目标主机返回一个 ICMP 数据包，其中错误类型为 3 且状态码为 1, 2, 3, 9, 10 或 13, 则说明目标端口被过滤了无法确定是否处于开放状态。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scapy.layers.inet <span class="keyword">import</span> TCP, IP, ICMP</span><br><span class="line"></span><br><span class="line">pkt = IP(src = <span class="string">&#x27;127.0.0.1&#x27;</span>, dst = <span class="string">&#x27;127.0.0.1&#x27;</span>)/TCP(sport=<span class="number">12345</span>, dport=<span class="number">8088</span>, flags=<span class="string">&quot;FPU&quot;</span>)</span><br><span class="line">resp = sr1(pkt, timeout=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">str</span>(<span class="built_in">type</span>(resp)) == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> resp <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Open|Filtered&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> resp.haslayer(TCP):</span><br><span class="line">    <span class="keyword">if</span> resp.getlayer(TCP).flags == <span class="number">0x14</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Closed&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> resp.haslayer(ICMP):</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(resp.getlayer(ICMP).<span class="built_in">type</span>) == <span class="number">3</span> <span class="keyword">and</span></span><br><span class="line">        <span class="built_in">int</span>(resp.getlayer(ICMP).code) <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">13</span>]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Filtered&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Filtered&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="TCP-ACK-扫描"><a href="#TCP-ACK-扫描" class="headerlink" title="TCP ACK 扫描"></a>TCP ACK 扫描</h3><p>ACK 扫描不是用于发现端口开启或关闭状态的，而是用于发现服务器上是否存在有状态防火墙的。它的结果只能说明端口是否被过滤。</p>
<h3 id="TCP-窗口扫描"><a href="#TCP-窗口扫描" class="headerlink" title="TCP 窗口扫描"></a>TCP 窗口扫描</h3><p>TCP 窗口扫描的流程同 ACK 扫描类似，同样是客户端向服务器发送一个带有 ACK 标识和端口号的 TCP 数据包，但是这种扫描能够用于发现目标服务器端口的状态。在 ACK 扫描中返回 RST 表明没有被过滤，但在窗口扫描中，当收到返回的 RST 数据包后，它会检查窗口大小的值。</p>
<ul>
<li>如果窗口大小的值是个非零值，则说明目标端口是开放的。</li>
<li>如果返回的 RST 数据包中的窗口大小为0，则说明目标端口是关闭的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scapy.layers.inet <span class="keyword">import</span> TCP, IP, ICMP</span><br><span class="line"></span><br><span class="line">pkt = IP(src = <span class="string">&#x27;127.0.0.1&#x27;</span>, dst = <span class="string">&#x27;127.0.0.1&#x27;</span>)/TCP(sport=<span class="number">12346</span>, dport=<span class="number">8089</span>, flags=<span class="string">&quot;A&quot;</span>)</span><br><span class="line">resp = sr1(pkt, timeout=<span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">str</span>(<span class="built_in">type</span>(resp)) == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> resp <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Response&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> resp.haslayer(TCP):</span><br><span class="line">    <span class="keyword">if</span> resp.getlayer(TCP).window == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Closed&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> resp.getlayer(TCP).window &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Opened&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> resp.haslayer(ICMP):</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(resp.getlayer(ICMP).<span class="built_in">type</span>) == <span class="number">3</span> <span class="keyword">and</span></span><br><span class="line">        <span class="built_in">int</span>(resp.getlayer(ICMP).code) <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">13</span>]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Filtered&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Filtered&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>参考 <a href="https://www.cnblogs.com/linagcheng/p/13033631.html">端口扫描之开放端口扫描方式</a></p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
  </entry>
  <entry>
    <title>OAuth 2.0 Analysis</title>
    <url>/2024/12/17/OAuth-2-0-Analysis/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>OAuth2.0</strong> 是 <a href="https://datatracker.ietf.org/doc/html/rfc6749">IETF RFC 6749 - The OAuth 2.0 Authorization Framework</a> 中规定的基于令牌的授权框架，允许客户端访问受保护的分布式资源而<br>不必要为每个输入密码。OAuth2.0 的设立是为了解决互联网上经常出现的多个账户使用相同的密码，密码只在必要的时候修改等糟糕的密钥健康状况。</p>
<span id="more"></span>

<p>IEFT ACE 工作组创建了定义 OAuth2.0 应用于物联网的工作文件。</p>
<p>OAuth2.0 是一个框架。关于 OAuth2.0 的安全最佳实践，参考 <a href="https://datatracker.ietf.org/doc/html/rfc6819">IETF RFC 6819 - OAuth 2.0 Threat Model and Security Considerations</a>。</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title>OpenGL 工具库</title>
    <url>/2023/04/18/OpenGL-%E5%B7%A5%E5%85%B7%E5%BA%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; OpenGL(OpenGL Utility Toolkit)  。<code>freeglut</code> 是 <code>GLUT</code> 的一个完全开源替代库。</p>
]]></content>
      <categories>
        <category>高性能计算</category>
      </categories>
  </entry>
  <entry>
    <title>OpenMP Tutorial</title>
    <url>/2023/03/02/OpenMP-Tutorial/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <a href="https://www.openmp.org/">OpenMP</a> 可以认为是用于<code>共享内存型并行编程</code> 的 API 接口，“MP” 是多处理（”multiprocessing”）的缩写。因此，OpenMP 被用于这样的系统：任何进程或线程都可以潜在地访问所有可用的内存资源。当我们使用 OpenMP 编程时，我们可以将系统看作 CPUs 的集合，这些 CPU 都可以访问内存。</p>
<blockquote>
<p>参考 《Introduction to ParallelProgramming》 by Peter Pacheco.</p>
</blockquote>
<span id="more"></span>

<h2 id="OpenMP-Vs-Pthreads"><a href="#OpenMP-Vs-Pthreads" class="headerlink" title="OpenMP Vs Pthreads"></a>OpenMP Vs Pthreads</h2><p>&emsp;&emsp; 尽管 <code>Pthreads</code> 也用于共享内存式的编程，但它和 OpenMP 有些不同：</p>
<ul>
<li>Pthreads 要求用户<strong>显示定义</strong>每个线程的行为；OpenMP 只用<strong>声明</strong>目标代码块需要并行，具体的行为交给编译器和运行时环境完成。</li>
<li>Pthreads 可以作为与主程序进行链接的<strong>库</strong>，使用 C 编译器编译即可；但 OpenMP 需要编译器的额外支持，因此使用不支持 OpenMP 的 C 编译器来编译 OpenMP 程序不会获得预想的并行执行行为。</li>
<li>Pthreads 更加底层，赋予用户控制线程行为细节的能力，但也给用户增加了编程负担；OpenMP 使得并行编程更加简单，但控制底层线程行为的能力较弱。</li>
</ul>
<p>&emsp;&emsp;对于大型的高性能程序，学术界和工业界的很多人都相信使用 Pthreads API 是非常困难的。OpenMP 被显式设计为一种更高层的 API，使得用户可以<strong>增量式</strong>地将串行程序并行化。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>&emsp;&emsp; OpenMP 使用 “基于声明式” 的API，在C&#x2F;C++语言中表现为使用预处理指令 <code>#pragma</code>。 #pragma 所定义的很多指示字是编译器特有的，在不同的编译器间是不可移植的。预处理期将忽略它不认识的 #pragma 指令，不同的编译器可能以不同的方式解释同一条 #pragma 指令。对于 OpenMP, 使用 <code>#pragma omp</code> 作为声明的前缀。</p>
<p><strong>一个简单的 HelloWorld 程序 omp_hello.c：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _OPENMP</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _OPENMP</span></span><br><span class="line">    <span class="type">int</span> my_rank = omp_get_thread_num();</span><br><span class="line">    <span class="type">int</span> thread_count = omp_get_num_threads();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> my_rank = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> thread_count = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d of %d\n&quot;</span>, my_rank, thread_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> thread_count = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">    hello();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>带有 <code>-fopenmp</code> 选项进行编译：</p>
<p><code>$ gcc -g -Wall -fopenmp -o omp_hello omp_hello.c</code></p>
<p>运行（指定4个线程）：<br><code>$ ./omp_hello 4</code></p>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello from thread 0 of 4</span><br><span class="line">Hello from thread 3 of 4</span><br><span class="line">Hello from thread 2 of 4</span><br><span class="line">Hello from thread 1 of 4</span><br></pre></td></tr></table></figure>

<p>由于 4 个线程竞争使用 <em>stdout</em> ，所以上述输出顺序不一定与线程的编号一致，当再次执行时，输出顺序就可能不同。</p>
<p>使用 <code>single</code> 声明可以指定代码只能被一个线程执行。</p>
<p>在上述代码中，<code>#pragma omp</code>声明中 <code>parallel</code> 指令表示紧跟的结构块（structured block）需要被多个线程执行。结构块可以是单个语句或者只有一个入口和出口组合语句（类似于编译理论中的“基本块”），即它不包括分支语句，也不是任何分支语句的目标。</p>
<p><code>num_threads</code> 被称为子句（clause），它可以修改 <code>parallel</code> 指令的默认行为。</p>
<p>上述声明所代表的底层行为到底是怎么样的呢？<br>首先当主线程（Master）运行到 <code>parallel</code> 指令时，会生成 thread_cnt-1 个从线程（Slave），然后每个线程都会执行结构块中的代码，最后当某个线程执行完成后，会等待其他线程完成。当所有线程完成后，从线程会被终结，主线程继续执行结构块之后的代码。Master线程和所有Slave线程组成一个 team 。</p>
<h2 id="一个复杂例子"><a href="#一个复杂例子" class="headerlink" title="一个复杂例子"></a>一个复杂例子</h2><p>&emsp;&emsp; 该节以计算某个函数 f 在区间 [a,b] 上的积分为例。我们使用梯形公式：<br>令 $ h &#x3D; \frac{(b-a)}{n} $ （n 代表将定义域分为等长区间的个数）：<br>$$ S &#x3D; h[\frac{f(x_0)}{2} + f(x_1) + f(x_2)+\cdots+\frac{f(x_n)}{2}] $$</p>
<p>calc 函数代表每个线程需要执行的结构块，它会根据当前线程的编号执行对应的子任务，其结果被写入 <em>group_result_ptr</em> 变量。<em>group_result_ptr</em> 变量必须进行互斥访问，可以使用 <code>#pragma omp critical</code> 来声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x* x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">calc</span> <span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">int</span> n, <span class="type">double</span> *global_result_p)</span>&#123;</span><br><span class="line">    <span class="type">double</span> h, x, my_result;</span><br><span class="line">    <span class="type">double</span> local_a, local_b;</span><br><span class="line">    <span class="type">int</span> i, local_n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> my_rank = omp_get_thread_num();</span><br><span class="line">    <span class="type">int</span> thread_count = omp_get_num_threads();</span><br><span class="line"></span><br><span class="line">    h = (b-a) / n;</span><br><span class="line">    local_n = n / thread_count;</span><br><span class="line">    local_a = a + my_rank*local_n*h;</span><br><span class="line">    local_b = local_a + local_n*h;</span><br><span class="line">    </span><br><span class="line">    my_result = (f(local_a) + f(local_b)) / <span class="number">2.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= local_n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        x = local_a  + i * h;</span><br><span class="line">        my_result += f(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_result = my_result*h;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">    *global_result_p += my_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义 <code>f(x) = x*x</code> 来作为待积分的函数，main 函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> global_result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">double</span> a, b;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> thread_count;</span><br><span class="line">    </span><br><span class="line">    thread_count = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a, b, and n: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %d&quot;</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">    calc(a, b, n, &amp;global_result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;With n = %d trapezoids, our estimate\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;of the integral from %f to %f = %.14e\n&quot;</span>,a, b, global_result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main 函数与第2节中的代码基本相同，这里<code>calc</code>函数被声明需要并行执行。</p>
<p>编译后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./trap 4</span></span><br><span class="line">Enter a, b, and n: </span><br><span class="line">3 6 100</span><br><span class="line">With n = 100 trapezoids, our estimate</span><br><span class="line">of the integral from 3.000000 to 6.000000 = 6.30004500000000e+01</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>精确值为 63，上面的输出结果是合适的，如果增加n值，会得到更精确的积分结果。</p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p><strong>还原（reduction）、还原变量及还原操作符（reduction operator）</strong><br><strong>还原子句</strong>： <code>reduction(&lt;operator&gt; : &lt;variable list&gt;)</code></p>
<p>使用 <code>private(var1,var2,...)</code> 子句可以声明某些变量位于私有域中。<br>使用 <code>shared(var1, var2,...)</code> 子句可以声明某些变量位于共享域中。</p>
<h2 id="使用parallel-for-指令"><a href="#使用parallel-for-指令" class="headerlink" title="使用parallel for 指令"></a>使用<code>parallel for</code> 指令</h2><p>&emsp;&emsp; <code>parallel for</code>指令可用于声明 for 循环为并行执行，上文的积分程序可以不使用 <code>parallel</code> 指令，而使用 <code>parallel for</code>指令，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">h = (b-a)/n;</span><br><span class="line">approx = (f(a) + f(b))/<span class="number">2.0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:approx)</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    approx += f(a+i*h);</span><br><span class="line">&#125;</span><br><span class="line">approx += h* approx;</span><br></pre></td></tr></table></figure>
<p>值的注意的是，approx 必须被声明为还原变量，+为还原运算符。另外，在使用<code>parallel</code>声明时，每个线程所要完成的子任务由线程自己分配，但使用<code>parallel for</code>声明时，任务的分配由系统决定。</p>
<p>for 循环中的 i 位于私有域中，即每个线程有一个 i 的拷贝，如果位于共享域，<code>i++</code>语句的执行 会导致数据竞争。对于被<code>parallel for</code>声明的for循环，其中的所有变量都位于共享域，但循环变量除外，例如这里的 i 。</p>
<p>可以使用<code>parallel for</code> 声明的 for 循环是有限制的，它需要满足一定的规范形式。否则的话，运行时系统如何在执行之前知道for循环的迭代次数呢？</p>
<p>另外，非常重要的两点是：</p>
<ul>
<li>对于使用 <code>parallel for</code>声明的for循环，OpenMP 编译器不会检测循环中不同迭代间的依赖关系，这些依赖必须由编程人员自己来检查。</li>
<li>所以，对于不同迭代间存在依赖的 for循环，通常不能被 OpenMP 并行化。</li>
</ul>
<p>使用 <code>default(none)</code> 子句可以强制用户为每个变量声明域，例如循环变量，在前文我们知道，循环遍历默认是私有的，但使用<code>default(none)</code>子句后，我们必须使用<code>private</code>显式声明它是私有的。</p>
<h3 id="并行化排序程序"><a href="#并行化排序程序" class="headerlink" title="并行化排序程序"></a>并行化排序程序</h3><h2 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h2><p>&emsp;&emsp;在使用<code>parallel for</code>声明 for 循环时，任务分配是由系统决定的，系统可以使用简单的块划分方法：前<code>n/thread_count</code>次迭代分配给线程0，接着的 <code>n/thread_count</code> 次迭代分配给线程1，依次类推，直到分配完所有迭代。但有时候这并不是最优的分配方案，比如当不同迭代的负载并不相同的时候。</p>
<p>OpenMP 的 <code>schedule</code>子句可以用来调度迭代，来获得性能提升。格式为：</p>
<p><code>schedule(&lt;type&gt; [, &lt;chunksize&gt;])</code></p>
<p><code>&lt;type&gt;</code>可以是下面的任意一种：</p>
<ul>
<li><code>static</code>：在循环执行前分配迭代。</li>
<li><code>dynamic</code> 或 <code>guided</code>：循环执行期间分配迭代，即一个线程完成它的任务后，还可以从运行时系统获取更多的任务。</li>
<li><code>auto</code>：由编译器或者运行时系统决定调度。</li>
<li><code>runtime</code>：由运行时系统决定调度。</li>
</ul>
<p>对于 <code>static</code> 调度，使用 <code>round-robin</code> 分配方法，如果我们有12个迭代和3个线程，<code>schedule(static, 1)</code>的分配方案如下：</p>
<ul>
<li>Thread0 ：0，3，6，9</li>
<li>Thread1 ：1，4，7，10</li>
<li>Thread2 ：2，5，8，11</li>
</ul>
<p><code>&lt;chunksize&gt;</code>默认为<code>total_iterations/thread_count</code>，在这种情况下的分配方案几乎等价于默认的分配方案（即简单的块划分）。</p>
<p>对于 <code>dynamic</code>调度，<code>&lt;chunksize&gt;</code>默认为 1 。对于 <code>guided</code>调度，当某个线程完成它的任务时，重新获得的迭代个数会递减。</p>
<p>对于 <code>runtime</code> 调度，具体的调度策略由环境变量 <code>OMP_SCHEDULE</code> 决定。</p>
<p>那么应该使用哪一种调度策略呢？</p>
<p><code>schedule</code>子句是存在开销（overhead）的，且<code>guided</code>调度的开销最大，<code>dynamic</code>次之，<code>static</code>最小。如果不使用 <code>schedule</code>子句时的程序性能是可以接受的，就不要使用它。下面是一些总结：</p>
<ul>
<li>如果每次迭代的负载基本相同，就<code>不要</code>使用<code>schedule</code>子句。</li>
<li>如果每次迭代的负载是线性递增的，使用<code>schedule(static,1)</code> 或许可以获得更好的性能。</li>
<li>如果迭代的负载不确定，可以使用不同的调度选项进行探测，这是可以使用 <code>schedule(runtime)</code>，每次探测可以对 <code>OMP_SCHEDULE</code>环境变量设定不同的值。</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>&emsp;&emsp; <code>pragma omp barrier</code> 可以在 <code>parallel</code>结构块的中间<strong>显式</strong>声明同步语义，即 team 中的任一线程必须在屏障点等待其他所有线程也到达屏障点之后才能继续执行。<strong>另外，<code>parallel</code>、<code>parallel for</code> 和 <code>for</code> 指令在结构块的结尾加入了一个隐含的屏障。对于一些 OpenMP 实现，支持使用<code>nowait</code>声明来取消这个隐式的屏障。</strong></p>
<p>&emsp;&emsp; <code>pragma omp atomic</code> 指令类似 <code>critical</code> 但拥有更好的性能。使用 <code>atomic</code>声明的临界区只能是单语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x &lt;op&gt;= &lt;expression&gt;</span><br><span class="line">x++;</span><br><span class="line">++x;</span><br><span class="line">x--;</span><br><span class="line">--x;</span><br></pre></td></tr></table></figure>
<p>另外，<code>critical(name)</code> 与 <code>critical</code>不同，它可以声明不同的临界区（以不同的 name 命名），这些临界区的代码可以并行执行。</p>
<p><strong>锁（locks）</strong>：被用于数据结构而非代码块的互斥访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">omp_init_lock</span><span class="params">(<span class="type">omp_lock_t</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">omp_set_lock</span><span class="params">(<span class="type">omp_lock_t</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">omp_unset_lock</span><span class="params">(<span class="type">omp_lock_t</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">omp_destory_lock</span><span class="params">(<span class="type">omp_lock_t</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是：</p>
<ul>
<li>对于单个临界区不应该混合使用不同类型的同步原语。</li>
<li><strong>不保证</strong>线程一定不会饥饿。</li>
<li>嵌套使用同步原语是“危险”的，有可能造成死锁。</li>
</ul>
<h2 id="Cache一致性"><a href="#Cache一致性" class="headerlink" title="Cache一致性"></a>Cache一致性</h2><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>&emsp;&emsp; 在结构块中调用外部函数时，要清楚地知道该函数是否线程安全（thread-safe），如果不是线程安全的，则该结构块不能被并行化，除非我们可以使用线程安全的函数替换它。</p>
<h2 id="其他-directive-和-clause"><a href="#其他-directive-和-clause" class="headerlink" title="其他 directive 和 clause"></a>其他 directive 和 clause</h2><h3 id="directive"><a href="#directive" class="headerlink" title="directive"></a>directive</h3><ul>
<li><code>atomic</code> : 内存位置将会原子更新（Specifies that a memory location that will be updated atomically）。</li>
<li><code>flush</code> : 所有线程对所有共享对象具有相同的内存视图（view of memory）。</li>
<li><code>master</code> : 指定由主线程来执行接下来的程式。</li>
<li><code>ordered</code>: 指定在接下来的代码块中，被并行化的 for 循环将依序执行（sequential loop）。</li>
<li><code>sections</code> : 将接下来的代码块包含将被并行执行的section块。</li>
<li><code>single</code> : 之后的程式将只会在一个线程（未必是主线程）中被执行，不会被并行执行。</li>
<li><code>threadprivate</code> : 指定一个变量是线程局部存储（thread local storage）。</li>
</ul>
<h3 id="clause"><a href="#clause" class="headerlink" title="clause"></a>clause</h3>]]></content>
      <categories>
        <category>高性能计算</category>
      </categories>
  </entry>
  <entry>
    <title>OpenPGP常用命令手册</title>
    <url>/2022/04/29/OpenPGP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;详细手册参考man page或者gnupg wiki等在线资源。</p>
<span id="more"></span>

<h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p><code>gpg --full-gen-key</code></p>
<h4 id="列出当前密钥对"><a href="#列出当前密钥对" class="headerlink" title="列出当前密钥对"></a>列出当前密钥对</h4><p><code>gpg --list-keys</code> (公钥)<br><code>gpg --list-secret-keys</code> (私钥)</p>
<h4 id="导出公钥"><a href="#导出公钥" class="headerlink" title="导出公钥"></a>导出公钥</h4><p><code>gpg --output &lt;文件名&gt; --armor --export &lt;user-id&gt;</code></p>
<h4 id="导入公钥"><a href="#导入公钥" class="headerlink" title="导入公钥"></a>导入公钥</h4><p><code>gpg --import &lt;文件名&gt;</code></p>
<h4 id="使用密钥服务器"><a href="#使用密钥服务器" class="headerlink" title="使用密钥服务器"></a>使用密钥服务器</h4><p><code>gpg --send-keys &lt;key-id&gt;</code><br><code>gpg --search-keys &lt;user-id&gt;</code><br><code>gpg --recv-keys &lt;key-id&gt;</code></p>
<p><code>gpg --auto-key-locate &lt;mechanisms&gt; --locate-external-key &lt;user-id&gt;</code> 从外部服务器获取用户公钥,user-id可以是邮箱地址。mechanisms默认是 <code>local,wkd</code>。</p>
<h4 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h4><ul>
<li>非对称加密：<br><code> gpg --recipient &lt;user-id&gt; -e &lt;明文文件&gt;</code> (加密)<br><code> gpg --output &lt;明文文件&gt; -d &lt;加密文件&gt;</code> （解密）</li>
<li>对称加密:<br><code> gpg -c &lt;明文文件&gt;</code> (加密)<br><code> gpg -o &lt;明文文件&gt; -d &lt;加密文件&gt;</code> (解密)</li>
</ul>
<h4 id="密钥维护"><a href="#密钥维护" class="headerlink" title="密钥维护"></a>密钥维护</h4><ul>
<li>备份私钥<br><code>gpg --export-secret-keys --armor &lt;user-id&gt; &lt;文件名&gt;</code></li>
<li>导入私钥<br><code>gpg --import &lt;私钥文件&gt;</code></li>
</ul>
<h4 id="编辑密钥"><a href="#编辑密钥" class="headerlink" title="编辑密钥"></a>编辑密钥</h4><p><code>gpg --edit-key &lt;user-id&gt;</code></p>
<h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p><code>gpg --output &lt;签名文件&gt; --sign &lt;原文件&gt; </code><br><code>gpg --output &lt;签名文件&gt; --clearsign &lt;原文件&gt;</code> (不压缩)<br><code>gpg --output &lt;签名文件&gt; --detach-sig &lt;原文件&gt;</code> (只有签名)<br><code>gpg --verify &lt;签名文件&gt;</code> 验证签名</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>信息安全</category>
      </categories>
  </entry>
  <entry>
    <title>OpenWRT for Raspberry Pi Model 3</title>
    <url>/2023/03/07/OpenWRT-for-Raspberry-Pi-Model-3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; 在 <a href="/2022/07/02/OpenWrt-Introduction/" title="OpenWrt Introduction">[OpenWrt Introduction]</a> 中我们对 OpenWrt 的特性、目标、架构以及构建系统做了介绍。本文将更注重实践，一步步构建 OpenWrt 使其移植到 <code>树莓派 Model 3B</code> 开发板。虽然我们可以直接下载编译好的固件，但也会失去自己动手做的乐趣。</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>&emsp;&emsp; 构建系统依赖一些软件包，这些软件包在大部分 Linux 发行版系统上已经安装。但如果一部分依赖没有安装，构建会失败，这时候需要根据错误信息发现未安装的依赖包。</p>
<p>在 Ubuntu 系统上：<br><code>$ sudo apt update</code></p>
<p><code>$ sudo apt install build-essential clang flex bison g++ gawk gcc-multilib g++-multilib gettext git libncurses5-dev libssl-dev python3-distutils rsync unzip zlib1g-dev file wget</code></p>
<h3 id="新建用户openwrt（可选）"><a href="#新建用户openwrt（可选）" class="headerlink" title="新建用户openwrt（可选）"></a>新建用户<code>openwrt</code>（可选）</h3><p>为了获得更干净的构建环境，我们可以新建一个<code>openwrt</code>用户（其他名字亦可）：</p>
<p><code>sudo groupadd openwrt</code><br><code>sudo useradd -s /bin/bash -g openwrt -m -k /dev/null openwrt</code></p>
<p>设置口令：<br><code>sudo passwd openwrt</code></p>
<p>切换用户:<br><code>cd /home/openwrt</code><br><code>su openwrt</code></p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h3><p><code>git clone https://git.openwrt.org/openwrt/openwrt.git</code></p>
<h3 id="更新并选择分支"><a href="#更新并选择分支" class="headerlink" title="更新并选择分支"></a>更新并选择分支</h3><p><code>git pull</code><br><code>git checkout &lt;XXXX&gt;</code></p>
<p>我们使用最新的 <code>22.03.3</code> 版本</p>
<h3 id="更新和安装-feeds"><a href="#更新和安装-feeds" class="headerlink" title="更新和安装 feeds"></a>更新和安装 <code>feeds</code></h3><p><code>./scripts/feeds update -a</code><br><code>./scripts/feeds install -a</code> : 安装所有获取的包的符号链接到<code>package/feeds</code></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>make menuconfig</code></p>
<p>具体配置选项:</p>
<ul>
<li><strong>Target System</strong> 选择 <code>BCM27xx</code></li>
<li><strong>Subtarget</strong> 选择 <code>BCM2710 boards (64bits)</code></li>
<li><strong>Target Profile</strong> 自动选择为 <code>Raspberry Pi 3B/3B+/3CM (64bit)</code></li>
<li><strong>Target Image</strong> 至少选择 <code>Gzip image</code><ul>
<li><strong>Kernel partition size</strong> 可以设置为 <code>256</code> M</li>
<li><strong>Root filesystem partition size</strong> 可以设置为 <code>1024</code> M（具体根据SD卡容量）</li>
</ul>
</li>
<li><strong>Kernel Modules &gt; USB Supports</strong> 可以全选</li>
<li><strong>Luci &gt; Application</strong>:<ul>
<li>luci-app-dockerman 容器</li>
<li>luci-app-frpc 内网穿透客户端</li>
<li>luci-app-ddns 动态域名解析</li>
<li>luci-app-mwan3  分流助手(多运营商网络)</li>
<li>luci-app-samba4 SMB网络共享</li>
<li>luci-app-ttyd 网页终端插件</li>
<li>luci-app-wol 网络唤醒</li>
</ul>
</li>
<li><strong>Luci -&gt; Themes</strong> : 主题，可以全选</li>
</ul>
<p>用户可以增加自己的扩展软件包或者 Luci 的扩展插件。</p>
<h3 id="下载-编译"><a href="#下载-编译" class="headerlink" title="下载&amp;编译"></a>下载&amp;编译</h3><p><code>make -j8 download V=s</code><br><code>make -j1</code></p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>开源硬件</category>
      </categories>
  </entry>
  <entry>
    <title>OpenWrt Introduction</title>
    <url>/2022/07/02/OpenWrt-Introduction/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://openwrt.org/">OpenWrt</a> 是针对嵌入式设备（特别是无线路由器）的 <code>Linux</code> 系统。<code>OpenWrt</code>使用带有包管理的完全可写的文件系统，这与静态、封闭的固件不同。<code>OpenWrt</code> 可以使用户获得更大的自由来进行个性化的配置（包括应用软件包的选择）、对系统及底层硬件资源完全的掌握。从安全的角度讲，用户可以自己检测固件是否包含安全漏洞或者后门（backdoor）程序，<code>OpenWrt</code> 的更新相对原固件更加及时，安全问题会更快地发现并解决。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://openwrt.org/docs/guide-developer/start">OpenWrt Developer Guide</a></p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>最新版本：<code>22.03.3</code></p>
<h2 id="设备支持和软件包"><a href="#设备支持和软件包" class="headerlink" title="设备支持和软件包"></a>设备支持和软件包</h2><h3 id="设备支持"><a href="#设备支持" class="headerlink" title="设备支持"></a>设备支持</h3><p><code>OpenWrt</code> 支持超过 65+ Target&#x2F;Soc，覆盖的指令集架构包括 <code>ARM</code>、<code>MIPS</code>、<code>MIPS64</code>、<code>PPC</code>、<code>X86</code> 和 <code>x86_64</code> 。</p>
<p>设备存储容量要求：</p>
<ul>
<li>最小 4M 的 Flash（不支持 GUI），8M 更好（支持 GUI）；</li>
<li>最小 32M 的 RAM，64M 更好。</li>
</ul>
<p>如果使用 18.06 或 更高的 OpenWrt 版本，上述 <code>4/32</code> 的最小要求可能无法满足，参看 <code>4/32</code>警告。</p>
<p><a href="https://openwrt.org/toh/start">ToH</a> 中列举了当前支持的设备列表，根据厂商及型号索引相关支持信息。用户可以更新该列表，加入已经过测试的新设备。</p>
<h3 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h3><p>现在最新 21.02 版本的软件包仓库: <a href="https://openwrt.org/packages/index/start">Package Index</a></p>
<p>这些软件包(1000+)可以用来扩展系统的功能，它包括一些分类：管理类（Administration）、语言类（Languages）、库（Libraries）、基础系统（Base System）、引导（BootLoader）、固件（Firmware）、网络类（Network）和 工具类（Utilties）等等。</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>OpenWrt 的整体架构和其他 Linux 发行版系统类似，基本上采用 <code>软件包+包管理器+内核</code> 的结构。</p>
<p>OpenWrt 的软件包在源代码中基本上只有一个 <code>Makefile</code> 文件，其中包含软件包上游的信息以及 OpenWrt 自己所作的修改。这与<code>ArchLinux</code>的做法类似。所有的软件包都使用 OpenWrt 自己的工具链进行编译，但工具链本身需要先通过用户(<code>Host</code>)系统上的编译工具链生成。所以 OpenWrt 的工具链实际上是交叉编译工具链。在 <a href="/2021/04/05/LFS-0-LFS-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" title="LFS 0: LFS 项目介绍">[LFS 0: LFS 项目介绍]</a> 中有更多关于交叉编译的细节。</p>
<p>OpenWrt 使用 <code>opkg</code> 包管理器。其软件仓库分为 <code>base</code> 和 <code>luci</code>、<code>packages</code>、<code>routing</code>、<code>telephony</code>。<code>base</code> 为主仓库，由核心开发人员维护；后面 4 个仓库称为 <code>package feeds</code>，它们由社区维护，每个包都有一个维护者。<code>package feed</code>系统很容易扩展，用户可以将自己的包放入官方的<code>feed</code>中或者根据自己手头特殊的固件来定制化<code>feed</code>（将包放到自己的下载服务器中）。</p>
<p>软件包的版本号：<code>上游主版本号-OpenWrt子版本号</code>，子版本号代表 OpenWrt 对该上游软件包进行了修改或者包装（与 debian 系统类似）。</p>
<p>内核本身也可以看作一个软件包，虽然它的编译相对来说更加复杂，但<code>Makefile</code>中的结构和其他软件包基本上都是相同的。</p>
<h2 id="源代码结构"><a href="#源代码结构" class="headerlink" title="源代码结构"></a>源代码结构</h2><p>OpenWrt 的源代码仓库：</p>
<ul>
<li>GitWeb - OpenWrt 的 <code>master</code> git仓库</li>
<li>GitHub - 持续更新的 GitWeb 的镜像仓库</li>
</ul>
<p>目录结构：</p>
<ul>
<li>&#x2F;config : menuconfig 的配置文件</li>
<li>&#x2F;include: 属于主仓库的软件包的<code>makefile</code>和<code>configuration</code></li>
<li>&#x2F;scripts: 构建过程中使用的脚本（Perl、Python 和 shell 等）</li>
<li>&#x2F;target: <code>Buildroot</code>构建<code>imagebuild</code>、<code>kernel</code>、<code>sdk</code>和<code>toolchain</code>的<code>makefile</code>和<code>configuration</code></li>
<li>&#x2F;toolchain: 构建交叉编译工具链的<code>makefile</code>和<code>configuration</code></li>
<li>&#x2F;tool: 构建过程中使用的工具的<code>makefile</code>和<code>configuration</code></li>
</ul>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>在第3节中说，OpenWrt 的工具链为交叉编译工具链，因为大部分目标设备的CPU 架构都与 Host 系统不同。对于用户来说，可以手动构建自己的工具链，然后构建 OpenWrt，但这种做法相对困难且很容易出错。</p>
<p>OpenWrt 的构建系统采取了不同的方法：它构建任何一部分都是从零开始、下载、打补丁和编译，包括交叉工具链也是如此。简单地说，OpenWrt 的构建系统不包含任何二进制代码或者源代码，它安全自动化的下载、针对给定的平台打补丁、针对给定的平台进行编译。另外，用户通过修改模板，进而改变这个过程中任何一步的行为。</p>
<h3 id="构建系统所工作的主要目录"><a href="#构建系统所工作的主要目录" class="headerlink" title="构建系统所工作的主要目录"></a>构建系统所工作的主要目录</h3><ul>
<li><p><strong>tools</strong>: 构建 <code>toolchain</code>、<code>packages</code>或<code>image generator</code>所使用的基本软件（例如<code>Autoconf</code>和<code>Automake</code>等）；虽然这些基本软件会有一部分已经安装在<code>Host</code>系统上，但 OpenWrt 选择编译自己的工具软件，这使得它不需要担心<code>Host</code>系统可能存在的版本不兼容问题。</p>
</li>
<li><p><strong>toolchain</strong>: 包括<code>编译器</code>、<code>链接器</code>、<code>汇编器</code>、<code>运行时库</code>和<code>通用工具</code>；构建过程中会生成两个其他目录 <code>toolchainbuild&#123;arch&#125;</code> 和 <code>stagingdir&#123;arch&#125;</code>；前者是构建<code>临时目录</code>，后者是工具链的<code>安装目录</code>。</p>
</li>
<li><p><strong>target</strong>: 包含针对特定嵌入式平台的补丁或者配置选项；例如<code>target/linux</code>子目录又根据不同的嵌入式平台进行划分，在某个嵌入式平台的目录中包含了对 Linux 内核的补丁和内核配置；类似的，<code>target/imagebuilder</code>子目录描述了如何针对特定平台打包固件。</p>
</li>
<li><p><strong>package</strong>: 打包后的软件包，后缀名为<code>ipk</code>（就像如果使用<code>debian</code>包格式，后缀名为<code>deb</code>）</p>
</li>
<li><p><strong>dl</strong>: 构建过程中下载的源代码等会放到该目录。</p>
</li>
</ul>
<p>在<code>target</code>和<code>package</code>步骤中，也会生成临时构建目录<code>build_&#123;arch&#125;</code>。</p>
<p>在主目录下会生成 <code>build_dir</code> 和 <code>staging_dir</code> 目录，<code>build_dir</code>用来解压下载后的软件包源码，然后编译它；<code>staging_dir</code>用来作为所有已编译好的程序的安装目录，它们可以用来构建其他软件包或者集成到最后的固件中。<code>build_dir</code>分为几个子目录：</p>
<ul>
<li><strong>build_dir&#x2F;host</strong>：所有将会运行在 Host系统上的工具，例如<code>sed</code>和<code>flex</code>等。</li>
<li><strong>build_dir&#x2F;hostpkg:</strong></li>
<li><strong>build_dir&#x2F;toolchain-xxxxxxx</strong> ：所有运行在<code>Host</code>系统上的交叉编译工具链、Linux内核，以及被运行在<code>Target</code>系统上的工具多需要链接的库，例如<code>musl</code>和<code>uClibc</code>（两者都是针对嵌入式设备的 C 库）等。</li>
<li><strong>build_dir&#x2F;target-xxxxxxx</strong>：运行在<code>Target</code>系统上的软件。</li>
</ul>
<p><code>staging_dir</code> 目录也分类类似的几个子目录：</p>
<ul>
<li><strong>staging_dir&#x2F;host</strong> ：一个小型的 Linux 根目录，包括运行在 Host上的工具，其中有些工具符号链接到 Host 系统上已经安装的相同工具。</li>
<li><strong>staging_dir&#x2F;hostpkg</strong>：</li>
<li><strong>staging_dir&#x2F;toolchain-xxxxxxx</strong>：一个小型的 Linux 根目录，包含运行在 Host 上的交叉编译工具链，例如 aarch64-openwrt-linux-musl-gcc。</li>
<li><strong>staging_dir&#x2F;target-xxxxxxx&#x2F;root-xxxx</strong>：一个 Linux 根目录，并且是最后生成固件的根文件系统的基础。</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>很容易移植软件。</li>
<li>使用 <code>kconfig</code> 来配置相关特性。</li>
<li>提供内置的交叉编译工具链。</li>
<li>处理标准的下载、打补丁、配置、编译和打包工作流。</li>
<li>对一些损坏的包提供一些通用的<code>fixups</code>。</li>
</ul>
<h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><p>a. tools</p>
<p>b. toolchain&#x2F;binutils - 交叉汇编器、交叉连接器等</p>
<p>c. toolchain&#x2F;gcc - 交叉编译器（我们在LFS 0: LFS 项目介绍中介绍过，gcc 的构建需要多次 Pass）</p>
<p>d. target&#x2F;linux - 内核模块</p>
<p>e. package - core(即base)仓库和feed仓库软件包</p>
<p>f. target&#x2F;linux - 内核镜像</p>
<p>g. target&#x2F;imagebuilder - 生成固件</p>
<h3 id="补丁管理"><a href="#补丁管理" class="headerlink" title="补丁管理"></a>补丁管理</h3><h3 id="Buildroot"><a href="#Buildroot" class="headerlink" title="Buildroot"></a>Buildroot</h3><h2 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h2><h3 id="所用路由器配置"><a href="#所用路由器配置" class="headerlink" title="所用路由器配置"></a>所用路由器配置</h3><p>Flash芯片： <code>cFeon QN32B-104HIP</code> 32M 容量<br>微处理器 A：<code>MediaTek MT7628DBN</code>，该处理器的相关属性如下：</p>
<ul>
<li>CPU: 32位 MIPS 24K™CPU核</li>
<li>时钟频率：580 MHZ</li>
<li>I-Cache, D-Cache : 64kb, 32kb</li>
<li>Memeory: 16bits</li>
<li>RF : 2T2R 802.11n 2.4 GHz</li>
<li>USB: 2.0</li>
<li>DRAM ： 8M</li>
</ul>
<p>微处理器 B: <code>MediaTek MT7613BEN</code>，该处理器的相关属性如下：</p>
<ul>
<li>5G WIFI 芯片</li>
<li>64M RAM</li>
</ul>
<p>MT7628 原理图：<br><img src="/2022/07/02/OpenWrt-Introduction/mt7628_arch.png"></p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>Perl简明手册</title>
    <url>/2022/04/14/Perl%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>&emsp;&emsp;Perl最强大的功能是其内置的对文本、面向行的数据格式进行模式导向的处理功能。比起shell，Perl包含更加强大的数据结构，包括混合元素类型的动态数组和支持名-值对的、查找方便快捷的散列（字典）类型。Perl还包括一个完备的、经过深思熟虑的全套Unix API的内部支持，显著减少对C的需求。另外，Perl形成了一个强大的开源社区。<br>&emsp;&emsp; Perl的最佳之处是作为强有力工具以供大量设计正则表达式匹配的小型胶合脚本使用。最糟之处是当程序很大时Perl会变得非常丑陋、刻板和几乎无法维护。 —— 《Unix编程艺术》</p>
</blockquote>
<span id="more"></span>

<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3>]]></content>
      <categories>
        <category>Perl</category>
      </categories>
  </entry>
  <entry>
    <title>Practical Internet of Thing Security Notes</title>
    <url>/2024/12/15/Practical-Internet-of-Thing-Security-Notes/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文是阅读 Brian Russell 和 Drew Van Duren 合著的《物联网安全》的笔记。该书从物联网带来的改变开始，引出物联网中存在的漏洞、面临的攻击以及可采取的对策，详细阐述物联网安全工程、密码学基础、身份识别与访问控制、隐私管理、合规监控、云安全以及物联网安全事件响应等诸多方面的内容。</p>
<span id="more"></span>

<h3 id="危险的新世界"><a href="#危险的新世界" class="headerlink" title="危险的新世界"></a>危险的新世界</h3><p>（什么是 IOT？）</p>
<blockquote>
<p>一个信息社会的全球性基础设施，基于已有的和演化的、可互操作的信息与通信技术，利用（物理和虚拟）设备互联来提供先进的服务。—— ITU</p>
</blockquote>
<blockquote>
<p>一个物联网是指这样一种网络，它将唯一标识的“实物”连接到互联网上。这里的实物具有感知&#x2F;驱动能力，以及潜在的可编程能力。通过对唯一身份标识和感知能力进行开发，<br>任意实体可以从任意时刻从任何位置收集“实物”相关信息，以及改变‘实物’的状态。 —— IETF</p>
</blockquote>
<p>（什么是物联网安全？）</p>
<p>物联网安全不是传统意义上的网络安全，而是网络安全与其他工程规范融合的产物。…… 网络安全一般不关注硬件设备的物理和安全方面，或者是设备与物理世界的交互方面的内容。</p>
<p>物理网安全的安全需求不再仅仅局限于包括可信性、完整性、不可否认性等内容的基本信息保障原则，还包括与在物理世界中生成并接收信息的物理资源和机器相关的原则。</p>
<p>跨行业合作的必要性 （信息安全工程 + 行业核心工程规范）</p>
<p><strong>信息安全是一个生态系统</strong></p>
<blockquote>
<p>物理安全：系统必须不对世界造成伤害。<br>信息安全：世界必须不对系统造成伤害。</p>
</blockquote>
<h4 id="物联网中的实体"><a href="#物联网中的实体" class="headerlink" title="物联网中的实体"></a>物联网中的实体</h4><p>ITU-T Y.2060 中的定义：</p>
<ul>
<li>设备：一个具有必需的通信能力和可选的感知、运动、数据收集、数据存储和数据处理能力的装置。</li>
<li>实体：一个物理世界（物理实体）或虚拟世界（虚拟实体）中能够被识别或者被整合到通信网络中的对象。</li>
</ul>
<p>设备的生命周期：设备的实现（OEM、ODM、BSP）, 服务的实现（CSP、OEM），设备和服务的部署。<br>硬件：MCU、主板、传感器、通信模组<br>操作系统：RTOS，TinyOS、Mantis、FreeRTOS、BrilloOS、嵌入式Linux、Ubuntu Core等。<br>物联网通信：设备-&gt;网关-&gt;控制器或网络服务</p>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>应用层：REST、AMQP、MQTT、LLAP、CoAP、SSI、DDS、XMPP 和 MQTT-SN、XMPP-IoT<br>传输层：TCP、UDP 和 TLS\DTLS<br>网络层：IPv4、IPv6 和 6LoWPAN<br>链路&#x2F;物理层：Zigbee、Bluetooth&#x2F;LE、802.15.4、802.11 WIFI、WAVE、WBAN、LTE、CDMA、GRPS、LoaWAN</p>
<h3 id="漏洞、攻击和对策"><a href="#漏洞、攻击和对策" class="headerlink" title="漏洞、攻击和对策"></a>漏洞、攻击和对策</h3><p>信息保障的传统核心概念：保密性、完整性、认证性、不可抵赖性、可用性。<br>与物联网的信息物理方面相关的安全保障需求：可快速恢复性和物理安全性。</p>
<p>威胁、漏洞和风险</p>
<p>风险可以通过威胁模型进行管理。</p>
<h4 id="攻击与对策"><a href="#攻击与对策" class="headerlink" title="攻击与对策"></a>攻击与对策</h4><p>物联网相关的最重要的攻击类型：<br>有线&#x2F;无线扫描映射攻击、协议攻击、窃听攻击、密码算法和密钥管理攻击、伪装攻击、操作系统与应用完整性攻击、拒绝服务与干扰、物理安全攻击（如改装、接口薄露等）、访问控制攻击。</p>
<h4 id="攻击树"><a href="#攻击树" class="headerlink" title="攻击树"></a>攻击树</h4><p>攻击树是一种概念图，可以用来展示一项资产或者目标可能被攻击的方式。<br>SecurITree 软件 基于能力的攻击树模型构建工具。</p>
<p>攻击目标 + 攻击操作（攻击操作之间的关系可以是‘与’关系，也可以是‘或’关系）。操作也是一个节点，也可以进行展开。</p>
<p>总的来说，攻击树可能有非常简单或者复杂的子树。一般地，子树越复杂，越需要在隔离主树的情况下对其进行分析，这个过程称为‘子树分析’。</p>
<h4 id="错误树"><a href="#错误树" class="headerlink" title="错误树"></a>错误树</h4><p>物理安全和可靠性工程原则的模型构建工具被称为错误树（也被称为故障树），它被用于错误树分析（FTA）中。</p>
<p>错误树和攻击树的区别（用户如何进入并遍历树）：</p>
<ul>
<li>错误树并不是基于精心编排的攻击行为来构建的，在错误树中，一个智能实体经过慎重考虑可以随意进入树的多个叶子节点。</li>
<li>错误树可以基于随机过程（故障&#x2F;错误发生比率），从每个叶子节点经过所依赖的中间节点进行遍历。</li>
<li>错误树的每个叶子节点完全独立（错误随机发生，且彼此相互独立）于树的所有其他叶子节点。</li>
</ul>
<h4 id="威胁建模"><a href="#威胁建模" class="headerlink" title="威胁建模"></a>威胁建模</h4><p>构建威胁模型为人们提供了一个系统的方法，来对一个系统或者系统设计进行安全评估。<br>构建威胁模型有助于加深对一个系统中的人员、入口点和资产的透彻理解。</p>
<p>流程：</p>
<ol>
<li>识别资产</li>
<li>创建对系统&#x2F;架构的纵览</li>
<li>剖析物联网系统</li>
<li>识别威胁</li>
<li>记录威胁</li>
<li>对威胁进行评级</li>
</ol>
<p>STRIDE 模型：<br>威胁类型：身份欺骗、篡改数据、否认抵赖、信息泄漏、拒绝服务、权限提升、物理安全绕过、社会工程和供应链问题。</p>
<p>威胁矩阵</p>
<h3 id="物联网开发中的安全工程"><a href="#物联网开发中的安全工程" class="headerlink" title="物联网开发中的安全工程"></a>物联网开发中的安全工程</h3><p>在设计和开发中融入安全。</p>
<p>微软 SDL：致力于解决安全需求并且引入了‘需求分类’这一概念，以此减轻开发团队在每个迭代周期内的负担。微软的技术提出了‘一次性、每次迭代、筒状安全需求’的概念。</p>
<p>一次性需求：</p>
<ul>
<li>建立在整个开发中必须遵守的编码指南。</li>
<li>为第三方组件和库建立许可软件列表。</li>
</ul>
<p>每次迭代：</p>
<ul>
<li>为了发现错误，在并入基线前对代码进行用行评审。</li>
<li>确保在持续集成（CI）环境中通过静态代码分析工具运行代码。</li>
</ul>
<h4 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h4><h3 id="物联网身份识别和访问管理解决方案"><a href="#物联网身份识别和访问管理解决方案" class="headerlink" title="物联网身份识别和访问管理解决方案"></a>物联网身份识别和访问管理解决方案</h3><p>IAM</p>
]]></content>
      <tags>
        <tag>嵌入式系统和IOT</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 元类</title>
    <url>/2022/11/20/Python-%E5%85%83%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; Python 是内置面向对象编程（OOP）的语言。在 Python 中，<strong>everything is a object</strong>，类也不例外。当把类看作对象时，类也是可以是被<code>动态创建</code>的。元类（Metaclass）就可以动态创建类对象，可以称它为“类工厂”。<code>type</code> 是 python 内置的元类，用户也可以创建自己的元类。</p>
<blockquote>
<p>本文主要翻译自 <a href="https://realpython.com/python-metaclasses/">Python Metaclass</a> by John Sturtz 。</p>
</blockquote>
<span id="more"></span>

<p>元类是非常难掌握的 OOP 概念，它隐藏在所有 Python 代码下面，甚至在你<strong>没有意识</strong>到它的存在的地方。在大多数情况下，你都<strong>不需要</strong>或者<strong>极少需要</strong>考虑它的存在。</p>
<p>自定义元类的做法是有些争议的，就像 Tim Peter 建议的那样：</p>
<blockquote>
<p>元类是比99%的用户本应该担心的更深的魔法。当你想弄清楚是否需要使用它们时，那你就不需要它们（那些实际用到它们的人都清楚地知道需要它们，而不需要解释原因）。<br>—— Tim Peters</p>
</blockquote>
<p>然后，理解 Python 元类还是值得的，因为它通常可以更好地帮助理解 Python 类的内部实现。<br>你绝不知道：可能在某一天发现使用自定义元类就是你需要的。</p>
<h2 id="新类-VS-旧类"><a href="#新类-VS-旧类" class="headerlink" title="新类 VS 旧类"></a>新类 VS 旧类</h2><p>在新类中，统一了 <code>class</code> 和 <code>type</code>的概念。如果一个 <code>obj</code> 时一个新类的实例（instance），那么<code>type(obj)</code> 和 <code>obj.__class__</code>是相同的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Foo&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(obj)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Foo&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__class__ <span class="keyword">is</span> <span class="built_in">type</span>(obj)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Type-和-Class"><a href="#Type-和-Class" class="headerlink" title="Type 和 Class"></a>Type 和 Class</h2><p>在 Python3 中，所有的类都是新类，因此，互换地引用对象的类型（object’s type）和对象的类是合理的。</p>
<p>类也是对象，那么类也有它自己的类型(type)，那么类的类型是什么呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Foo()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Foo&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Foo)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类 <code>Foo</code> 的类型是 <code>type</code>，通常情况下，所有新类的类型都是 <code>type</code>，包括用户十分熟悉的内置类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">dict</span>, <span class="built_in">list</span>, <span class="built_in">tuple</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">type</span>(t))</span><br><span class="line">...</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>type</code> 的类型是它自己：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">type</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>type</code>是元类，其他类是它的实例。</p>
<h2 id="动态定义类"><a href="#动态定义类" class="headerlink" title="动态定义类"></a>动态定义类</h2><p>内置的 <code>type()</code> 当被传递一个参数时，它返回参数对象的类型，对于新类，它通常和对象的 <code>__class__</code>属性是相同的。<br>但也可以向 <code>type()</code>传递三个参数 <code>type(&lt;name&gt;, &lt;bases&gt;, &lt;dct&gt;)</code>:</p>
<ul>
<li><code>name</code> 代表类名，另外该名字会成为类的 <code>__name__</code> 属性。</li>
<li><code>bases</code> 代表父类的元组，它会成为类的 <code>__bases__</code> 属性。</li>
<li><code>dct</code> 代表类的命名空间字典，其中包含了类体，它会作为类的 <code>__dict__</code> 属性。</li>
</ul>
<p>这样调用<code>type()</code>函数会返回<code>type</code>元类的实例，或者说它动态创建了一个新的类。</p>
<p>在下面的每个示例中都包含两个代码片段，上面的一个使用 <code>type()</code>动态创建类，下面的一个使用<code>class</code>语句定义类，这两个片段在功能上是等价的。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>在这个例子中，<code>type()</code>函数的 <code>bases</code> 和 <code>dct</code> 参数都为空：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = <span class="built_in">type</span>(<span class="string">&#x27;Foo&#x27;</span>, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&lt;__main__.Foo <span class="built_in">object</span> at <span class="number">0x04CFAD50</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&lt;__main__.Foo <span class="built_in">object</span> at <span class="number">0x0370AD50</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>在这里，<code>bases</code> 参数是一个单成员元组，该成员 <code>Foo</code> 作为所创建类的父类。另外，在命名空间中设置了属性 <code>attr</code>并初始化 100：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Bar = <span class="built_in">type</span>(<span class="string">&#x27;Bar&#x27;</span>, (Foo,), <span class="built_in">dict</span>(attr=<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.attr</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Bar&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__class__.__bases__</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Foo&#x27;</span>&gt;,)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line"><span class="meta">... </span>    attr = <span class="number">100</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.attr</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Bar&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__class__.__bases__</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Foo&#x27;</span>&gt;,)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = <span class="built_in">type</span>(</span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>    (),</span><br><span class="line"><span class="meta">... </span>    &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">&#x27;attr&#x27;</span>: <span class="number">100</span>,</span><br><span class="line"><span class="meta">... </span>        <span class="string">&#x27;attr_val&#x27;</span>: <span class="keyword">lambda</span> x : x.attr</span><br><span class="line"><span class="meta">... </span>    &#125;</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.attr</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.attr_val()</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line"><span class="meta">... </span>    attr = <span class="number">100</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">attr_val</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="variable language_">self</span>.attr</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.attr</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.attr_val()</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h3><h2 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h2><p>考虑下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br></pre></td></tr></table></figure>
<p>当解释器解析 <code>Foo()</code> 时，将会发生下面的动作：</p>
<ul>
<li><code>Foo</code>的父类的 <code>__call__</code> 方法会被调用。在这里 <code>Foo</code> 的父类是 <code>type</code>，因此<code>type</code>的 <code>__call__</code>方法被调用。</li>
<li><code>__call__()</code>方法依次调用下面的方法：<ul>
<li><strong>new</strong>()</li>
<li><strong>init</strong>()</li>
</ul>
</li>
</ul>
<p>如果<code>Foo</code>没有定义 <code>__new__()</code> 和 <code>__init__()</code>，其祖先的默认方法会被调用。<code>Foo</code> 可以通过定义这些函数来自定义自己实例化的行为。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">cls</span>):</span><br><span class="line"><span class="meta">... </span>    x = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"><span class="meta">... </span>    x.attr = <span class="number">100</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__new__ = new</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.attr</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.attr</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，每次实例化 <code>Foo</code>类时，都会默认初始化一个 <code>attr</code> 属性为100。（通常，这种代码都出现在 <code>__init__</code>方法中而不是<code>__new__</code>中。这个例子仅仅作为一个 demo。）</p>
<p>如果你想要同样自定义类（例如 Foo）的创建行为，可以自定义 Foo 的类型的 <code>__new__</code>方法。但直接重新对 <code>type</code> 的 <code>__new__()</code> 方法进行赋值是不允许的。</p>
<p>一种方案是自定义元类，该元类继承自 <code>type</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Meta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, dct</span>):</span><br><span class="line"><span class="meta">... </span>        x = <span class="built_in">super</span>().__new__(cls, name, bases, dct)</span><br><span class="line"><span class="meta">... </span>        x.attr = <span class="number">100</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> x</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在 <code>Meta</code> 也是元类，接下来完成另外一半：定义一个新类 <code>Foo</code> 并指定它的元类上面自定义的 <code>Meta</code>，而不是标准的 <code>type</code>。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Foo</span>(metaclass=Meta):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.attr</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，任何采取上面同样定义的类都默认包含属性 <code>attr</code>。一个类函数可以作为创建对象的模板，一个元类函数则可以作为创建类的模板。元类也可以被称为 <strong>类工厂</strong>。</p>
<h2 id="是否真的必要？"><a href="#是否真的必要？" class="headerlink" title="是否真的必要？"></a>是否真的必要？</h2><p>实际上，第4节中的实现可以采用其他方案，例如类继承和类修饰符。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常情况下，创建自定义元类都是不必要的。如果对于当前问题存在更简单的解决方式，那么很可能就应该使用这种方式。但理解元类仍然是有利于你去理解python的类机制，并可以判断什么时候元类可以作为一个真正合适的工具来使用。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python 装饰器</title>
    <url>/2022/10/23/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; 在 <a href="https://stonetough.com/index.php/archives/73/">Python3某些强大的特性与Lisp的关系</a> 一文中提到 Python 装饰器提供了一种定义<strong>高阶函数</strong>的语法。从定义上说，装饰器是一个以另一个函数为参数的函数，它将隐式地扩展或修改这个函数的行为。</p>
<blockquote>
<p>主要翻译自：<a href="https://realpython.com/primer-on-python-decorators/">Primer on Python Decorators</a> by <em>Geir Arne Hjelle</em>。</p>
</blockquote>
<span id="more"></span>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>注意</strong>： Python 尽管不是纯粹的函数式编程语言（如与 Lisp 相比），但仍然支持许多函数式编程的概念，包括函数作为第一级状态对象（first-class objects）。（这与 python 的 <code>everything is a object</code> 也是保持一致的。）</p>
<p>###1.1 First-Class Objects<br>函数作为第一级对象意味着 <strong>函数可以被作为参数传递</strong>，就如其他对象（如 <code>string</code>，<code>float</code>, <code>list</code>等）一样。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">be_awesome</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Yo <span class="subst">&#123;name&#125;</span>, together we are the awesomest!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet_bob</span>(<span class="params">greeter_func</span>):</span><br><span class="line">    <span class="keyword">return</span> greeter_func(<span class="string">&quot;Bob&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>say_hello()</code> 和 <code>be_awesome</code> 是普通的函数，而<code>greet_bob()</code> 函数将一个函数作为它的参数，例如我们可以将 <code>say_hello</code> 的引用传递给它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; greet_bob(say_hello)</span></span><br><span class="line">&#x27;Hello Bob&#x27;</span><br></pre></td></tr></table></figure>
<p>在 Python 中，<strong>函数的参数都是引用</strong>（具体实现可参考 <a href="https://stonetough.com/index.php/archives/244/">Python Internals</a>），<code>say_hello</code> 作为<code>greet_bob</code>的参数时不会被执行，它只会在 <code>greet_bob</code> 的函数体中被执行。</p>
<h3 id="Inner-函数"><a href="#Inner-函数" class="headerlink" title="Inner 函数"></a>Inner 函数</h3><p><code>Inner函数</code>是定义在函数中的函数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parent</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printing from the parent() function&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">first_child</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Printing from the first_child() function&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">second_child</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Printing from the second_child() function&quot;</span>)</span><br><span class="line"></span><br><span class="line">    second_child()</span><br><span class="line">    first_child()</span><br></pre></td></tr></table></figure>

<p><code>first_child()</code> 和 <code>second_child()</code> 作为 <code>parent()</code> 的内部函数，它们存在于<code>parent()</code>函数的内部域中，也就是说，如果在<code>parent()</code>外调用它们则会失败：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &#x27;first_child&#x27; is not defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>函数可以作为返回值，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">first_child</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hi, I am Emma&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">second_child</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Call me Liam&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> first_child</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> second_child</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>parent()</code> 函数返回的是<code>first_child()</code>和<code>second_child()</code>函数的引用，如果要调用它们，需要加’()’，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; first = parent(1)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; second = parent(2)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; first</span></span><br><span class="line">&lt;function parent.&lt;locals&gt;.first_child at 0x7f599f1e2e18&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; second</span></span><br><span class="line">&lt;function parent.&lt;locals&gt;.second_child at 0x7f599dad5268&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; first()</span></span><br><span class="line">&#x27;Hi, I am Emma&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; second()</span></span><br><span class="line">&#x27;Call me Liam&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="简单的装饰器"><a href="#简单的装饰器" class="headerlink" title="简单的装饰器"></a>简单的装饰器</h2><p>先看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening before the function is called.&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening after the function is called.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_whee</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Whee!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_whee = my_decorator(say_whee)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; say_whee()</span></span><br><span class="line">Something is happening before the function is called.</span><br><span class="line">Whee!</span><br><span class="line">Something is happening after the function is called.</span><br></pre></td></tr></table></figure>

<p><code>say_whee()</code> 函数的引用作为 <code>my_decorator()</code> 参数传入，<code>my_decorator()</code>函数返回其内部函数 <code>wrapper()</code> 的引用，并赋值给 <code>say_whee</code>。因此，在全局环境中，<code>say_whee</code>标识符不再绑定为 <code>say_whee()</code> 函数，而是绑定为 <code>wrapper()</code>函数。然而，<code>wrapper()</code> 函数在它的上下文环境中保存了原来的 <code>say_whee()</code> 函数的引用。（在这里，过程和数据的概念不再是完全对立的，过程可以是数据，数据也可以是过程。）</p>
<p>简单来说，<strong>装饰器包装了一个函数，修改了它的行为。</strong></p>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>上述装饰 <code>say_whee()</code> 函数的做法是有些繁琐的，所以在 Python 中允许使用 <code>@</code>符号来简单地使用装饰器，下面的例子做了同样的事情，但更加简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening before the function is called.&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening after the function is called.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_whee</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Whee!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="重用装饰器"><a href="#重用装饰器" class="headerlink" title="重用装饰器"></a>重用装饰器</h3><p>装饰器函数可以单独定义在一个模块中，其他模块可以通过 <code>import</code> 导入它。</p>
<h3 id="带有参数的装饰器"><a href="#带有参数的装饰器" class="headerlink" title="带有参数的装饰器"></a>带有参数的装饰器</h3><p>在内部包装函数中使用 ** *args ** 和 ** *kwargs **作为形参，使得它可以接受任意的位置参数和关键字参数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper_do_twice</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_whee</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Whee!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; say_whee()</span></span><br><span class="line">Whee!</span><br><span class="line">Whee!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; greet(<span class="string">&quot;World&quot;</span>)</span></span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="从装饰器函数中返回值"><a href="#从装饰器函数中返回值" class="headerlink" title="从装饰器函数中返回值"></a>从装饰器函数中返回值</h3><p>如果被装饰的函数有返回值，我们只需要在包装函数中返回这个返回值即可。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper_do_twice</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_greeting</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Creating greeting&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hi <span class="subst">&#123;name&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; return_greeting(<span class="string">&quot;Adam&quot;</span>)</span></span><br><span class="line">Creating greeting</span><br><span class="line">Creating greeting</span><br><span class="line">&#x27;Hi Adam&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="使用-functools-wraps"><a href="#使用-functools-wraps" class="headerlink" title="使用 @functools.wraps()"></a>使用 @functools.wraps()</h3><h2 id="更有用的例子"><a href="#更有用的例子" class="headerlink" title="更有用的例子"></a>更有用的例子</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python3异步编程与Twisted框架介绍</title>
    <url>/2021/03/18/Python3%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%8ETwisted%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h3 id="异步编程模型"><a href="#异步编程模型" class="headerlink" title="异步编程模型"></a>异步编程模型</h3><p>在早期的计算机那里，我们可以看到只有单一的工作流（workflow），因此它也只能解决某类问题，当某个任务存在多个工作流时或者说它可以分解成多个工作流时，这种单一的方法就不能有效地解决问题了。当我们仔细观察现实世界的任务时，特别是大型任务时，就会发现它从来都不是完全顺序执行的，总有任务的某些部分是并行的，这是一种树状的工作流。发掘和利用并行性是提高任务执行效率的非常重要的手段，而计算机对现实世界的抽象也就无法回避现实世界存在的这样的基本问题。</p>
<span id="more"></span>


<p>计算机发展过程中引入了ECF（Exceptional Control Flow）机制，这种机制反映的是一种通用的思想，因此它存在于现代计算机内部的各个层次，比如：硬件层的中断信号、操作系统层的软中断信号、进程间信号通信和进程间切换等。C++&#x2F;Java&#x2F;Python 这些现代编程语言中tay&#x2F;exception&#x2F;catch机制也是同样思想的一种表现。ECF机制使得我们可以对现实世界更好的抽象与模拟，它反映了在计算机中引入我们对时间、空间、通信和事件的理解。</p>
<p>异步模型同样也是基于同样的思想，发掘和利用程序的并行性，特别是I&#x2F;O类程序（I&#x2F;O bound program）。参考krondo的 <a href="https://krondo.com/in-which-we-begin-at-the-beginning/">Twisted Introduction Part1</a> ,那里对该主题有更详细具体的描述。</p>
<h3 id="Select-和-Poll"><a href="#Select-和-Poll" class="headerlink" title="Select 和 Poll"></a>Select 和 Poll</h3><p>在 <code>Unix/Linux</code> 传统的<code>非阻塞 IO</code>编程中，<code>select()</code>、<code>poll()</code> 和 <code>epoll()</code> 函数是最重要的系统调用。但三个函数的性能是不一样的，<a href="https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf">Comparing and Evaluating epoll, select, and poll Event Mechanisms</a> 文档对比了三者的性能。一般来说，当涉及的 <code>fd</code> 数量较少的时候，使用 <code>select</code> 是合适的；如果涉及的<code>fd</code>很多，如高性能网络服务器中，适合使用 <code>epoll</code> 。</p>
<p><code>非阻塞 IO</code> 不完全等于<code>异步 IO</code>。如果要使用<code>异步 IO</code>，<code>Unix/Linux</code>可以使用<code>基于信号的异步通知</code>机制。</p>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>Linux 的 <code>AIO</code> 是一种异常 IO 机制，有多种实现方式。其中一种实现是在用户空间的 <code>glibc</code> 库中实现的，它本质上是借用了多线程模型，用开启新的线程以同步的方法来做 I&#x2F;O，新的 <code>AIO</code> 辅助线程以 <code>pthread_cond_signal()</code> 的形式进行线程间的同步。</p>
<p><code>Linux AIO</code> 也可以由内核空间实现，相比而言，要比 <code>glibc</code> 实现的方案有更好的性能。在用户空间，一般要结合 <code>libaio</code> 进行内核 <code>AIO</code> 的系统调用。</p>
<p>选择正确的 <code>I/O</code> 模型对系统性能的影响很大，关于该问题可以参阅著名的 <a href="http://www.kegel.com/c10k.html">C10K 问题</a>，它特指服务器同时支持成千上万客户端的问题。</p>
<h3 id="Asyncio"><a href="#Asyncio" class="headerlink" title="Asyncio"></a>Asyncio</h3><p>python asyncio库是一种在单线程、单进程下的异步模型，它的用户可以显示控制（context switching）程序的工作流，特别是当有多个任务协作进行时。这种特性是指它可以停止程序某部分的执行（往往是该部分因等待I&#x2F;O事件而阻塞），但保存其调用时的状态信息，然后在未来需要的时候重新进入这个状态，在这之前，主程序可以切换到其他任务。而在多线程与多进程的模型下，任务的切换由操作系统控制，用户无法对何时切换、切换的顺序等作出预测，另外线程或者进程间的通信和同步也是不小的编程负担。</p>
<p>在使用asyncio库以前，要首先理解什么是事件循环（event loop），循环是我们将时间引入计算机后必然的产物。在现实世界中，我们看待对象的方式都是和时间有关的，在不同的时间有不同的状态，在计算机中，要表现对象的状态随时间的变化，就必须引入状态变量以及对状态变量的访问和修改机制。在一个并发的程序系统中，不同部分都有着自己的状态，而且它们之间会相互影响，通过事件循环的方式我们可以将逻辑上的并行工作流映射到对现实世界抽象的单一的时间流中。</p>
<p>任何一个asyncio程序都必须要生成一个event loop对象，每一个任务由coroutine对象表示。我们将coroutine对象想象‘挂在’（hook）或者说注册到（register）event loop上，如果某个coroutine 阻塞了，event loop就会跳过它执行其他任务，但event loop会监控它的状态，等到它从阻塞中唤醒时就从阻塞的地方重新执行它。</p>
<p>coroutine之间可以形成链状结构，即某一个coroutine的数据依赖于另一个coroutine，这种结构可以使用await关键字实现。call_soon、call_at和call_later API可以在特定的时间执行某个callback函数，Future对象可以用来异步获取任务的执行结果，其本身可以注册一些回调函数，这些 回调函数会在Future对象的结果设置后被调用。在Twisted框架中，它也是有着非常重要的作用。关于event loop清晰详细的描述，krondo的文章<a href="https://wiki.jikexueyuan.com/project/twisted-intro/">Twisted Introduction</a> 可以作为很好的参考。</p>
<p>asyncio虽然是单线程的应用，但它仍然是并发的程序，它同样要面对并发的同步问题。asyncio可以使用类似与线程和进程的同步原语（Synchronization Primitives），比如锁（Lock）、事件（Event）、条件变量（Condition）和安全队列（safed queueu）。</p>
<h3 id="Twisted-框架"><a href="#Twisted-框架" class="headerlink" title="Twisted 框架"></a>Twisted 框架</h3><p>Twisted是事件驱动的网络框架，其实现了反映堆模式（reactor），并支持多种协议和服务。总结来说，Twisted是将程序构建在reactor驱动的一系列异步回调链上，所以可以认为reactor是最顶层的代码，而用户的代码却是最底层，这与同步程序正好相反。Twisted中异步函数通常会返回一个Deferred对象，它类似于python的coroutine与generator。一个Deferred对象代表了一个‘异步的结果’或者说‘结果还没有到来’，异步函数会负责（通过启动一系列事件）当结果到来时相应地激活（那些事件来激活Deferred）Deferred中的callback链或者errback链。和具体可参考<a href="https://krondo.com/in-which-we-begin-at-the-beginning/">Twisted Introduction</a>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python3某些强大的特性与Lisp的关系</title>
    <url>/2021/02/17/Python3%E6%9F%90%E4%BA%9B%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8ELisp%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;python作为解释性语言，拥有许多优秀和强大的特性，理解这些特性的本质和来源对我们学习这门语言有着很大的帮助。<br>&emsp;&emsp;python吸收了历史上以及现存的许多语言的特性，比如结构化（structured）、<br>面向对象（OOP）、函数式编程（functional programming）、动态类型（dynamically typed）以及垃圾收集（garbage-collected）等。其中包括对Lisp语言函数式编程的传统，python提供map、filter、和reduce等函数；提供列表解析（list comprehensions）、字典（dictionaries）、集合（set）和生成器（generator）表达式等；同时在标准库中提供functools和itertools模块，这两个模块的特性来源于函数式编程语言Haskell和Standard ML。<br>&emsp;&emsp;这些特性不仅赋予了语言强大的抽象能力，而且反映了一些关于计算科学的本质问题。</p>
<span id="more"></span>

<h3 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h3><p>&emsp;&emsp;在数学中，closure一般是指域的封闭性，比如整数域在加法运算下是封闭的。在数系发展的历史上，先出现的是非零自然数域，即1,2,3,4,…，负数是不存在也是不可理解和忽视的，这种情况下，我们说非零自然数域在减法上是不封闭的。后来一方面人们逐渐在生活中不自觉的使用负数，比如某个人的欠款，另一方面则来自数学本身内在的发展要求，促使人们扩展数系，引入零和负数。数学的内在动力就是呼吁这种内在逻辑的自洽性，而不关心现实世界是否可以找到对应的概念。后来数系逐渐扩展到整数域、有理数域、实数域以及复数域，数学的抽象能力逐渐增强。<br>&emsp;&emsp;在计算机编程语言领域，closure有两种含义：一种是和数学中类似，即一个数据结构中可以包含它自身的嵌套结构，一个运算的结果可以作为它自己操作的参数；另外一种是指在lambda表达式中实现自由变量（free variables）的技术。<br>&emsp;&emsp;python的基本数据结构和类型，如list，tuple，set, dict, str都支持闭包，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">&gt;&gt; a_tuple = (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&gt;&gt; a_dict = [<span class="string">&#x27;a&#x27;</span>:<span class="number">123</span>, <span class="string">&#x27;b&#x27;</span>:[<span class="string">&#x27;c&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<p>另外在这种数据结构上的运算也满足闭包，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; added_list = a_list + a_list</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在Lisp中，只有一种组合数据的胶水（glue），即序对（pair）。由序对构造的数据对象称为表结构（list-structured）数据。这种结构当然也是满足闭包特性的，例如：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">=&gt; (<span class="name"><span class="built_in">define</span></span> a (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">=&gt; (<span class="name"><span class="built_in">define</span></span> b (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">list</span></span> <span class="number">4</span> <span class="number">5</span>) <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">=&gt; (<span class="name"><span class="built_in">define</span></span> c (<span class="name"><span class="built_in">list</span></span> a b))</span><br><span class="line">=&gt; c</span><br><span class="line">(( <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)(<span class="name">1</span> (<span class="name">4</span> <span class="number">5</span>) <span class="number">2</span> <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>Lisp中所有的表达式也都可以看作表结构数据。list数据结构也是一种序对，或者说是序对的链，其中链的结尾使用约定的标记’()。例如：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">=&gt; (<span class="name"><span class="built_in">define</span></span> a (<span class="name"><span class="built_in">list</span></span> <span class="number">1</span> <span class="number">2</span> (<span class="name"><span class="built_in">list</span></span> <span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>))</span><br><span class="line">=&gt; (<span class="name"><span class="built_in">define</span></span> b (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">3</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">4</span> &#x27;())) (<span class="name"><span class="built_in">cons</span></span> <span class="number">5</span> &#x27;())))))</span><br><span class="line">=&gt; (<span class="name"><span class="built_in">equal?</span></span> a b)</span><br><span class="line">#t <span class="comment">;; a 与 b的值是相等的</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么到目前为止，这种闭包特性带给了我们什么重要的东西呢？我们可以看到，在Lisp中，我们所知道的更为复杂的数据结构，例如链表、栈、队列、树、堆等都可以使用通用的pair来构造，闭包特性赋予了pair表达层次性数据的能力。另外，这种特性非常适合递归算法，例如对树的几乎所有遍历、查找、替换和映射的操作，都可以使用递归算法简单而优雅的解决。Lisp拥有非常简单的语法，或者说程序员几乎不需要考虑语法的问题，从而获得了在语义上的强大抽象能力。<br>&emsp;&emsp;在python中，也可以基于通用的tuple或者list来构造复杂的数据结构，但python的做法则尽量是使用标准库来解决，在那里可以专心解决性能和效率的问题。这是一种小而强大、简单而强大的理念，python具有很强的可扩展性，且避免过早优化，其语言核心尽量保持小、整洁和简单，然后将大量功能放入标准库中，这种做法鼓励了模块化的设计。</p>
<h3 id="装饰器（decorator）"><a href="#装饰器（decorator）" class="headerlink" title="装饰器（decorator）"></a>装饰器（decorator）</h3><p>&emsp;&emsp;关于这个主题，可以参考链接 <a href="https://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html">Python3 Decorators</a>。装饰器的特性类似于宏（macro），基于该特性使得python可以获得动态获取、修改函数（functions）内部状态的强大能力。<br>&emsp;&emsp;在Lisp中，函数具有第一级状态（first-class functions）,即函数本身可以作为返回值，可以作为函数的参数，可以用变量命名，可以包含在数据结构中。我们也可以说，函数本身满足闭包性质。首先我们以<a href="https://www.mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html#%25_sec_1.3.4">SICP Exercise 1.41</a>来表现这种特性:</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">double</span> f) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">f</span> (<span class="name">f</span> x))))</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">inc</span> x) (<span class="name"><span class="built_in">+</span></span> x <span class="number">1</span>))</span><br><span class="line">(((<span class="name">double</span> (<span class="name">double</span> double)) inc) <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>过程double以过程f作为参数,并返回一个过程（以lambda表达式的形式），该过程将f执行两次。所以，最后一行表达式的值是21，f被执行了16次。python中可以使用装饰器实现类似的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_double</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(f(x))</span><br><span class="line">    <span class="keyword">return</span> my_double</span><br><span class="line"></span><br><span class="line"><span class="meta">@double</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inc</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Lisp中的这种特性可以非常方便地建立更一般的抽象，比如说高阶函数，它可以增加代码的重用性以及程序的模块化。而python的装饰器特性主要还是获得开始时所说得那种动态修改函数性质的能力，它不需要修改原来函数的代码却可以获得额外的功能，使得程序更加清晰和简洁，比如，定义property等。当然它也可以用来进行定义高阶抽象，比如表格化或者记忆化（Memoized），这种方法可以大大提高某些算法（动态规划、树形递归等）的效率，它针对一类问题而不是某个特定的问题。在 <a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Memoize">PythonDecoratorLibrary Memorized</a> 例子中使用Memoized装饰器可以在不改动原有算法代码的基础上提高算法的效率。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>&emsp;&emsp;在Lisp中过程与数据可以相互转换，过程本身也可以成为对象。python中可以将函数本身看成对象，不同的变量可以引用（reference）同一个函数对象，一个函数也就可以作为另一个函数的参数。我们以map为例来表现这种特性的威力，假设我们要将一列数加倍，我们可以写下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">a_list</span>):</span><br><span class="line">    <span class="keyword">return</span> [i * <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> a_list]</span><br></pre></td></tr></table></figure>
<p>那么如果需要将一列字母全部变为大写，我们可以写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">capitalize</span>(<span class="params">char_list</span>):</span><br><span class="line">    <span class="keyword">return</span> [a.upper() <span class="keyword">for</span> a <span class="keyword">in</span> char_list]</span><br></pre></td></tr></table></figure>
<p>我们还可以给出大量这样的例子，那么这些例子中是否包含共同的、一般性的概念呢？是否可以用一种统一的方式解决一类的问题呢？如果我们抽象的看待这类问题，将对list中数据的操作函数作为参数由用户定义，就是说map是一种对list数据的映射，这种映射本身由用户自己定义。我们的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map</span>(<span class="params">f, a_list</span>):</span><br><span class="line">    <span class="keyword">return</span> [f(i) <span class="keyword">for</span> i <span class="keyword">in</span> a_list]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">capitalize</span>(<span class="params">char_list</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="built_in">str</span>.upper, char_list)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">a_list</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x*<span class="number">2</span>, a_list)</span><br></pre></td></tr></table></figure>
<p>capitalize和double函数都可以基于map来定义，我们说map有更高的抽象能力。<br>&emsp;&emsp;python中的map、filter、sorted和reduce函数都是基于上诉的思想，这种高阶函数的使用使得程序简单、清晰和模块化，更重要的是它们可以协作组合完成更加复杂的功能。</p>
<h3 id="函数式编程模块"><a href="#函数式编程模块" class="headerlink" title="函数式编程模块"></a>函数式编程模块</h3><p>&emsp;&emsp;functools库中主要的工具是partial类，它可以使用默认参数来包装（wrap）一个可调用的对象（callable object）,结果对象可以看作原来的那个对象。这里的可调用对象既可以是单独的函数（standalone function）也可以是类（class）。在某些场景，对象会作为某些方法的参数，但该对象不能带有自己的默认参数，而partial通过wrap原有的对象和其默认参数获得一个新的对象，该对象可以作为无参对象传入其他方法。<br>total_ordering装饰器可以自动增加类的比较方法（ rich comparison methods）。<br>&emsp;&emsp;itertools库中的函数可以实现惰性求值（lazy evaluation），数据只有等到它被需要的时候才会产生，这样可以更有效率的使用存储资源，而且可以用来表达更加复杂的算法。<br>其中itertools.map和python内置的map函数有些不同，前者返回的是iterator，对输入数据的操作还没有进行，它只在需要的时候产生数据；而后者返回的就是映射后的最终数据。<br>&emsp;&emsp;operator提供函数式的运算操作符。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python描述器介绍</title>
    <url>/2022/11/27/Python%E6%8F%8F%E8%BF%B0%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; Python 描述器(Descriptor) 是一个具有”绑定行为”的对象属性，它的访问控制（读、写和删除）可以由描述器协议(Descriptor Protocol)重写。一个实现 <code>__set__</code>、<code>__get__</code>和<code>__del__</code>方法中的任意一个的对象就称为描述符。</p>
<blockquote>
<p>主要翻译自 <a href="https://realpython.com/python-descriptors/">Python Descriptors: An Introduction</a> by Davide Mastromatteo.</p>
</blockquote>
<span id="more"></span>

<h2 id="描述器定义"><a href="#描述器定义" class="headerlink" title="描述器定义"></a>描述器定义</h2><p>&emsp;&emsp;描述器是一个实现描述器协议中方法的 Python 对象，描述器协议定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__get__(<span class="variable language_">self</span>, obj, <span class="built_in">type</span>=<span class="literal">None</span>) -&gt; <span class="built_in">object</span></span><br><span class="line">__set__(<span class="variable language_">self</span>, obj, value) -&gt; <span class="literal">None</span></span><br><span class="line">__delete__(<span class="variable language_">self</span>, obj) -&gt; <span class="literal">None</span></span><br><span class="line">__set_name__(<span class="variable language_">self</span>, owner, name)</span><br></pre></td></tr></table></figure>
<p>如果描述器仅仅实现了 <code>__get__()</code> 方法，则称它为非数据描述器(non-data descriptor)；如果它实现了 <code>__set__()</code> 或 <code>__del__()</code> 方法，则称它为数据描述器(data-decriptor)；两者不仅在名字上，在行为上也有差别，数据描述器在属性遍历中有更高的优先级。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># descriptors.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Verbose_attribute</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, <span class="built_in">type</span>=<span class="literal">None</span></span>) -&gt; <span class="built_in">object</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;accessing the attribute to get the value&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, obj, value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;accessing the attribute to set the value&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Cannot change the value&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>():</span><br><span class="line">    attribute1 = Verbose_attribute()</span><br><span class="line"></span><br><span class="line">my_foo_object = Foo()</span><br><span class="line">x = my_foo_object.attribute1</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>上述例子中，Verbose_attribute 实现了描述器协议，并被示例化为 Foo 的属性，因此它可以被认为是一个描述器。</p>
<p>作为描述器，当它被访问时（使用符号 <code>.</code>）会做出自己的绑定行为(binding behavior)。在上面的例子中，当 Verbose_attribute 描述器被访问时，它就会向终端打印日志信息。</p>
<p>运行上面的例子，将会得到下面的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python descriptors.py</span></span><br><span class="line">accessing the attribute to get the value</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<h2 id="内部工作细节"><a href="#内部工作细节" class="headerlink" title="内部工作细节"></a>内部工作细节</h2><p>熟悉 Python 面向对象的用户会认为上面的例子完全可以使用 <code>properties</code> 来达到同样的效果。尽管这是对的，但实际上，<code>properties</code> 在 python 中就是描述器。</p>
<h3 id="Property-中的描述器"><a href="#Property-中的描述器" class="headerlink" title="Property 中的描述器"></a>Property 中的描述器</h3><p>对于第2节的例子，如果不想显式地使用描述器，直接使用 <code>property</code> 也可以达到同样的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># property_decorator.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>():</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attribute1</span>(<span class="params">self</span>) -&gt; <span class="built_in">object</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;accessing the attribute to get the value&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @attribute1.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attribute1</span>(<span class="params">self, value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;accessing the attribute to set the value&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Cannot change the value&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_foo_object = Foo()</span><br><span class="line">x = my_foo_object.attribute1</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子使用了修饰符(<code>decorators</code>)来定义 property，但 decorators 是一种语法糖。实际上，它可以被重写成下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># property_function.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getter</span>(<span class="params">self</span>) -&gt; <span class="built_in">object</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;accessing the attribute to get the value&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setter</span>(<span class="params">self, value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;accessing the attribute to set the value&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Cannot change the value&quot;</span>)</span><br><span class="line"></span><br><span class="line">    attribute1 = <span class="built_in">property</span>(getter, setter)</span><br><span class="line"></span><br><span class="line">my_foo_object = Foo()</span><br><span class="line">x = my_foo_object.attribute1</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>property()</code> 返回一个实现了描述器协议的 <code>property</code> 对象，它使用参数 fget、fset 和 fdel 作为描述器协议中三个方法的具体实现。</p>
<h3 id="方法和函数中的描述器"><a href="#方法和函数中的描述器" class="headerlink" title="方法和函数中的描述器"></a>方法和函数中的描述器</h3><p><code>Function</code> 类、<code>ClassMethod</code>类和<code>StaticMethod</code>类实际上都实现了 <code>__get__()</code> 方法，因此可以认为它们是非数据描述器。其中<code>ClassMethod</code>描述器的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassMethod</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;Emulate PyClassMethod_Type() in Objects/funcobject.c&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, f</span>):</span><br><span class="line">        <span class="variable language_">self</span>.f = f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, klass=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> klass <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            klass = <span class="built_in">type</span>(obj)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">newfunc</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.f(klass, *args)</span><br><span class="line">        <span class="keyword">return</span> newfunc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当一个对象调用类方法(method)时，<code>obj.method(*args)</code> 就会被转换为 <code>method(type(obj), *args)</code></p>
<p>对于静态方法，则更简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticMethod</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;Emulate PyStaticMethod_Type() in Objects/funcobject.c&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, f</span>):</span><br><span class="line">        <span class="variable language_">self</span>.f = f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, objtype=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当一个对象调用静态方法时，<code>obj.method(*args)</code> 会被转换为 <code>method(*args)</code> 。</p>
<h2 id="如何使用查找链进行属性访问"><a href="#如何使用查找链进行属性访问" class="headerlink" title="如何使用查找链进行属性访问?"></a>如何使用查找链进行属性访问?</h2><p>在 Python 中，任何对象都有一个内值的 <code>__dict__</code> 属性，它是一个包含了在该对象中定义的所有属性的字典。<br>对象所属的类(Class)也是一个对象，因此它也有 <code>__dict__</code> 属性，它包含了该类的属性和方法。</p>
<p>当我们在 Python 中访问一个属性时，在底层到底发生了什么呢？解释器是如何直到你想要什么呢？这些问题可以通过查找链（Lookup chain）的概念来回答：</p>
<ul>
<li>首先，如果你要查找的属性是一个数据描述器，该描述器的 <code>__get__</code>方法会被调用，其返回结果作为属性的值。</li>
<li>如果失败，则会在对象的<code>__dict__</code> 中查找，该属性作为查找时使用的 key。</li>
<li>如果失败，如果你要查找的属性是一个非数据描述器，该描述器的 <code>__get__</code>方法会被调用，其返回结果作为属性的值。</li>
<li>如果失败，则会在对象所属类的<code>__dict__</code> 中查找，该属性作为查找时使用的 key。</li>
<li>如果失败，则会在对象所属类的父类的<code>__dict__</code> 中查找，该属性作为查找时使用的 key。</li>
<li>如果失败，重复上一步，直到遍历所有父类。</li>
<li>如果都失败了，则返回 <code>AttributeError</code> 异常。</li>
</ul>
<h2 id="如何正确地使用-Python-描述器"><a href="#如何正确地使用-Python-描述器" class="headerlink" title="如何正确地使用 Python 描述器?"></a>如何正确地使用 Python 描述器?</h2><p>仅仅需要实现<strong>描述符协议</strong>，其中最重要的是 <code>__get__</code> 和 <code>__set__</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__get__(<span class="variable language_">self</span>, obj, <span class="built_in">type</span>=<span class="literal">None</span>) -&gt; <span class="built_in">object</span></span><br><span class="line">__set__(<span class="variable language_">self</span>, obj, value) -&gt; <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，一定要注意：</p>
<ul>
<li><strong>self</strong> 代表描述符实例。</li>
<li><strong>obj</strong> 代表描述符所属的对象的实例。</li>
<li><strong>type</strong> 代表描述符所属对象的类型。</li>
</ul>
<p>在 <code>__set__()</code> 中，不需要 <code>type</code> 变量，因为只有对象才能调用 <code>__set__()</code>，而<code>__get__()</code>可以被对象或类调用。</p>
<p>另外，描述器只会被实例化一次，即每一个类的所有实例共享该类中描述器的实例。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># descriptors2.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OneDigitNumericValue</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, <span class="built_in">type</span>=<span class="literal">None</span></span>) -&gt; <span class="built_in">object</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, obj, value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">9</span> <span class="keyword">or</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">int</span>(value) != value:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;The value is invalid&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>():</span><br><span class="line">    number = OneDigitNumericValue()</span><br><span class="line"></span><br><span class="line">my_foo_object = Foo()</span><br><span class="line">my_second_foo_object = Foo()</span><br><span class="line"></span><br><span class="line">my_foo_object.number = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(my_foo_object.number)</span><br><span class="line"><span class="built_in">print</span>(my_second_foo_object.number)</span><br><span class="line"></span><br><span class="line">my_third_foo_object = Foo()</span><br><span class="line"><span class="built_in">print</span>(my_third_foo_object.number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上例的运行结果是所有 <code>Foo</code> 的实例的 <code>number</code> 属性有着相同的值。number描述器实际上仅仅是一个类属性（class-level attribute）。</p>
<p>如何解决这个问题呢？如果在描述器 <code>OneDigitNumericValue</code>中为所有 Foo 的对象建立字典，保存其 <code>value</code> 值，可以吗？这样做会造成对 Foo 对象的强引用（<strong>strong reference</strong>），影响 gc 释放 Foo 对象所占的内存。</p>
<p>正确的做法应该是将 <em>value</em> 存贮在 Foo 对象的 <code>__dict__</code> 属性中，因为每个对象都有自己单独的 <code>__dict__</code> 属性。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># descriptors4.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OneDigitNumericValue</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_name__</span>(<span class="params">self, owner, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, <span class="built_in">type</span>=<span class="literal">None</span></span>) -&gt; <span class="built_in">object</span>:</span><br><span class="line">        <span class="keyword">return</span> obj.__dict__.get(<span class="variable language_">self</span>.name) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, obj, value</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        obj.__dict__[<span class="variable language_">self</span>.name] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>():</span><br><span class="line">    number = OneDigitNumericValue()</span><br><span class="line"></span><br><span class="line">my_foo_object = Foo()</span><br><span class="line">my_second_foo_object = Foo()</span><br><span class="line"></span><br><span class="line">my_foo_object.number = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(my_foo_object.number)</span><br><span class="line"><span class="built_in">print</span>(my_second_foo_object.number)</span><br><span class="line"></span><br><span class="line">my_third_foo_object = Foo()</span><br><span class="line"><span class="built_in">print</span>(my_third_foo_object.number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <code>__set_name__()</code> 方法在描述符实例化时会被默认调用，并且 <code>name</code> 参数会被默认设置。</p>
<h2 id="为什么使用-Python-描述器？"><a href="#为什么使用-Python-描述器？" class="headerlink" title="为什么使用 Python 描述器？"></a>为什么使用 Python 描述器？</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>RISC-V 架构介绍</title>
    <url>/2023/09/05/RISC-V-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
  </entry>
  <entry>
    <title>RaspberryPi5 And AI Hailo8L Tutorial</title>
    <url>/2024/11/12/RaspberryPi5-And-AI-Hailo8L-Tutorial/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="">Raspberry Pi 5</a> 树莓派 <a href="https://www.raspberrypi.com/documentation/computers/ai.html">AI 套件</a>将树莓派 M.2 HAT+ 与 Hailo AI 加速模块捆绑在一起，用于树莓派 5。</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="温度传感器"><a href="#温度传感器" class="headerlink" title="温度传感器"></a>温度传感器</h3><p>获取当前温度：<br><code>$ vcgencmd measure_temp</code></p>
<p>可以使用 stress 命令来手动增加 CPU 负载，观察 CPU 温度变化。<br><code>$ stress --cpu 4</code></p>
<p>Raspberry 的 Active Cooler 主动冷却器由固件主动控制：在 60°C 时，鼓风机风扇将打开，在 67.5°C 时风扇速度将增加，最后在 75°C 时风扇增加到全速。<br>当温度回落到这些限制以下时，鼓风机的风扇将自动停止旋转。</p>
<h3 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h3><p>在 RaspberryPi OS Lite 系统中使用第三方摄像头需要更改启动配置。首先更改 config.txt:<br>a. 关闭摄像头自动检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># camera_auto_detect = 1</span><br><span class="line">camera_auto_detect = 0</span><br></pre></td></tr></table></figure>

<p>b. 设置 dtoverlay 为所使用的摄像头型号（以 imx219 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dtoverlay=imx219</span><br></pre></td></tr></table></figure>

<p>c. 测试<br><code>$ rpicam-hello</code></p>
<p>d. 使用 VLC 搭建实时视频流服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt-get install vlc</span></span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure>

<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>安装 raspberry pi OS 时会提示进行网络配置，最后配置信息会写入：<br><code>/etc/NetworkManager/system-connections/preconfigured.nmconnection</code> </p>
<p>配置路由优先级（使用 <code>NetworkManager</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">sudo</span> nmcli d modify wlan0 ipv4.route-metric 100</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">sudo</span> nmcli d modify eth0 ipv4.route-metric 800</span></span><br></pre></td></tr></table></figure>

<p>硬件相关，使用 <code>ethtool</code> 工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sduo ethtool eth0  <span class="comment"># 查看网卡的信息</span></span> </span><br></pre></td></tr></table></figure>

<h4 id="网络测速"><a href="#网络测速" class="headerlink" title="网络测速"></a>网络测速</h4><blockquote>
<p>参考 <a href="https://ncosbit.net/posts/2024-07-11-net-testing/">Raspberry Pi5 网卡测试</a></p>
</blockquote>
<h3 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h3><p>a. 使用 <code>raspi-config</code> 使能 <code>VNC</code>，打开 VNC 服务器。<br>b. 在客户机安装 <code>tigervnc-viewer</code> VNC 客户端。</p>
<h2 id="AI-测试"><a href="#AI-测试" class="headerlink" title="AI 测试"></a>AI 测试</h2><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p><img src="/2024/11/12/RaspberryPi5-And-AI-Hailo8L-Tutorial/aihal_plus.png"></p>
<p>a. 连接 Raspberry 5 开发板、摄像头以及 <a href="https://www.raspberrypi.com/documentation/accessories/ai-hat-plus.html#ai-hat-plus-installation">AI HAT+</a>。注意在连接前，检查固件版本是否最最新的：<code>$ sudo rpi-eeprom-update</code>。</p>
<p>b. 为了更好地利用 NPU 的性能，建议使能<a href="https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#pcie-gen-3-0">PCIe Gen 3.0</a></p>
<p>c. 安装 <code>hailo</code> AI 软件套件：<code>$ sudo apt-get install hailo-all</code>，这些软件包括：</p>
<ul>
<li>Hailo 内核设备驱动和固件</li>
<li>HailoRT 中间层软件</li>
<li>Hailo Tappas 后处理核心库</li>
<li>demo 包</li>
</ul>
<p>（注意，如果下载速度过慢，可以更换国内的 debian 镜像源）</p>
<p>d. 重启</p>
<p>e. 确认软硬件环境一切 OK：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hailortcli fw-control identify</span></span><br><span class="line">Executing on device: 0000:01:00.0</span><br><span class="line">Identifying board</span><br><span class="line">Control Protocol Version: 2</span><br><span class="line">Firmware Version: 4.20.0 (release,app,extended context switch buffer)</span><br><span class="line">Logger Version: 0</span><br><span class="line">Board Name: Hailo-8</span><br><span class="line">Device Architecture: HAILO8L</span><br><span class="line">Serial Number: &lt;N/A&gt;</span><br><span class="line">Part Number: &lt;N/A&gt;</span><br><span class="line">Product Name: &lt;N/A&gt;</span><br></pre></td></tr></table></figure>

<p>后面三个编号为 <code>&lt;N/A&gt;</code> 对 <strong>AI HAT+</strong> 设备来说是正常的，不影响实际的功能。</p>
<p>如果得到下面的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CHECK failed - Driver version (4.18.0) is different from library version (4.20.0)</span><br></pre></td></tr></table></figure>
<p>则需要更新系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt full-upgrade</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install hailo-all</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">reboot</span></span><br></pre></td></tr></table></figure>

<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><code>rpicam-apps</code> 软件套件实现了一个<strong>后处理框架（post-processing framework）</strong>。</p>
<p><code>$ sudo apt update &amp;&amp; sudo apt install rpicam-apps</code></p>
<h4 id="对象检测（Object-Detection）"><a href="#对象检测（Object-Detection）" class="headerlink" title="对象检测（Object Detection）"></a>对象检测（Object Detection）</h4><p>该 demo 使用神经网络识别特定对象，并使用方框进行标记。下面以 <a href="https://zhuanlan.zhihu.com/p/598566644">YOLOv6 模型</a> 为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpicam-hello -t 0 --post-process-file /usr/share/rpi-camera-assets/hailo_yolov6_inference.json</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/11/12/RaspberryPi5-And-AI-Hailo8L-Tutorial/hailo_yolov6_inference.png"></p>
<p>使用 <code>YOLOv8</code> 模型后实物检测和实例分割更准确：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpicam-hello -t 0 --post-process-file /usr/share/rpi-camera-assets/hailo_yolov8_inference.json</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/11/12/RaspberryPi5-And-AI-Hailo8L-Tutorial/hailo_yolov8_inference.png"></p>
<p>还可以使用 <code>YOLOX</code> 模型、 使用<code>YOLOv5</code>模型进行人脸识别：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpicam-hello -t 0 --post-process-file /usr/share/rpi-camera-assets/hailo_yolov5_personface.json</span></span><br></pre></td></tr></table></figure>

<h4 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h4><p>使用 <code>YOLov5</code> 模型进行图像分割：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpicam-hello -t 0 --post-process-file /usr/share/rpi-camera-assets/hailo_yolov5_segmentation.json --framerate 20</span></span><br></pre></td></tr></table></figure>

<p>如果输出未找到 <code>/usr/share/hailo-models/yolov5seg.json</code>，可以在 <a href="https://github.com/hailo-ai/tappas/blob/master/apps/h8/gstreamer/general/instance_segmentation/resources/configs/yolov5seg.json">tappas-github</a> 中另行下载。</p>
<h4 id="姿态估计"><a href="#姿态估计" class="headerlink" title="姿态估计"></a>姿态估计</h4><p>下面的 demo 进行了 17 个点的人体姿态模拟：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpicam-hello -t 0 --post-process-file /usr/share/rpi-camera-assets/hailo_yolov8_pose.json</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/11/12/RaspberryPi5-And-AI-Hailo8L-Tutorial/hailo_yolov8_pose.png"></p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2>]]></content>
      <categories>
        <category>开源硬件</category>
        <category>人工智能</category>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>Raspberrypi 3移植总结</title>
    <url>/2020/06/25/Raspberrypi-3%E7%A7%BB%E6%A4%8D%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="github树莓派官方源码"><a href="#github树莓派官方源码" class="headerlink" title="github树莓派官方源码"></a>github树莓派官方源码</h3><p><a href="https://github.com/raspberrypi/firmware">https://github.com/raspberrypi/firmware</a><br>可使用aarch64-gnu-linux交叉编译器编译</p>
<span id="more"></span>


<h3 id="bamarni在rpi3上移植Debian-9-arm64版本"><a href="#bamarni在rpi3上移植Debian-9-arm64版本" class="headerlink" title="bamarni在rpi3上移植Debian 9 arm64版本"></a>bamarni在rpi3上移植Debian 9 arm64版本</h3><p><a href="https://github.com/bamarni/pi64">https://github.com/bamarni/pi64</a><br>源码非常有参考价值</p>
<h3 id="个人移植Ubuntu-17-10-arm64版本"><a href="#个人移植Ubuntu-17-10-arm64版本" class="headerlink" title="个人移植Ubuntu 17.10 arm64版本"></a>个人移植Ubuntu 17.10 arm64版本</h3><p>大体上可参考bamarni的项目源码进行<br>后续开启VC4 3D加速，只需要在&#x2F;boot&#x2F;config.txt文件中设置有关设备树的参数即可<br>有关树莓派配置的相关细节可参考<br><a href="https://www.raspberrypi.org/documentation/configuration/">https://www.raspberrypi.org/documentation/configuration/</a></p>
<h3 id="配置无线wifi热点"><a href="#配置无线wifi热点" class="headerlink" title="配置无线wifi热点"></a>配置无线wifi热点</h3><p>Phil Martin的个人博客 <a href="https://frillip.com/using-your-raspberry-pi-3-as-a-wifi-access-point-with-hostapd/">https://frillip.com/using-your-raspberry-pi-3-as-a-wifi-access-point-with-hostapd/</a></p>
<h3 id="打开或者关闭图形界面"><a href="#打开或者关闭图形界面" class="headerlink" title="打开或者关闭图形界面"></a>打开或者关闭图形界面</h3><p>打开图像界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl isolate graphical.target</span></span><br></pre></td></tr></table></figure>

<p>关闭图形界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl isolate multi-user.target</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开源硬件</category>
      </categories>
  </entry>
  <entry>
    <title>S32K芯片CPU核性能优化方法总结</title>
    <url>/2025/02/25/S32K%E8%8A%AF%E7%89%87CPU%E6%A0%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MCU 是随着大规模集成电路的出现及其发展，将 CPU 核、存储器、定时器以及各种输入输出模块（外设）通过总线互联并集成到一起的微型计算机。MCU 的性能也随着半导体工业的发展越来越强大，其应用场景也越来越广泛。对于开发者来说，在一些特殊应用场景中需要最大程度地发挥 MCU 中 CPU 核的性能，这就需要开发者对所用 MCU 的架构、总线及各模块特性等有深入的了解。本文以 NXP 的 S32K1XX&#x2F;S32K3XX 系列 MCU为例， 并参考一些资料对此进行了总结。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI4MzExNzgwNw==&mid=2650117254&idx=3&sn=49a012cb4d0dc0092565173d2de03d10&chksm=f38ea506c4f92c106f5a62418cb70cad082b4e08bbc589b57dee17439108e634c673b1f04599&mpshare=1&scene=23&srcid=#">汽车电子expert成长之路-微信公众号</a></p>
</blockquote>
<h2 id="架构和存储器映射"><a href="#架构和存储器映射" class="headerlink" title="架构和存储器映射"></a>架构和存储器映射</h2><p>S32K1xx（以S32K14x为例）的架构：<br><img src="/2025/02/25/S32K%E8%8A%AF%E7%89%87CPU%E6%A0%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/s32k14x_block.png"></p>
<p>S32K3xx（以S32K312为例）的架构：<br><img src="/2025/02/25/S32K%E8%8A%AF%E7%89%87CPU%E6%A0%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/s32k312_block.png"></p>
<p>S32K 系列内核的存储器映射，可以概括如下：<br><img src="/2025/02/25/S32K%E8%8A%AF%E7%89%87CPU%E6%A0%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/s32k_memory_map.png"></p>
<p>图中的 <code>PPB</code> 又可以分为<code>内部 PPB</code>和外部 <code>PPB</code>，前者主要用来访问 <code>ITM/DWT/PFB/MPU/NVIC</code>，后者主要用来访问 <code>ETM/CTI</code>。</p>
<h2 id="时钟频率"><a href="#时钟频率" class="headerlink" title="时钟频率"></a>时钟频率</h2><p>S32K1XX MCU 使用 ARM 的 <code>Cortex M0+</code> （如 S32K118 和 S32K116）和 <code>Cortex M4F</code> （如 S32K14X）核，主频率可以达到最高 48MHZ 和 112MHZ （HSRUN）模式。S32K3 MCU使用 ARM 的 <code>Cortex M7</code> 核（哈佛架构 + 6级超标量流水线 + 分支预测），主频可以达到 120MHZ-240 MHZ。</p>
<p>但仅仅通过调整 <code>PLL</code> 或者 <code>FLL</code> 产生 CPU 核和内部总线的最高时钟频率就能获得最高性能吗？如果对于计算密集型且不需要考虑 cache 的应用，大概是正确的；但对于大部分应用来说，这样做是不够的。很多应用的性能受到存储、cache、浮点计算、IO等的极大影响，另外我们还要考虑编译器优化、程序链接等软件层面的影响。综合考虑各种软硬方面，开发者才能最大程度地发挥 CPU 核的最大性能。</p>
<h2 id="指令和数据-Cache"><a href="#指令和数据-Cache" class="headerlink" title="指令和数据 Cache"></a>指令和数据 Cache</h2><p>从前面的 S32K14x MCU 结构图中我们可以看到 Code Bus 上有 4KB 的指令和数据 Cache，注意这里的 Cache 不在 Cortex M4核的内部，但即使如此，Cache 的使用仍然可以很好地改善 Flash&#x2F;SRAM 密集型应用的性能。S32K14x 的 cache 需要在 MCU 启动时打开，具体为配置 <code>LMEM-&gt;PCCCR</code> 寄存器来使能。</p>
<p>S32K3XX MCU 使用 ARM Cortex-M7 核，该核内也包含了 L1&#x2F;L2 指令和数据 cache。核内的 cahe 与 D-Cache&#x2F;I-Cache 的配置可以通过 <code>SCTLR</code> 寄存器来完成。</p>
<h2 id="TCM"><a href="#TCM" class="headerlink" title="TCM"></a>TCM</h2><p>从前面 S32K3 系列的架构图中我们可以看到，核对 <code>TCM</code> 的访问不通过 <code>Cache</code>。那么 TCM 和 Cache 的区别在那里呢？</p>
<p>我们可以从设计目的和使用方式方面来区分，TCM 是专门设计用于处理器内部的高速存储器，包括<code>I-TCM</code>代码区和<code>D-TCM</code>数据区，可以存放<strong>最常用的代码和数据</strong>，用于提高系统的性能。Cache 用于存储最近访问的数据，来减少对外部存储器的访问次数，并提高系统性能；但 Cache 依赖于<code>局部性原理</code>，如果软件设计不是 <code>Cache 友好</code>的，那么就会频繁地发生 Cache 命中失败而访问外部存储器，性能提升受到打折。</p>
<p>另一个区别是，TCM 是处理器内部的存储器，Cache 需要外部存储器的支持，且需要使用特殊的硬件逻辑来管理缓存。</p>
<h2 id="Flash-的工作频率"><a href="#Flash-的工作频率" class="headerlink" title="Flash 的工作频率"></a>Flash 的工作频率</h2><h2 id="Flash-的指令和数据预取"><a href="#Flash-的指令和数据预取" class="headerlink" title="Flash 的指令和数据预取"></a>Flash 的指令和数据预取</h2><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><h2 id="内存段的布局"><a href="#内存段的布局" class="headerlink" title="内存段的布局"></a>内存段的布局</h2><h2 id="使用硬件-FPU"><a href="#使用硬件-FPU" class="headerlink" title="使用硬件 FPU"></a>使用硬件 FPU</h2><p>由于目前主流的 ARM 芯片都自带<code>VFP</code>或者<code>NEON</code>等浮点处理单元（FPU），所以对<code>硬浮点</code>的需求就更加强烈。Linux 的浮点处理可以采用<code>完全软浮点</code>，也可以采用与软浮点兼容，但是使用 FPU 硬件的<code>softfp</code>，以及完全硬浮点。具体的<code>ABI</code>（Application Binary Interface，应<br>用程序二进制接口）通过<code>-mfloat-abi=</code> 参数指定，3 种情况下的参数分别是<code>-mfloat-abi=soft/softfp/hard</code>。</p>
<p><code>softfp</code> 使用了硬件的 FPU，但是函数的参数仍然使用整型寄存器来传递，<code>hard</code> 完全硬浮点则直接使用 FPU 的寄存器传递参数。</p>
<p>在启用 FPU 的前提下，编译器在做激进的优化时，会使用浮点寄存器来进行整型数据的拷贝等操作，具体的话，会使用 <code>vstr.64</code> 和 <code>vldr.64</code> 浮点指令。</p>
<h2 id="多核性能（核间通信）"><a href="#多核性能（核间通信）" class="headerlink" title="多核性能（核间通信）"></a>多核性能（核间通信）</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>SSH 安全登录配置</title>
    <url>/2024/02/24/SSH%E5%AE%89%E5%85%A8%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OpenSSH 远程登陆应尽可能避免使用 <strong>口令+密码</strong> 的认证方式，而尽量使用非对称公钥证书进行认证。</p>
<blockquote>
<p><a href="https://blog.csdn.net/tang_jian_dong/article/details/124771246">Centos8 ssh 禁用密码登录， 使用证书登录</a></p>
</blockquote>
<span id="more"></span>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title>SSL Protocol Analysis</title>
    <url>/2024/12/16/SSL-Protocol-Analysis/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>信息安全</category>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title>Shell脚本常用过滤器命令</title>
    <url>/2022/04/16/Shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;过滤器是Unix&#x2F;Linux下多道程序设计风格的重要部分，它和管道机制一起可以发挥巨大的作用。相比使用通用语言来完成同样的工作，过滤器&#x2F;管道设计更加简洁清晰，更加敏捷和健壮。另外，在不同种类的shell中，有些命令的部分功能可能不同。</p>
<span id="more"></span>

<h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><p>语法：</p>
<h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><ul>
<li><code>-v</code> ：反转模式匹配</li>
</ul>
<h3 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h3><h3 id="head和tail命令"><a href="#head和tail命令" class="headerlink" title="head和tail命令"></a>head和tail命令</h3><h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h3><h3 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tr [-cdst][--help][--version][第一字符集][第二字符集]</span><br><span class="line">tr [OPTION]…SET1[SET2]</span><br></pre></td></tr></table></figure>

<p>例子：<br><code>$ echo sasdas |tr a-z A-Z</code>  # 大小写转换</p>
<h3 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h3><p>&emsp;&emsp;<strong>语法：</strong> <code>cut [-bcdfsz] FILE</code></p>
<p>参考：<br><a href="https://www.runoob.com/linux/">Linux教程-菜鸟</a></p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>SmartCar 项目</title>
    <url>/2021/04/20/SmartCar-%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文章是整理基于<code>TM4C123G</code>开发板的智能小车的项目笔记，它会包括整个项目的开发流程及相关技术知识等，但它没有任何工程学上的目标，只是一种学习或者说一种动手设计的乐趣。</p>
<span id="more"></span>

<h2 id="功能目标"><a href="#功能目标" class="headerlink" title="功能目标"></a>功能目标</h2><p>首先我们定义我们初步要达到的功能目标：</p>
<ul>
<li>支持自动左右转向，当遇到障碍物时可以转向或者倒</li>
<li>支持加速和减速，自动模式或者手动模式</li>
<li>支持红外线遥控，可以手动遥控左右转向、倒退&#x2F;前进以及加减速</li>
</ul>
<p>高级功能：</p>
<ul>
<li>增加WIFI模块，可以通过远程控制</li>
<li>增加摄像头模块，可以进行视频采集和监控</li>
</ul>
<h2 id="使用的硬件模组"><a href="#使用的硬件模组" class="headerlink" title="使用的硬件模组"></a>使用的硬件模组</h2><h3 id="TM4C123G-微控制器开发版"><a href="#TM4C123G-微控制器开发版" class="headerlink" title="TM4C123G 微控制器开发版"></a>TM4C123G 微控制器开发版</h3><p><img src="/2021/04/20/SmartCar-%E9%A1%B9%E7%9B%AE/ek-tm4c123gxl-top.png"></p>
<h3 id="红外对管距离传感器-3个"><a href="#红外对管距离传感器-3个" class="headerlink" title="红外对管距离传感器 3个"></a>红外对管距离传感器 3个</h3><p>分别位于车体的前部、左部和右部</p>
<h3 id="红外线接收器和遥控器"><a href="#红外线接收器和遥控器" class="headerlink" title="红外线接收器和遥控器"></a>红外线接收器和遥控器</h3><h3 id="L298N电机驱动模块"><a href="#L298N电机驱动模块" class="headerlink" title="L298N电机驱动模块"></a>L298N电机驱动模块</h3><p>L298N电机驱动</p>
<h3 id="摄像头和WIFI模组"><a href="#摄像头和WIFI模组" class="headerlink" title="摄像头和WIFI模组"></a>摄像头和WIFI模组</h3><h3 id="L298N电机驱动"><a href="#L298N电机驱动" class="headerlink" title="L298N电机驱动"></a>L298N电机驱动</h3><p>L298N电机驱动</p>
<h3 id="带有前后直流电机的模型小车"><a href="#带有前后直流电机的模型小车" class="headerlink" title="带有前后直流电机的模型小车"></a>带有前后直流电机的模型小车</h3><p>前部电机控制方向，后部电机负责前进和倒退</p>
<p>初步功能实现后：<br>L298N电机驱动</p>
<h2 id="软件平台"><a href="#软件平台" class="headerlink" title="软件平台"></a>软件平台</h2><p>  使用 <code>Keil uVersion IDE</code>.</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><h3 id="main函数主结构"><a href="#main函数主结构" class="headerlink" title="main函数主结构"></a>main函数主结构</h3><p>首先我们实现程序的主结构，它包含如下步骤：</p>
<h4 id="激活grader和设置系统时钟"><a href="#激活grader和设置系统时钟" class="headerlink" title="激活grader和设置系统时钟"></a>激活grader和设置系统时钟</h4><p>设置系统时钟的方法是配置<code>PLL</code>，<code>TM4C123G</code>使用<code>16M</code>的主振荡器，具体配置<code>PLL</code>的方法在上一章中已经介绍。我们这里只需要直接调用接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TexaS_INIT(SW_PIN_PE210, LED_PIN_PB543210);</span><br></pre></td></tr></table></figure>

<p>它会设置系统时钟为 <code>80M Hz</code>.</p>
<h4 id="初始化IO端口和定时器及中断"><a href="#初始化IO端口和定时器及中断" class="headerlink" title="初始化IO端口和定时器及中断"></a>初始化IO端口和定时器及中断</h4><p>首先初始化 <code>TM4C123G</code> 板上自带的<code>RGB LED</code>端口为数字输出端口，它分别对应<code>pin</code>口为<code>PF1（R）</code>、<code>PF2（B)</code>、<code>PF3（G）</code>,具体的函数定义在后面加入，这里只需要明白它做了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RGB_LED_Init();</span><br></pre></td></tr></table></figure>

<h4 id="初始化和直流电机相关的端口"><a href="#初始化和直流电机相关的端口" class="headerlink" title="初始化和直流电机相关的端口"></a>初始化和直流电机相关的端口</h4><p>设置<code>PD0</code>，<code>PD1</code>，<code>PD2</code>，<code>PD3</code>为数字输出端口，并设置其初始值为<code>0</code>；设置<code>PE5</code>为数字输出端口，并设初始值为<code>1</code>。上述5个端口都使用<code>8mA</code>驱动，具体如何用于控制电机后面会进行描述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Motor_Port_Init()</span><br></pre></td></tr></table></figure>

<h4 id="前置电机定时器Timer0和中断初始化"><a href="#前置电机定时器Timer0和中断初始化" class="headerlink" title="前置电机定时器Timer0和中断初始化"></a>前置电机定时器Timer0和中断初始化</h4><p>我们在这里初始化<code>Timer0A</code>定时器，优先级为<code>2</code>，它的 <code>IRQ</code> 编号为19，<code>ISR</code>为<code>Timer0A_Handler</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Motro_Front_Init()</span><br></pre></td></tr></table></figure>

<h4 id="后置电机定时器-Systick-和中断初始化"><a href="#后置电机定时器-Systick-和中断初始化" class="headerlink" title="后置电机定时器 Systick 和中断初始化"></a>后置电机定时器 Systick 和中断初始化</h4><p>我们设置 <code>SysTick</code> 定时器，优先级为<code>2</code>，<code>ISR</code> 为<code>SysTick_Handler</code>，<code>SysTick</code>中断不需要中断确认<code>(ack)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Motro_Back_Init();</span><br></pre></td></tr></table></figure>

<p>我们在使用定时器的目的是使用 <code>PWM</code> 来驱动电机，使其可以加速或者减速, 定时器可以帮助我们生成不同占空比的<code>PWM</code>，对于后置电机占空比由 <code>BACK_L</code>和 <code>BACK_H</code> 变量控制，这两个变量交替作为<code>SysTick</code>的初始计数器值。<code>PD0</code>和<code>PD1</code>端口与<code>LN298</code>模块相连，在<code>SysTick_Handler</code>中会向<code>PDO</code>和<code>PD1</code>输出 <code>0</code> 或者 <code>1</code>，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bitmap = <span class="number">0x01</span> &lt;&lt; reversal;</span><br><span class="line">    <span class="keyword">if</span>(GPIO_PORTD_DATA_R &amp; bitmap)&#123; <span class="comment">// toggle ENA</span></span><br><span class="line">        GPIO_PORTD_DATA_R &amp;= ~bitmap;</span><br><span class="line">        NVIC_ST_RELOAD_R = back_L<span class="number">-1</span>; <span class="comment">// reload value for low phase</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        GPIO_PORTD_DATA_R |= bitmap;</span><br><span class="line">        NVIC_ST_RELOAD_R = back_H<span class="number">-1</span>; <span class="comment">// reload value for low phase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>reversal</code>用来控制电机反向旋转；<code>NVIC_ST_RELOAD_R</code>寄存器存有 <code>SysTick</code> 的计数器初始值。</p>
<h4 id="初始化-IRremote-模块"><a href="#初始化-IRremote-模块" class="headerlink" title="初始化 IRremote 模块"></a>初始化 IRremote 模块</h4><p>该模块负责红外遥控，主要包括<code>NEC</code>协议的解析等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IRremote_init();</span><br></pre></td></tr></table></figure>

<h4 id="初始化和红外线距离传感器相关的端口及中断"><a href="#初始化和红外线距离传感器相关的端口及中断" class="headerlink" title="初始化和红外线距离传感器相关的端口及中断"></a>初始化和红外线距离传感器相关的端口及中断</h4><p>我们设置<code>PA4</code>，<code>PA5</code>，<code>PA6</code>为数字输入端口，并设置为双边缘触发中断，优先级为<code>1</code>，<code>IRQ</code>为 <code>0</code>，它们分别对应前方、左方和右方的传感器。连接到响应端口，当有信号到来时，会触发中断，进而执行 <code>GPIOPortA_Handler ISR</code>。在 <code>ISR</code> 中首先进行中断确认，然后会获取<code>3</code>个端口的数据值，根据数据值来判断当前小车前、左和右方是否有障碍物，会根据具体情况进行后退、转向或者加速等。在<code>IR_sensor_Init</code>中会时设置延迟定时器<code>TIMER1A</code>，但不能启动定时器，该定时器在<code>GPIOPortA_Handler</code>中启动，并根据具体参数设置延迟时间。在延迟期间，<code>GPIOPortA_Handler</code>不再处理来自传感器的数据而是直接返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IR_sensor_Init();</span><br></pre></td></tr></table></figure>

<h4 id="全局中断使能"><a href="#全局中断使能" class="headerlink" title="全局中断使能"></a>全局中断使能</h4><p>调用如下接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EnableInterrupts();</span><br></pre></td></tr></table></figure>

<p>其具体实现通过汇编代码表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EnableInterrupts    CPSID    I ; set I = 1</span><br><span class="line">                    BX    LR </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="进入主循环："><a href="#进入主循环：" class="headerlink" title="进入主循环："></a>进入主循环：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (IRreceived()) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> data_value;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> count = <span class="number">1</span>&lt;&lt;<span class="number">15</span>;</span><br><span class="line">        data_value = getIRresult();</span><br><span class="line"></span><br><span class="line">        swicth(data_value) &#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (count) &#123;count--;&#125;</span><br><span class="line">    resumeIRremote(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主循环主要是监听红外遥控命令来作出反应。</p>
<h3 id="其他子函数"><a href="#其他子函数" class="headerlink" title="其他子函数"></a>其他子函数</h3><h4 id="后置电机停止-Motor-Back-Stop-函数"><a href="#后置电机停止-Motor-Back-Stop-函数" class="headerlink" title="后置电机停止 Motor_Back_Stop 函数"></a>后置电机停止 Motor_Back_Stop 函数</h4><p>该函数通过禁止 <code>SysTick</code> 定时器和设置 <code>PD0</code> 和 <code>PD1</code> 端口为 <code>0</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Motor_Back_Stop</span><span class="params">()</span>&#123;</span><br><span class="line">    NVIC_ST_CTRL_R = <span class="number">0</span>;      <span class="comment">// disable SysTick</span></span><br><span class="line">    reversal = <span class="number">0</span>;</span><br><span class="line">    GPIO_PORTD_DATA_R &amp;= ~<span class="number">0x03</span>; <span class="comment">// make PD0(IN1),PD1(IN2) low</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后置电机运行"><a href="#后置电机运行" class="headerlink" title="后置电机运行"></a>后置电机运行</h4><p>重新使能 <code>SysTick</code> 并设置 <code>PD0</code> 和 <code>PD1</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Motor_Back_Run</span><span class="params">()</span>&#123;</span><br><span class="line">    reversal = <span class="number">0</span>;</span><br><span class="line">    NVIC_ST_CTRL_R = <span class="number">0x07</span>; <span class="comment">// e`nable SysTick with core clock and interrupts</span></span><br><span class="line">    GPIO_PORTD_DATA_R |= <span class="number">0x01</span>; <span class="comment">// make PD0(IN1) high</span></span><br><span class="line">    GPIO_PORTD_DATA_R &amp;= ~<span class="number">0x02</span>; <span class="comment">// make PD1(IN2) low</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后置电机减速"><a href="#后置电机减速" class="headerlink" title="后置电机减速"></a>后置电机减速</h4><p>通过调节 <code>Bask_L</code> 和 <code>Back_H</code> 全局变量来实现，我们只能这两个变量会与 <code>SysTick</code> 定时器合作完成 <code>PWM</code> 控制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Motor_Back_SlowDown</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(NVIC_ST_CTRL_R != <span class="number">0x0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>((n--)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(back_L&gt;<span class="number">8000</span>) back_L = back_L - <span class="number">8000</span>; <span class="comment">//slow down</span></span><br><span class="line">        &#125;</span><br><span class="line">         back_H = <span class="number">80000</span> - back_L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后置电机加速"><a href="#后置电机加速" class="headerlink" title="后置电机加速"></a>后置电机加速</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Motor_Back_SpeedUp</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(NVIC_ST_CTRL_R != <span class="number">0x0</span>)&#123;</span><br><span class="line">         <span class="keyword">while</span>((n--)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(back_L&lt;<span class="number">72000</span>) back_L = back_L + <span class="number">8000</span>; <span class="comment">// speed up</span></span><br><span class="line">         &#125;</span><br><span class="line">         back_H = <span class="number">80000</span> - back_L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后置电机反向旋转"><a href="#后置电机反向旋转" class="headerlink" title="后置电机反向旋转"></a>后置电机反向旋转</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Motor_Back_Reversal</span><span class="params">()</span>&#123;</span><br><span class="line">    reversal = <span class="number">1</span>;</span><br><span class="line">    NVIC_ST_CTRL_R = <span class="number">0x07</span>; <span class="comment">// enable SysTick with core clock and interrupts</span></span><br><span class="line">    GPIO_PORTD_DATA_R &amp;= ~<span class="number">0x01</span>; <span class="comment">// IN1 low</span></span><br><span class="line">    GPIO_PORTD_DATA_R |= <span class="number">0x02</span>; <span class="comment">// IN2 high</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="左右转弯"><a href="#左右转弯" class="headerlink" title="左右转弯"></a>左右转弯</h4><p>左右转弯通过 <code>PWM</code> 控制前置电机完成，它要重新使能<code>Timer0A</code>定时器，因为在停止转向函数中该定时器会被禁止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Turn_Left</span><span class="params">()</span>&#123;</span><br><span class="line">    GPIO_PORTD_DATA_R &amp;= ~<span class="number">0x04</span>; <span class="comment">// PD2(IN3)</span></span><br><span class="line">    GPIO_PORTD_DATA_R |= <span class="number">0x08</span>; <span class="comment">// PD3 (IN4)</span></span><br><span class="line">    TIMER0_CTL_R |= <span class="number">0x00000001</span>;</span><br><span class="line">    turning =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Turn_Right</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//TIMER0_CTL_R |= 0x00000001;</span></span><br><span class="line">    GPIO_PORTD_DATA_R &amp;= ~<span class="number">0x08</span>; <span class="comment">// PD3(IN4)</span></span><br><span class="line">    GPIO_PORTD_DATA_R |= <span class="number">0x04</span>; <span class="comment">// PD2 (IN3)</span></span><br><span class="line">    TIMER0_CTL_R |= <span class="number">0x00000001</span>;</span><br><span class="line">    turning =<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="停止转向"><a href="#停止转向" class="headerlink" title="停止转向"></a>停止转向</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Turn_Stop()&#123;</span><br><span class="line">    TIMER0_CTL_R &amp;= ~0x00000001;</span><br><span class="line">    GPIO_PORTD_DATA_R &amp;= ~0x0c; // make PD2(IN3),PD3(IN4) low</span><br><span class="line">    turning = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><h4 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h4><h4 id="使用WIFI模组联网"><a href="#使用WIFI模组联网" class="headerlink" title="使用WIFI模组联网"></a>使用WIFI模组联网</h4>]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>TLS Protocol Analysis</title>
    <url>/2024/12/16/TLS-Protocol-Analysis/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>IEFT 在 <code>SSL v3.0</code> 的基础上制定了 SSL 的互联网标准版本，称为<strong>传输层安全</strong>（Transport Layer Security, TLS）协议。其目标是使 SSL 更安全，并使协议的规范更精确和完善。IEFT 在后续发布的 RFC 中建议禁用 SSL。</p>
<p>TLS 主要经历了 4 个版本：<a href="https://www.rfc-editor.org/rfc/rfc2246">TLS 1.0</a> (RFC2246, 1999年)，<a href="https://www.rfc-editor.org/rfc/rfc4346">TLS 1.1</a>（RFC4346, 2006年），<a href="https://www.rfc-editor.org/rfc/rfc5246">TLS 1.2</a> (RFC5246, 2008年)，<a href="https://www.rfc-editor.org/rfc/rfc8446">TLS 1.3</a>（RFC8446, 2018年）。</p>
<span id="more"></span>

<h3 id="TLS-协议"><a href="#TLS-协议" class="headerlink" title="TLS 协议"></a>TLS 协议</h3><h4 id="协议栈体系结构"><a href="#协议栈体系结构" class="headerlink" title="协议栈体系结构"></a>协议栈体系结构</h4><p><img src="/2024/12/16/TLS-Protocol-Analysis/tls_protocal_stack.png"></p>
<h4 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h4><p>TLS v1.2 的握手流程如下图所示，假设使用基于 RSA 的密钥交换算法：<br><img src="/2024/12/16/TLS-Protocol-Analysis/handshake.png"></p>
<p>在 <code>ClientHello</code> 消息中的<strong>密码套件（cipher suite）</strong> 参数格式如下（TLS v1.2）:<br><img src="/2024/12/16/TLS-Protocol-Analysis/ciphersuite.png"></p>
<blockquote>
<p>参考 <a href="https://www.golinuxcloud.com/analyze-tls-mtls-wireshark/">Analyze TLS and mTLS Authentication with Wireshark</a>。</p>
</blockquote>
<h3 id="Demo-测试"><a href="#Demo-测试" class="headerlink" title="Demo 测试"></a>Demo 测试</h3><p>本节使用 Go 建立基于 TLS 的 C&#x2F;S 通信，并使用 wireshark 解析通信协议报文。</p>
<h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><p>为了使用 TLS，我们首先需要生成一系列 TLS 证书。由于我们不是部署到生产环境，我们可以使用自签名证书；反之，我们需要从一个可信的 CA 获取证书。</p>
<p>a. 生成私钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl genrsa -out server.key 2048</span></span><br></pre></td></tr></table></figure>

<p>b. 生成自签名证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl req -new -x509 -key server.key -out server.crt -days 365 -addext <span class="string">&quot;subjectAltName = DNS:localhost&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="编写-server-端代码"><a href="#编写-server-端代码" class="headerlink" title="编写 server 端代码"></a>编写 server 端代码</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">&quot;certificates/server.crt&quot;</span>, <span class="string">&quot;certificates/server.key&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Server start listening on port 443&quot;</span>)</span><br><span class="line">	ln, err := tls.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:443&quot;</span>, &amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cert&#125;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> ln.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := ln.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handler(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	r := bufio.NewReader(conn)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		msg, err := r.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">		_, err = conn.Write([]<span class="type">byte</span>(<span class="string">&quot;world\n&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写-client-端代码"><a href="#编写-client-端代码" class="headerlink" title="编写 client 端代码"></a>编写 client 端代码</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := tls.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:443&quot;</span>, &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	_, err = conn.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello\n&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	n, err := conn.Read(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TLS扩展和高级特性"><a href="#TLS扩展和高级特性" class="headerlink" title="TLS扩展和高级特性"></a>TLS扩展和高级特性</h3><p>TLS 协议不仅提供基本的加密和身份认证功能，还包括多种扩展和高级特性，这些特性可以优化性能、增强安全性，或支持特定的安全场景。</p>
<h4 id="SNI"><a href="#SNI" class="headerlink" title="SNI"></a>SNI</h4><p><code>SNI</code>(Server Name Indication) 扩展允许多个域名共享同一个 IP 地址和端口，但同时使用不同的证书。在 Go 中，可以通过 <code>tls.config</code> 的 <code>NameToCertificate</code> 字段来实现 SNI。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config := &amp;tls.Config &#123;</span><br><span class="line">    NameToCertificate: map[string]*tls.Certificate &#123;</span><br><span class="line">        &quot;example.com&quot; : cert1,</span><br><span class="line">        &quot;example.org&quot; : cert2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ALPN"><a href="#ALPN" class="headerlink" title="ALPN"></a>ALPN</h4><p><code>ALPN</code>(Application-Layer Protocol Negotiation) 扩展允许客户端和服务器在 TLS 握手过程中协商应用层协议（如 HTTP）。在 Go 的 <code>tls.config</code> 中，可以设置 <code>NextProtos</code> 来实现 ALPN。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">config := &amp;tls.Config &#123;</span><br><span class="line">    NextProtos: []<span class="type">string</span>&#123;<span class="string">&quot;h2&quot;</span>, <span class="string">&quot;http/1.1&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>信息安全</category>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title>TM4C123G H6PIM微控制器开发板</title>
    <url>/2022/05/03/TM4C123G-H6PIM%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp; <code>TM4c123Gh6pm</code> 是嵌入ARM Cortex-M4F处理器的开发板，处理器频率为80MHZ（通过PLL配置后），配有256k flash ROM，32k RAM，2k EEPROM，还包括USB主机，OTG连接，睡眠模块、PWM和其他外围设备。</p>
<span id="more"></span>

<p>硬件架构：<br><img src="/2022/05/03/TM4C123G-H6PIM%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%9D%BF/tm4c_arch.png"></p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><h4 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h4><ul>
<li>供电：在<code>USB Device</code>和<code>ICDI/DEBUG USB</code>间切换</li>
<li>休眠：TIVA C系列的Launchpad提供频率为 32.768khz 的外部晶振（Y1），它为休眠模块提供时钟源。</li>
</ul>
<h4 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h4><p>&emsp;&emsp;主控制器的内部时钟由频率为 16Mhz 的晶振（Y2）提供。内部PLL可以通过软件配置来产生更高频率的时钟。</p>
<h3 id="软件开发环境"><a href="#软件开发环境" class="headerlink" title="软件开发环境"></a>软件开发环境</h3><h4 id="ICDI驱动"><a href="#ICDI驱动" class="headerlink" title="ICDI驱动"></a>ICDI驱动</h4><p>&emsp;&emsp;  <a href="https://www.ti.com/tool/STELLARIS_ICDI_DRIVERS?keyMatch=ICDI&tisearch=Search-EN-everything&usecase=part-number">TI官网下载</a><br>&emsp;&emsp; <code>ICDI</code>（In-Circuit Debug Interface）是一个电路调试接口，它可以允许使用<code>LM Flash Programmer</code>或者其他支持的工具对板子进行编程或者调试。ICDI只支持JTAG调试。当设备连接到PC后，设备枚举器会生成虚拟COM端口。</p>
<h4 id="Windows-下开发环境"><a href="#Windows-下开发环境" class="headerlink" title="Windows 下开发环境"></a>Windows 下开发环境</h4><p>&emsp;&emsp; 在windows下开发可以使用IDE，例如TI支持的CCS，或者第三方的Keil等，开发前要首先安装ICDI驱动。接下来如果使用Keil v5集成开发环境，要下载相应的PACK（<code>Keil:TM4C_DFP</code>），然后可以下载<code>TivaWare SDK</code>，里面包含很多示例项目以及驱动库（USB库、图形库等）。Keil已经集成了烧录工具，可以直接使用，但也可以使用TI官方提供的<code>LM Flash Programmer</code>工具。Keil集成了编译器和链接器，但也可以从官网下载独立的工具链  <a href="https://www.ti.com/tool/TI-CGT">TI_CGT</a>。</p>
<h4 id="Linux-下开发环境"><a href="#Linux-下开发环境" class="headerlink" title="Linux 下开发环境"></a>Linux 下开发环境</h4><p>参考 <a href="https://jachinshen.github.io/environment/2018/02/01/%E7%BF%BB%E8%AF%91-%E5%9C%A8Linux%E4%B8%8A%E5%BC%80%E5%8F%91TivaC.html">在 Linux 上开发 TivaC </a></p>
<h4 id="片上调试"><a href="#片上调试" class="headerlink" title="片上调试"></a>片上调试</h4><p>&emsp;&emsp; 使用OpenOCD</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="http://users.ece.utexas.edu/~valvano/arm/">示例项目</a></p>
]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>TSP问题的数值模拟</title>
    <url>/2023/03/13/TSP%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E5%80%BC%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <code>旅行商问题（Traveling SalesPerson Program, TSP）</code>是一个经典的组合优化问题。给定一个城市列表以及各相邻城市间的<strong>旅行代价值</strong>（例如物理距离），一个商人从出发城市开始，需要<strong>访问并且只访问一次</strong>其他所有城市后返回出发地，并要求旅行代价值最小。<br>&emsp;&emsp; 从图论的角度上分析，TSP 问题是 <strong>NP 完全问题</strong>。实际上，从工程实践的角度上看，它意味着在任何情况下，没有已知算法可以比<strong>穷举法</strong>更好地解决该问题。但是对于穷举法，随着顶点数的增加，会产生组合爆炸问题。<br>&emsp;&emsp;虽然如此，目前仍然存在许多近似算法和启发式算法可以使用，例如遗传算法、模拟退火法、蚁群算法、禁忌搜索算法、贪婪算法和神经网络等。</p>
<span id="more"></span>

<blockquote>
<p>参考 《Introduction to ParallelProgramming》 by Peter Pacheco.</p>
</blockquote>
<h2 id="树搜索方法"><a href="#树搜索方法" class="headerlink" title="树搜索方法"></a>树搜索方法</h2><pre class="mermaid">graph LR
emperor((0)) -- 1 --> emperor1((1))
emperor1((1)) -- 5 --> emperor((0))
emperor((0)) -- 3 --> emperor2((2))
emperor2((2)) -- 1 --> emperor((0))
emperor((0)) -- 8 --> emperor3((3))
emperor3((3)) -- 7 --> emperor((0))
emperor1((1)) -- 2 --> emperor2((2))
emperor2((2)) -- 18 --> emperor1((1))
emperor1((1)) -- 6 --> emperor3((3))
emperor3((3)) -- 4 --> emperor1((1))</pre>]]></content>
      <categories>
        <category>高性能计算</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Tmux快捷键参考手册</title>
    <url>/2022/04/29/Tmux%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;tmux具有强大的终端复用功能，它可以实现编辑同步。tmux的命令模式、配置文件都与vim类似。tmux整体遵循CS设计，围绕window、session、pane等核心概念。详细手册参考man page或者项目github主页。</p>
<span id="more"></span>

<h3 id="命令及快捷键前缀"><a href="#命令及快捷键前缀" class="headerlink" title="命令及快捷键前缀"></a>命令及快捷键前缀</h3><p><code>Ctrl b</code> (可以在tmux.conf中更改为其他前缀)</p>
<h4 id="创建新窗口"><a href="#创建新窗口" class="headerlink" title="创建新窗口"></a>创建新窗口</h4><p><code>:new-window (neww)</code><br><code>c</code> ：创建新窗口，窗口索引号会自动分配</p>
<h4 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h4><p><code>:kill-window</code> ：关闭窗口，所有pane被关闭<br><code>&amp;</code>：关闭当前激活窗口</p>
<h4 id="选择窗口"><a href="#选择窗口" class="headerlink" title="选择窗口"></a>选择窗口</h4><p><code>:select-window</code><br><code>[0-9]</code>：选择索引所代表的窗口<br><code>&#39;</code> ：根据索引选择当前窗口<br><code>n</code> ：选择下一个窗口<br><code>l</code> ：选择最后一个窗口<br><code>:choose-tree</code>：选择树结构<br><code>s或w</code>：然后使用上下左右进行选择，使用<code>t</code>可以进行标记，使用<code>x</code>可以直接关闭某个item。</p>
<h4 id="分列窗口，创建pane"><a href="#分列窗口，创建pane" class="headerlink" title="分列窗口，创建pane"></a>分列窗口，创建pane</h4><p><code>:split-window (splitw)</code>：创建pane，分列窗口<br><code>% </code>: 水平分列<br><code>&quot;</code> : 垂直分列</p>
<h4 id="关闭pane"><a href="#关闭pane" class="headerlink" title="关闭pane"></a>关闭pane</h4><p><code>:kill-pane</code>：关闭当前激活的pane<br><code>x</code></p>
<h4 id="选择pane"><a href="#选择pane" class="headerlink" title="选择pane"></a>选择pane</h4><p><code>:select-pane</code><br><code>&lt;Up&gt; &lt;Down&gt; &lt;Right&gt; &lt;Left&gt;</code> ：按照上下左右的方向跳转<br><code>q</code> ：显示Pane数以其尺寸<br><code>&lt;Space&gt;</code>窗口布局切换<br><code>f</code>：寻找包含某个文本的pane或者window</p>
<h4 id="重新规划pane大小"><a href="#重新规划pane大小" class="headerlink" title="重新规划pane大小"></a>重新规划pane大小</h4><p><code>Ctrl &lt;Left&gt;</code> 、<code>Ctrl &lt;Right&gt;</code>、<code>Ctrl &lt;Up&gt;</code> 、<code>Ctrl &lt;Down&gt;</code></p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p><code>:new-session</code>创建新的会话<br><code>:attach-session (attach)</code> ：连接一个已经存在的会话或者新建一个会话<br><code>:attach -t &lt;seesion-id&gt;</code><br><code>:detach-client</code>或<code>d</code>：从当前会话退出</p>
<h4 id="设置鼠标"><a href="#设置鼠标" class="headerlink" title="设置鼠标"></a>设置鼠标</h4><p><code>:set -g mouse on</code><br><code>:set -g mouse off</code></p>
<h4 id="文本模式"><a href="#文本模式" class="headerlink" title="文本模式"></a>文本模式</h4><p><code>Ctrl+b+[</code> : 进入文本复制模式，然后按下 <code>Space</code> 空格键选择起始位置，<code>Enter</code> 键完成，<code>Ctrl+b+]</code> 粘贴。</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>TrustZone 与 OP-TEE技术总结</title>
    <url>/2025/03/25/TrustZone-%E4%B8%8E-OP-TEE%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><span id="more"></span>
<blockquote>
<p>参考 《手机安全和可信应用开发指南：TrustZone 与OP-TEE技术详解》by 帅峰云等<br>参考 <a href="https://zhuanlan.zhihu.com/p/18478508824">ARM trustzone的安全扩展介绍</a></p>
</blockquote>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>UART/TTL/RS232学习总结</title>
    <url>/2018/03/17/UART-TTL-RS232%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="关于RS232与TTL间的转换"><a href="#关于RS232与TTL间的转换" class="headerlink" title="关于RS232与TTL间的转换"></a>关于RS232与TTL间的转换</h2><p>特别注意的是:UART是将计算机的并行信号转换成串行信号的硬件设备，不要简单理解为协议</p>
<span id="more"></span>


<h2 id="关于Linux终端①"><a href="#关于Linux终端①" class="headerlink" title="关于Linux终端①"></a>关于Linux终端①</h2><p>&emsp;&emsp;Linux在为用户提供对终端设备简洁的读写接口之外，还提供了一组编程接口来对终端进行更精细的控制。下面是用户能够控制的主要功能：</p>
<p><code>行编辑</code>： 是否允许使用退格键来编辑。</p>
<p><code>缓存</code>：是立即读取字符，还是等待一段可配置的延迟之后再读取它们。</p>
<p><code>回显</code>：允许控制字符的回显，例如读取密码时。</p>
<p><code>回车/换行（CR/LF）</code>：定义如何在输入&#x2F;输出时映射回车&#x2F;换行符，比如打印\n字符时应该如何处理。</p>
<p><code>线速</code>：这种功能很少用于PC控制台，但对调制解调器或通过串行线连接的终端就很重要。</p>
<p><code>标准模式</code>：所有的操作都基于行进行处理，在一个输入行完成前（通常是用户按下回车键之前），终端接口负责管理所有的键盘输入，包括退格键（Backspace）和删除键（Del），应用程序读不到用户的任何输入。这样做是有益的，因为允许用户来纠正输入中的错误直到满意为止。</p>
<h3 id="termios结构"><a href="#termios结构" class="headerlink" title="termios结构"></a>termios结构</h3><p>&emsp;&emsp;可以分为以下几个模式：输入模式，输出模式，控制模式，本地模式，特殊控制字符模式。</p>
<p>函数接口原型：②</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span>&#123;</span></span><br><span class="line">    <span class="type">tcflag_t</span> c_iflag;</span><br><span class="line">    <span class="type">tcflag_t</span> c_oflag;</span><br><span class="line">    <span class="type">tcflag_t</span> c_cflag;</span><br><span class="line">    <span class="type">tcflag_t</span> c_lflag;</span><br><span class="line">    <span class="type">tcflag_t</span> c_cc[NCCS];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcgetattr</span><span class="params">(<span class="type">int</span> fd,<span class="keyword">struct</span> termios* termios_p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> ations,<span class="type">const</span> <span class="keyword">struct</span> trmios* termios_p)</span>; </span><br></pre></td></tr></table></figure>
<p>参数action控制修改方式，共有三种修改方式：</p>
<p><code>TCSANOW</code>：立即对值进行修改。</p>
<p><code>TCSADRAIN</code>：等当前的值输出完成后再对值进行修改。</p>
<p><code>TCSAFLUSH</code>：等当前的值输出完成后再对值进行修改，但丢弃还未从read调用返回的当前可用的任何输入。</p>
<p>&emsp;&emsp;特别注意，程序有责任将终端设置恢复到程序开始运行之前的状态，这一点是非常重要的。在kydevmonit的devicesManagerd中该如何做呢？</p>
<h4 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h4><p>&emsp;&emsp;通过设置termios中的c_lflag成员的标志来对本地模式进行设置。可用于c_lflag成员的宏如下：</p>
<p><code>ECHO</code>：启用输入字符的本地回显功能。</p>
<p><code>ECHONL</code>：回显新行符。</p>
<p><code>ICANON</code>：启用标准输入处理，否则就启用非标准模式。</p>
<p><code>ISIG</code>：启用信号。</p>
<p><code>NOFLUSH</code>：禁止清空队列。</p>
<p><code>TOSTOP</code>：在试图进行写操作之前给后台进程发送一个信号。</p>
<p><code>ECHOE/ECHOK/IEXTEN</code>：略</p>
<h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>&emsp;&emsp;输入模式控制输入数据（终端驱动程序从串行口或键盘接收到的字符）在被传递给程序之前的处理方式。设置c_iflag。成员宏如下：</p>
<p><code>BRKINT</code>：当在输入行中检测到一个终止状态（连接丢失）时，产生一个中断。</p>
<p><code>IGNBRK</code>：忽略输入行中的终止状态。</p>
<p><code>ICRNL</code>：将接收到的回车符转换为新行符。</p>
<p><code>INLCR</code>：将接收到的新行符转换为回车符。</p>
<p><code>IGNCR</code>：忽略接收到的回车符。</p>
<p><code>IGNPAP</code>：忽略奇偶校验错误的字符。</p>
<p><code>INPCK</code>：对接收到的字符进行奇偶校验。</p>
<p><code>ISTRIP</code>：将所有接收到的字符裁剪为7bit。</p>
<p><code>IXOFF/IXON</code>：关闭&#x2F;打开软件流控。</p>
<h4 id="输出模式"><a href="#输出模式" class="headerlink" title="输出模式"></a>输出模式</h4><p>&emsp;&emsp;输出模式控制输出字符的处理方式，即由程序发送出去的字符在传递到串行口或屏幕之前是如何处理的。设置c_oflag。成员宏如下：</p>
<p><code>OPOST</code>：打开输出处理功能。如果没有设置该标志，则所有其他标志则被忽略。</p>
<p><code>OCRNL</code>：将输出的回车符转换为新行符。</p>
<p><code>ONLCR</code>：将输出到的新行符转换为回车符。</p>
<p><code>ONLRET</code>：不输出回车符。</p>
<p>其他略</p>
<h4 id="控制模式"><a href="#控制模式" class="headerlink" title="控制模式"></a>控制模式</h4><p>&emsp;&emsp;控制模式控制终端的硬件特性。你通过设置c_cflag成员的标志来对控制模式进行配置。成员宏如下：</p>
<p><code>CLOCAL</code>：忽略所有调试解调器的状态行。</p>
<p><code>CREAD</code>：启用字符接收器。</p>
<p><code>CS5</code>：发送或接收时使用5bit。</p>
<p><code>CS6</code>：发送或接收时使用6bit。</p>
<p><code>CS7</code>：发送或接收时使用7bit。</p>
<p><code>CS8</code>：发送或接收时使用8bit。</p>
<p><code>CSTOP</code>：每个字符使用两个停止位而不是一个。</p>
<p><code>CSIZE</code>：对数据的bit位使用掩码。注意，在设置CS数据位时要先屏蔽其他位。c_cflag &amp;&#x3D; ~CSIZE;</p>
<p><code>HUPCL</code>：关闭时挂断调制解调器。</p>
<p><code>PARENB</code>：启用就校验码的生成和检测功能。</p>
<p><code>PARODD</code>：使用奇校验而不是偶检验。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_flag &amp;= ~PARENB; // 无校验</span><br><span class="line">c_flag |=（PARODD | PARENB）;//奇校验</span><br><span class="line">c_falg &amp;= ~PARENB;c_falg &amp;= ~PARODD;//偶校验</span><br></pre></td></tr></table></figure>
<h4 id="特殊控制字符"><a href="#特殊控制字符" class="headerlink" title="特殊控制字符"></a>特殊控制字符</h4><p>这里只说明TIME与MIN值。用于是作为c_cc数组的index：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int TIME,MIN;</span><br><span class="line">c_cc[VTIME] = TIME;</span><br><span class="line">c_cc[VMIN] =MIN;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;TIME与MIN只能用于非标准模式（禁用ICANON标志），两者结合起来共同控制对输入的读取。</p>
<p>&emsp;&emsp;两者的结合分为如下四种情况：</p>
<p>&emsp;&emsp;MIN&#x3D;0和TIME&#x3D;0：在这种情况下，read调用总是立即返回，如果有等待处理的字符，它们就会被返回；如果没有字符等待处理，read调用返回0，并且不读取任何字符。</p>
<p>&emsp;&emsp;MIN&#x3D;0和TIME&gt;1：这种情况下，只要有字符可以处理或者是经过TIME个0.1秒的时间间隔，read调用会返回。如果因为超时而未读到任何字符，read返回0，否则read返回读取的字符数目。</p>
<p>&emsp;&emsp;MIN&gt;0和TIME&#x3D;0：这种情况下，read调用会一直等待，直到有MIN个字符可以读取时才返回，返回值是读取的字符数量，但文件尾时返回0。</p>
<p>&emsp;&emsp;MIN&gt;0和TIME&gt;0：这种情况下，当read被调用时，它会等待接收一个字符。在接收到第一个字符及后续的每个字符后，一个字符间隔定时器被启动。当有MIN个字符可读或者两个字符的时间间隔超过TIME个0.1秒时，read调用返回。这个功能可用于区分是单独按下了Escape键还是按下了以Escape键开始的功能组合键。但要注意的是，网络通信或处理器的高负载使得类似这样的定时器失去作用。</p>
<p>&emsp;&emsp;通过设置非标准模式与使用MIN和TIME值，程序可以逐个字符地处理输入</p>
<h4 id="终端速度"><a href="#终端速度" class="headerlink" title="终端速度"></a>终端速度</h4><p>&emsp;&emsp;设置终端速度直接作用于termios结构，因此要设置新的终端速度，你必须使用tcgetattr获取当前配置，最后使用tcsetattr写回。只有写回后，终端速度才会改变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">speed_t cfgetispeed(const struct termios*);</span><br><span class="line">speed_t cfgetospeed(const struct termios*);</span><br><span class="line">int cfsetispeed(struct termios*,speed_t speed);</span><br><span class="line">intccfsetospeed(struct termios*,speed_t speed);</span><br></pre></td></tr></table></figure>
<p>speed的值可设置如下：</p>
<p>B0：挂起终端。</p>
<p>B9600：9600波特率。</p>
<p>B115200：115200波特率。</p>
<p>其他波特率包括B1200，B2400，B19200，B38400等。</p>
<h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int tcdrain(int fd); //让调用程序一直等待，直到所有排队的输出都已发送完毕。</span><br><span class="line">int tcflow(int fd, int flowtype);//用于暂停或重新开始输出。</span><br><span class="line">int tcflush(int fd,int in_out_selector);//用于清空输入、输出或者两者都输出。</span><br></pre></td></tr></table></figure>
<p>使用shell命令<code>stty -F &lt;DEVICE&gt; -a</code>可以查看某个设备当前的termios值。</p>
<h3 id="虚拟控制台"><a href="#虚拟控制台" class="headerlink" title="虚拟控制台"></a>虚拟控制台</h3><p>&emsp;&emsp;Linux提供一组终端设备来共享PC电脑的屏幕、键盘和鼠标。虚拟控制台通过字符设备文件&#x2F;dev&#x2F;ttyN来使用。</p>
<p>&emsp;&emsp;使用命令who或者ps -e你可以查看目前登录进系统的用户，以及在这个虚拟控制台上运行的shell和执行的程序。</p>
<p>&emsp;&emsp;Linux系统通常会在前6个虚拟台上运行一个getty进程，这样用户既可用同一个屏幕、键盘和鼠标在6个不同的虚拟控制台上登录。</p>
<h3 id="伪终端"><a href="#伪终端" class="headerlink" title="伪终端"></a>伪终端</h3><p>PTY与pts</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>① Linux程序设计：第4版&#x2F;（英）马修（Mattew,N.），（英）斯通斯（Stones,R.）著；陈健，宋健健译.——北京：人民邮电出版社,2010.6</p>
<p>② manpage for tcgetattr&#x2F;tcsetattr</p>
]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 18.04 上安装Tenda U9无线网卡驱动</title>
    <url>/2021/12/31/Ubuntu-18-04-%E4%B8%8A%E5%AE%89%E8%A3%85Tenda-U9%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="网卡芯片"><a href="#网卡芯片" class="headerlink" title="网卡芯片"></a>网卡芯片</h3><p>内部芯片型号为 Realtek 8811CU Wireless LAN 802.11ac</p>
<span id="more"></span>

<h3 id="获取驱动代码"><a href="#获取驱动代码" class="headerlink" title="获取驱动代码"></a>获取驱动代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/brektrou/rtl8821CU.git</span><br></pre></td></tr></table></figure>
<p>该驱动适用于 Realtek 8811CU&#x2F;8821CU USB Wi-Fi适配器</p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd rtl8821CU</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="检查驱动"><a href="#检查驱动" class="headerlink" title="检查驱动"></a>检查驱动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /lib/modules/$(uname -r)/kernel/drivers/net/wireless/realtek/rtl8821cu</span><br></pre></td></tr></table></figure>

<h3 id="执行usb-modeswitch"><a href="#执行usb-modeswitch" class="headerlink" title="执行usb_modeswitch"></a>执行usb_modeswitch</h3><p>usb_modswaitch命令将USB适配器切换到网络设备模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usb_modeswitch -K -v 0bda -p 1a2b</span><br></pre></td></tr></table></figure>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>为避免每次重启系统或者USB适配器重新插拔时都要手动执行上面的命令,可以增加一条udev规则,使得当udev检测到设备时自动执行相应的命令.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /lib/udev/rules.d/40-usb_modeswitch.rules</span><br></pre></td></tr></table></figure>
<p>在文件中增加一条规则<code>ATTR&#123;idVendor&#125;=&quot;0bda&quot;, ATTR&#123;idProduct&#125;=&quot;1a2b&quot;, RUN+=&quot;usb_modeswitch &#39;/%k&#39;&quot;</code></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在一台机器上增加了udev规则后,重启系统后USB网卡并不能总是正常工作,但这不是udev的问题,而是内核更新后,8821cu内核模块不能自动安装到新的内核模块目录(&#x2F;lib&#x2F;modules&#x2F;$(uname -r)&#x2F;…)中,手动安装后就可以正常工作了.更方便的方法是使用dkms系统,它可以自动编译和安装内核外的驱动模块.</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Wireless Network Security Analysis</title>
    <url>/2024/12/18/Wireless-Network-Security-Analysis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文就无线网络安全协议（如 WEP、WPA&#x2F;WPA2 等）的流程、安全性等做一些总结。</p>
<span id="more"></span>

<h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2><h3 id="STA-与-AP-建立连接的过程"><a href="#STA-与-AP-建立连接的过程" class="headerlink" title="STA 与 AP 建立连接的过程"></a>STA 与 AP 建立连接的过程</h3><p><img src="/2024/12/18/Wireless-Network-Security-Analysis/sta_ap.png"></p>
<h2 id="无线局域网的安全问题"><a href="#无线局域网的安全问题" class="headerlink" title="无线局域网的安全问题"></a>无线局域网的安全问题</h2><ul>
<li>信道干扰。攻击层次位于物理层，WLAN 的频段是公开的，因此 Attacker 很容易通过发射同频段的噪声信号实现信道干扰。</li>
<li>窃听和嗅探。</li>
<li>伪造 AP。AP 和 STA 的网络拓扑关系为中心化的，所有 STA 都是通过接入 AP 后通过 AP 完成数据转发的。攻击者可以伪造一个 AP，并在信号强度上合法 AP 发射的信号，进而截获甚至篡改 STA 的通信数据。</li>
<li>重放攻击。</li>
</ul>
<h2 id="WEP-安全协议"><a href="#WEP-安全协议" class="headerlink" title="WEP 安全协议"></a>WEP 安全协议</h2><p><code>WEP (Wired Equivalent Privacy)</code> 是 IEEE 802.11b 中定义的第一个用于保护 WLAN 通信安全的协议。但目前因为其安全弱点，已经在 2003 年被 <code>Wi-FI Protected Access</code>淘汰，后来在 2004 年由完整的 IEEE 802.11i 标准（WPA2）所取代。</p>
<p>802.11b 支持<strong>开放系统认证（open system authentication）</strong> 和 <strong>共享密钥认证（shared key authentication）</strong>。开放系统认证，也就是无认证。</p>
<h3 id="共享密钥认证"><a href="#共享密钥认证" class="headerlink" title="共享密钥认证"></a>共享密钥认证</h3><p>共享密钥认证过程并不复杂，如下图所示：<br><img src="/2024/12/18/Wireless-Network-Security-Analysis/SKA.png"></p>
<p>注意的是，上述认证过程是单向的，即只能 AP 向 STA 认证，因此 STA 容易受到<strong>伪 AP</strong> 的攻击。</p>
<h3 id="数据加解密流程"><a href="#数据加解密流程" class="headerlink" title="数据加解密流程"></a>数据加解密流程</h3><p><strong>加密流程：</strong><br><img src="/2024/12/18/Wireless-Network-Security-Analysis/wep_encrypt.png"></p>
<p>加密数据帧 MPDU 格式：<br><img src="/2024/12/18/Wireless-Network-Security-Analysis/dataframe_encrypt.png"></p>
<p><strong>解密流程：</strong><br><img src="/2024/12/18/Wireless-Network-Security-Analysis/wep_encrypt.png"></p>
<h3 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h3><ul>
<li>密文逆向分析：根据加密流程，可以知道，当获取到两段密文 S1 和 S2 的情况下，即使不知道密钥流，也可以获得对应两个明文的异或结果。换句话说，在这种情况下，一旦知道了 S1 的明文，立即可以推导出 S2 的明文，反之亦然。因此，WEP 引入了 IV，这样每次加密时，即使密钥相同，IV 不同，也能产生不同的密钥流。</li>
<li>密钥破解：穷举 IV</li>
<li>数据完整性问题：CRC 不能解决身份认证问题，任何人根据明文都可以计算出 CRC 校验和。另外 CRC 具有线性性质，而且流密码器对异或运算也是线性的，从而使得数据篡改成为可能。</li>
</ul>
<p>给定密文 <code>C</code>: $ C &#x3D; RC4(IV, k) \bigotimes (M || CRC(M)) $<br>攻击者按如下方式可以将明文 M 修改为 M’：</p>
<p>a. 计算 M 和 M’ 的差分 $ \Delta $：$ \Delta &#x3D; M \bigoplus M’ $<br>b. 创建新的密文 $ C’ $： $ C’ &#x3D; C \bigoplus (\Delta || CRC(\Delta)) $</p>
<p>证明:<br>$$\begin{align}<br>C’ &amp;&#x3D; C \bigoplus (\Delta || CRC(\Delta)) \\<br>&amp;&#x3D; RC4(IV,k) \bigoplus (M \bigoplus \Delta || CRC(M) \bigoplus CRC(\Delta)) \\<br>&amp;&#x3D; RC4(IV,k) \bigoplus (M’ || CRC(M \bigoplus \Delta)) \\<br>&amp;&#x3D; RC4(IV,k) \bigoplus (M’ || CRC(M’)\\<br>\end{align}$$</p>
<p>因此，攻击者可以有针对性地对明文进行修改，而不用加密或者解密原消息。</p>
<h2 id="WPA-WPA2-WPA3-安全协议"><a href="#WPA-WPA2-WPA3-安全协议" class="headerlink" title="WPA&#x2F;WPA2&#x2F;WPA3 安全协议"></a>WPA&#x2F;WPA2&#x2F;WPA3 安全协议</h2><h3 id="WPA-协议"><a href="#WPA-协议" class="headerlink" title="WPA 协议"></a>WPA 协议</h3><p>由于 WEP 的安全性问题，IEEE 于 2003 年在 802.11g 标准中推出了 <code>WPA(Wi-Fi Protected Access)</code> 协议。<br>WPA 引入了临时密钥完整性协议 <code>TKIP</code>，相对 WEP，TKIP 在安全方面有两点增强：一是增加了密钥强度（但仍然使用 RC4 算法），从 40 位增加到 128 位；二是 <code>MIC</code>（Michael 算法） 代替 CRC 作为完整性校验算法。 </p>
<p>加密过程：<br><img src="/2024/12/18/Wireless-Network-Security-Analysis/wpa_encrypt.png"></p>
<p>解密过程：</p>
<p>WPA的安全性：</p>
<ul>
<li>使用 MIC 替换 CRC，提高了数据传输的完整性保护能力。</li>
<li>动态变换密钥。在 TKIP 中，每个 STA 与 AP 进行通联时，会使用动态生成的临时密钥 TK。这个临时密钥通过将特定的会话内容与 AP 和 STA 生成的一些随机数以及 AP 和 STA 的 MAC 地址进行哈希运算来产生。</li>
<li>使用 TSC 来抵抗重放攻击：接收方接收到报文后会首先提取 TSC，如果 TSC 和上次相比不在合法范围内则认定为重放报文；如果重放攻击累积到一定次数，则中断连接。</li>
</ul>
<h3 id="WPA2-协议"><a href="#WPA2-协议" class="headerlink" title="WPA2 协议"></a>WPA2 协议</h3><p>IEEE 在 2004 年的 802.11i 标准对 WPA 协议进行了更新，称为 WPA2。WPA2 弃用 RC4 算法，改用 AES 加密算法。WPA2 协议配套使用的加密协议改为 <code>CCMP (CTR mode with CBC-MAC Protocol)</code></p>
<p>CCMP 加密过程：<br><img src="/2024/12/18/Wireless-Network-Security-Analysis/ccmp.png"></p>
<h3 id="WPA-WPA2-的认证协议"><a href="#WPA-WPA2-的认证协议" class="headerlink" title="WPA&#x2F;WPA2 的认证协议"></a>WPA&#x2F;WPA2 的认证协议</h3><ul>
<li>802.1x 认证方式：双向认证，面向企业</li>
<li>WPA-PSK 方式：采用预共享密钥进行认证，主要面向个人。在这种方式下， AP 和 STA 之间预共享有相同的 PMK，认证过程需要四次握手。</li>
</ul>
<p>WPA-PSK 认证过程：<br><img src="/2024/12/18/Wireless-Network-Security-Analysis/wpa_psk.png"></p>
<p><code>PMK</code> 由 AP 的 SSID 和 Wi-Fi 口令生成。由 <code>PMK</code>、SNonce、Anonce、AP 和 STA 的 MAC 地址等作为输入，生成 <code>PTK</code>，再由 <code>PTK</code> 生成 MIC。MIC 在上述握手过程中，是最重要的身份识别码 。</p>
<p>WPA2 会遭受 <code>KRACK</code> 攻击：在四次握手过程中，第三个消息报文可能被篡改重放，可导致中间人重置重放计数器和随机数值（Nonce），重放给 STA端，使 STA 安装上不安全加密密钥。</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title>flex 规范参考</title>
    <url>/2022/08/28/flex-%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <a href="https://github.com/westes/flex/">Flex</a> 是扫描器（scanner）生成工具，在编译器开发中，则可以作为词法分析器。<strong>Flex</strong> 通过<code>正则表达式</code>和部分C代码片段对输入文本进行扫描和匹配，并可以输出 Token 流。这些 Token 流可以作为下一级工具（如语法分析工具 <code>Bison</code>）的输入。<br>&emsp;&emsp; <strong>Flex</strong> 是由<code>ratfor</code>语言写成的<code>lex</code>工具演化而来的，被命名为 “Flex”，意为 “快速词法分析器生成程序”（Fast Lexical Analyzer Generator）。</p>
<span id="more"></span>

<h2 id="结构规范"><a href="#结构规范" class="headerlink" title="结构规范"></a>结构规范</h2><p>flex 程序由三部分构成：定义部分、规则部分和用户子例程（subroutine）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">// C头文件 或 变量声明</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">...定义...</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">...规则...</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">...用户子例程...</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>微型语言</tag>
      </tags>
  </entry>
  <entry>
    <title>vim配置及命令手册</title>
    <url>/2022/04/29/vim%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;vim是著名编辑器<code>vi</code>的变种，相比<code>vi</code>而言，提供了更多扩展，包括插件结构等。vim可以打造成IDE前端，但在Unix&#x2F;Linux环境中，标准的IDE并不是开发人员的首选；而可以灵活整合各种语言和工具的vim与<code>emacs</code>则是Unix&#x2F;Linux下开发人员的主要选择。<br>&emsp;&emsp;下文中的快捷键都可以重新绑定，但默认的绑定设置大部分都是最方便的选择，遵循传统可以有利于协作开发。<br>&emsp;&emsp;<strong>下文中快捷键中带<code>+</code>号的组合键代表同时按下，不带<code>+</code>号的顺序按下。组合键有些会用空格分隔，这样做是为了使得描述更清晰直接，此时空格并不是组合键的一部分；如果有些快捷键中包含空格，下文会以<code>&lt;Space&gt;</code>来表示。另外，<code>（n）</code>表示实际的按键是整数数字，而不是字母<code>n</code>。</strong></p>
<span id="more"></span>


<h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><ul>
<li><p><strong>光标移动：</strong></p>
<p><code>h</code>或<code>&lt;Left&gt;</code> ：向左移动一个字符<br><code>j</code>或<code>&lt;Down&gt;</code> ：向下移动一行<br><code>k</code>或<code>&lt;Up&gt;</code> ：向上移动一行<br><code>l</code>或<code>&lt;Right&gt;</code> ：向右移动一个字符<br><code>(n) &lt;方向键&gt;</code>：（顺序按下）多字符（行）移动<br><code>(n) &lt;Space&gt;</code> ：光标向右移动n个字符<br><code>(n) &lt;Enter&gt;</code> ：向下移动 n 行<br><code>0</code>或<code>&lt;Home&gt;</code>：移动到行首<br><code>$</code>或<code>&lt;End&gt;</code>：移动到行尾<br><code>&lt;Ctrl&gt;</code> + <code>f</code>：屏幕向下移动一页，相当于<code>&lt;Page Down&gt;</code><br><code>&lt;Ctrl&gt;</code> + <code>b</code>：屏幕向上移动一页，相当于<code>&lt;Page Up&gt;</code><br><code>&lt;Ctrl&gt;</code> + <code>d</code>：屏幕向下移动半页<code> </code><Ctrl><code>+</code>o<code>：屏幕向上移动半页</code><br><code>&lt;CTRL&gt;</code> + <code>O</code>：调整到上一次光标所在的行号上，即往后跳转<br><code>&lt;CTRL&gt;</code> + <code>i</code>：调整到jump list中当前记录的下一个记录的行号上，即往前调整<br><code>(n) &lt;Space&gt;</code> ：光标向右移动n个字符<br><code>H</code>：移动到屏幕最上方行的行首<br><code>M</code>：移动到屏幕中央行的行首<br><code>L</code>：移动到屏幕最下方行的行首<br><code>G</code>：移动到文档的最后一行<br><code>(n) G</code>：移动到文档的第 n 行<br><code>gg</code>或<code>1G</code>：移动到档案的第 1 行</p>
</li>
<li><p><strong>搜寻与替代：</strong></p>
<p><code>/word</code> ： 向光标之下搜寻匹配 word 的字符串<br><code>? word</code>： 向光标之上搜寻匹配 word 的字符串<br><code>n</code>：在上次的搜寻结果中跳到下一个匹配的字符串<br><code>N</code>：在上次的搜寻结果中跳到前一个匹配的字符串，与<code>n</code>相反<br><code>:[n1],[n2]s/word1/word2/[g][c]</code>：替换从n1行到n2行之间所有行的第一个word1匹配为word2（如果替换命令的最后部分选择 <code>g</code>，则替换该行所有的匹配），如果没有指定n1，n2，则作用于当前行，如果n2为<code>$</code>，则代表最后一行。<br><code>:%s/word1/word2/[g][c]</code>：对每一行的word1匹配进行替换<br><code>:s#word1/#word2/#</code>：<code>#</code>为命令的分隔符，<code>\</code>会被解析为关键词的一部分</p>
</li>
<li><p><strong>删除、粘贴与复制</strong></p>
<p><code>x</code>，<code>X</code>：在当前行中，<code>x</code>为向后删除一个字符，<code>X</code>为向前删除一个字符<br><code>(n) x</code>：连续向后删除 n 个字符<br><code>(n) X</code>：连续向前删除 n 个字符<br><code>dd</code>：删除当前行<br><code>(n) dd</code>：删除从当前行往下的n行（包括当前行）<br><code>d1G</code>或<code>d gg</code>：删除从当前行向上到第一行的所有数据<br><code>dG</code>：删除从当前行向下到最后一行的所有数据<br><code>d$</code>：删除当前行从光标所在处到行尾的所有字符<br><code>d0</code>：删除当前行从光标到行首的所有字符<br><code>:reg</code> 查看当前寄存器的内容<br><code>yy</code>：复制当前行存储到<code>&quot;</code>和<code>0</code>号寄存器（）<br><code>&quot;+yy</code>：<strong>复制当前行存储到<code>+</code>号寄存器（对应于系统粘贴板）</strong><br><code>&quot;+p</code>：<strong>粘贴系统粘贴板的内容</strong><br><code>(n) yy</code>：复制往下多行<br><code>y1G</code>，<code>yG</code>，<code>y0</code>，<code>y$</code>：分别与<code>d</code>开头的组合键意义相对<br><code>p</code>，<code>P</code>：<code>p</code>为将<code>reg &quot;</code>或<code>reg 0</code>的数据复制到当前行的下一行，而<code>P</code>则复制到当前行的上一行<br><code>J</code>：将当前行与下一行连接为一行<br><code>u</code>：递归撤回前一个动作<br><code>&lt;Ctrl&gt;</code>+<code>r</code>：与<code>u</code>相反，重新执行前一个动作<br><code>.</code>：重新执行前一个动作</p>
</li>
<li><p><strong>指令列</strong>：<br><code>:w</code> ：写入<br><code>:w!</code>：强制写入<br><code>:q</code>：退出<br><code>:q!</code>：强制退出，不保存<br><code>:wq</code>：保存后退出<br><code>ZZ</code>：若文档没有修改，则不保存退出，否则，保存后退出<br><code>:w [filename]</code>：另存为其他文件<br><code>:n1,n2 w [filename]</code>：将n1行到n2行之间的所有内容写入到另一个文件中<br><code>:r [filename]</code>：从当前行的下一行处插入另一个文件的内容<br><code>:! (Command)</code>：执行shell命令</p>
</li>
<li><p><strong>格式化:</strong></p>
<p><code>gg=G</code>：全文格式化<br><code>(n)g=(m)G</code>：格式化第n行到第m行</p>
</li>
</ul>
<h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><ul>
<li><strong>切换到插入模式</strong>：<br><code>i</code>，<code>I</code>：<code>i</code>从光标所在处插入，<code>I</code>从当前行第一个非空格符开始插入<br><code>a</code>，<code>A</code>：<code>a</code>从光标所在处的下一个字符处插入，<code>A</code>从当前行的行尾开始插入<br><code>o</code>，<code>O</code>：<code>o</code>从当前行的下一行插入新行，<code>O</code>从当前行的上一行处插入新行<br><code>R</code>: 进入取代模式，直到按下<code>&lt;Esc&gt;</code><br><code>&lt;Esc&gt;</code>或<code>&lt;Ctrl&gt;</code>+<code>c</code>：退出编辑模式</li>
<li><strong>编辑过程</strong>：<br><code>&lt;Alt&gt;</code> + <code>i</code>：光标向左移动一个字符</li>
</ul>
<h3 id="块选择模式"><a href="#块选择模式" class="headerlink" title="块选择模式"></a>块选择模式</h3><p><code>v</code>：字符选择，将光标所经过的地方反白选择<br><code>V</code>：行选择<br><code>&lt;Ctrl&gt;</code>+<code>v</code>：区块选择<br><code>y</code>，<code>d</code>：对反白的地方进行复制或者删除</p>
<ul>
<li><strong>批量注释:</strong> 首先<code>&lt;Ctrl&gt;</code>+<code>v</code>进入区块选择模式，然后移动光标选择要注释的行，再按<code>I</code>进入行首插入模式，输入注释符，完成后按<code>&lt;Esc&gt;</code>退出。</li>
</ul>
<h3 id="多窗口模式"><a href="#多窗口模式" class="headerlink" title="多窗口模式"></a>多窗口模式</h3><p><code>:sp [filename]</code>：水平开启新窗口<br><code>:vsp [filename]</code>：垂直开启新窗口<br><code>[Ctrl]</code>+<code>w</code> <code>j</code> ：切换窗口<br><code>[Ctrl]</code>+<code>w</code> <code>k</code> ：切换窗口</p>
<h3 id="多档案编辑"><a href="#多档案编辑" class="headerlink" title="多档案编辑"></a>多档案编辑</h3><p><code>:n</code>： 切换到下一个文档<br><code>:N</code>：切换到上一个文档<br><code>:buffers</code>：查看当前打开buffer<br><code>:badd [filename]</code>：打开新文件到buffer<br><code>:bdelete</code>：删除buffer，关闭打开文件<br><code>:bnext</code>：切换到下一个buffer</p>
<h3 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h3><p>配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set tags=tags;</span><br><span class="line">set autochdir</span><br></pre></td></tr></table></figure>
<p>命令:<br><code>[Ctrl]</code> + <code>]</code>：跳转<br><code>[Ctrl]</code> + <code>T</code>：回跳</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>《古今数学思想I》读书笔记</title>
    <url>/2019/09/11/%E3%80%8A%E5%8F%A4%E4%BB%8A%E6%95%B0%E5%AD%A6%E6%80%9D%E6%83%B3I%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><em>本文主要是早期阅读时的摘抄笔记，只可见该著作之冰山一角。</em></p>
<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>&emsp;&emsp;历史告诉我们，一个科目的发展是由汇集不同方面的成果点滴积累而成的。我们也知道，常常需要几十年甚至是几百年的努力才能迈出有意义的几步。不仅这些学科并没有锤炼得天衣无缝，甚至是那些已经取得的成就，也常常只是个开始，许多缺陷有待填补，或者真正重要的扩展还有待创造。</p>
<span id="more"></span>
<p>&emsp;&emsp;课本中的斟字酌句的叙述，未能表现出创造过程中的斗争和挫折，以及在建立一个可观的结构前，数学家所经历的漫长艰苦的道路。学生一旦认识到这一点，他将不仅获得真知灼见，还将获得顽强地追究他所攻问题的勇气，并且不会因为自己的工作并非完美无缺而感到颓丧。</p>
<h3 id="7-希腊人对自然形成理性观点的过程"><a href="#7-希腊人对自然形成理性观点的过程" class="headerlink" title="7.希腊人对自然形成理性观点的过程"></a>7.希腊人对自然形成理性观点的过程</h3><p>&emsp;&emsp;古希腊人产生了新的信念：认为自然界是有秩序的并始终按照一定的方案运行。更有甚者，他们深信人的智慧是强有力的甚至是至高无上的，人不仅可以探索自然界的道理甚至还能预知它将会出现的事态。<br>&emsp;&emsp;（爱奥尼亚学派）他们用合理化的解释来代替诗人的想象和不加分析的传说，并且他们用理性来辩护他们的主张。这些人至少敢于凭他们的理性来面对宇宙，而不肯依赖与神，灵，鬼，怪，天使及其他神秘的力量。</p>
<h3 id="8-希腊世界的衰替"><a href="#8-希腊世界的衰替" class="headerlink" title="8. 希腊世界的衰替"></a>8. 希腊世界的衰替</h3><p>&emsp;&emsp;人们把数学成为抽象化科学归功于希腊人。希腊人坚持要演绎证明。……需要做演绎推理的决心是同人类在其他一切领域的习惯做法完全违背的；它实际上几乎像一件不合理的事情，因为人类凭经验，归纳，类比和实验已经获得了那么多可靠的知识。但希腊人需要真理，并觉得只有用毋庸置疑的演绎推理法才能获得真理。<br>&emsp;&emsp;……希腊人还表现出一种为创新者少见的细致精神。他们认识到概念必须彼此没有矛盾，以及不能用不存在的图形来搞出前和一致的逻辑结构，这一切显出他们几乎有超人的并且是空前的思想深度。<br>&emsp;&emsp;…….<br>&emsp;&emsp;希腊人把数学等同于物理世界的实质，并在数学里看到关于宇宙结构和设计的最终真理。他们建立了数学与研究自然真理之间的联盟，这在以后便成为现代科学基础本身。其次，他们对自然的合理化认识推进到足够深远的程度，使他们能够牢固树立一种信念，感到宇宙确实是按数学规律设计的，是有条理，有规律并且能被人所认识的。<br>&emsp;&emsp;…… 凡鄙视数学家以及科学家高度理论性工作并斥其为无用的人民，他们对重要实际成果如何产生是盲目无知的。</p>
<h3 id="9-印度和阿拉伯的数学"><a href="#9-印度和阿拉伯的数学" class="headerlink" title="9. 印度和阿拉伯的数学"></a>9. 印度和阿拉伯的数学</h3><p>&emsp;&emsp;阿拉伯人钻研数学主要是为了推进他们所从事的几门重要的科学，而不是为了数学本身。他们也不搞为科学而研究科学的事。他们对希腊人为了弄懂自然界的数学设计或对中世界欧洲人为了领悟上帝之道这种目标是不感兴趣的……他们是为了要支配自然界而从事科学研究的。<br>&emsp;&emsp;…… （印度人和阿拉伯人）这两个民族所创造的文明总的来说都是缺乏批判精神的，尽管阿拉伯人对欧几里得著作曾写过评注。另外这两个文明都是偏重实际的，实际需要确乎要求提供数量结果，而这就得用算法和代数来求出。<br>&emsp;&emsp;新思想只有在自由和勇敢的直观启发下才能产生。</p>
<h3 id="10-欧洲中世纪时期"><a href="#10-欧洲中世纪时期" class="headerlink" title="10. 欧洲中世纪时期"></a>10. 欧洲中世纪时期</h3><p>&emsp;&emsp;数学水平之所以底，主要原因是对物理世界缺乏兴趣。当时在欧洲占统治地位的基督教规定了它自身的目标，价值和生活方式。主要关心精神生活，因而认为出于好奇心或实用目的而探索自然的工作是浮薄不足道的。基督教乃至后期的希腊哲学界如斯多葛派，伊壁鸠鲁派和新柏拉图派都强调要把心灵提高到超越肉体和物质之上，并为灵魂做好准备，以便死后去过天国的生活。<br>&emsp;&emsp;奥古斯丁：”从圣经以外获得的任何知识，如果它是有害的，理应加以排斥；如果它是有益的，那它是会包含在圣经里的。” 这段话虽然不足以代表奥古斯丁，却足以代表中世纪早期的人对研究自然的态度。<br>&emsp;&emsp;直到1100年，中世纪时期没有在知识领域里产生任何大的文化。它的知识状态是思想一律，教条主义，神秘主义，信赖权威，不断向权威著作求教，进行分析和加以评述。倾向于神秘主义的结果使人把含糊其词的思想奉为现实甚至接受为宗教真理。仅存的那一点点科学是呆板无生气的。神学统辖了所有的学问，教会神甫能编造万有知识体系。但除了包含在基督教义中的以外，他们不去寻思或追求任何别的原理。<br>&emsp;&emsp;数学显然不能在一个只重世务或只信天国的文明中繁荣滋长，我们可以看到，数学在一个自由的学术氛围中最能获得成功，那里既能对物理世界产生的概念发生兴趣，又有人愿意从抽象方面去思考由这些问题所引起的概念，而不计其是否能获得眼前或者实际的利益。自然界是产生概念的温床，然后必须对概念本身进行研究。<br>&emsp;&emsp;反过来，能对自然获得新的观点，对它有更丰富，更广泛，更强有力的理解，而这又产生更深刻的数学工作。</p>
<h3 id="文艺复兴"><a href="#文艺复兴" class="headerlink" title="文艺复兴"></a>文艺复兴</h3><p>&emsp;&emsp;革命的影响是十分广泛且连续不断的，几乎遍及欧洲每个国家每个城市的战争乃是政治变革的原因。…… 中世纪后期，意大利获得了大量的财富；…… 在15世纪，希腊的著作大量进入欧洲；……大约在1450年，古登堡发明了活版印刷，加速了知识传播；……罗盘和火药的引进是有重大意义的；……由于制造业，矿业，大规模的农业以及各种贸易的大量发展，一个新的经济时代开始了。…… 和埃及，希腊及罗马的奴隶社会以及中世纪的封建农奴制社会相比较，新社会拥有一个不断增大的自由手工业和自由劳动者阶级。……为了改进生产方法和材料的质量，资本主义经济竞争也促使人们去直接研究一些物理现象和因果关系。……..可以肯定，每当物理的解释被证明比神学的解释更为有用的时候，神学的解释就被人们抛弃了。…….. 通过地理勘察以及进一步的商业贸易，使得人们接触到了异地各种各样新的知识，这些知识对中世纪的教条提出了挑战并激发了想象力。…….也引起对教会的科学和宇宙学说的可靠性的怀疑，对教会压制实验和压制人们思考新秩序所产生的问题的反抗。</p>
<h3 id="达芬奇"><a href="#达芬奇" class="headerlink" title="达芬奇"></a>达芬奇</h3><p>&emsp;&emsp;他对这些读书人是这样描写的：”他们高傲自大，卖弄学问，并非以自己的钻研所得而只是以背诵别人的成果来夸耀自己，他们只是别人学问的朗诵者和吹鼓手”。<br>“如果你不立足于大自然这个很好的基础，你的劳动将无裨于人，无益于己。”<br>“在以数学为依据的科学的研究中，如果有些人不直接向自然界请教而是向书本的作者请教，那么，他就不是自然界的儿子而是孙子了。”</p>
<h3 id="弗郎西斯培根"><a href="#弗郎西斯培根" class="headerlink" title="弗郎西斯培根"></a>弗郎西斯培根</h3><p>&emsp;&emsp;所有的知识都是通过观察开始的。然后，他作出了非凡的贡献，就是坚持‘逐步和持续不断地归纳’以代替草率的一般结论。他说：“寻找和发现真理有两条路，也只有两条路。其一，通过感觉和特例飞跃到普遍的公理，然后通过这些原则和一劳永逸的真理发明和判断一些派生的公理。另一种方法是感觉和特例收集公理，不断地逐步上升，这样最后到达更普遍的公理；这后一种方法是真实的，但尚未有人试用过。”但它没有认识到科学必须通过测量才能得到定量的规律。弗朗西斯.培根虽然自己没有创造但却发出了关于实验方法的宣言。…… 让我们接近大自然并面对着它。我们不要搞杂乱的，偶然的试验，要让它成为系统的，彻底的和有一定方向的。数学应该是物理学的仆人。<br>&emsp;&emsp;他希望致知识与应用。他想以掌握自然来服务并造福于人类，而不是为博得学者的高兴和快乐。如他所说，科学应上升为公理然后又下降到应用。（促进理论与实践的结合）<br>&emsp;&emsp;对我们来说，现代科学开端之所以重要，当然在于它为数学的重大发展铺平了道路。它直接的效果是和具体问题相联系。<br>&emsp;&emsp;……长远的效果是现代数学在柏拉图“数学是现实的核心”的学说指引下，几乎完全是由具体的科学问题产生的（如微积分）。在研究自然并且得到包括观察和实验结果的规律这个新的方向的引导下，数学从哲学中分离出来并和物理科学联系在一起。对数学来说，进一步的后果是爆发了一个空前活跃和富有创造性的时期。</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《麦田里的守望者》读书笔记</title>
    <url>/2017/10/10/%E3%80%8A%E9%BA%A6%E7%94%B0%E9%87%8C%E7%9A%84%E5%AE%88%E6%9C%9B%E8%80%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><em>本文是早期阅读时的摘抄笔记</em></p>
<p>&emsp;&emsp;一个不成熟男子的标志是他愿意为某种事业英勇地死去，一个成熟男子的标志是他愿意为某种事业卑贱地活着。</p>
<span id="more"></span>


<p>&emsp;&emsp;我想象你这样骑马瞎跑。将来要是摔下来，可不是玩儿的——那是很特殊、很可怕的一跤。摔下来的人，都感觉不到也听不见自己着地。只是一个劲儿往下摔。这整个安排是为哪种人作出的呢？只是为某一类人，他们在一生中这一时期或那一时期，想要寻找某种他们自己的环境无法提供的东西。或者寻找只是他们认为自己的环境无法提供的东西。于是他们停止寻找。他们甚至在还未真正开始寻找之前就已停止寻找。</p>
<p>&emsp;&emsp;你一旦经受了所有的文孙先生的考验，你就可以学到越来越多的知识——那是说，只要你想学，肯学，有耐心学——你就可以学到一些你最最心爱的知识。其中的一门知识就是，你将发现对人类的行为感到惶惑、恐惧、甚至恶心的，你并不是第一个。在这方面你倒是一点也不孤独，你知道后一定会觉得兴奋，一定会受到鼓励。历史上有许许多多人都象你现在这样，在道德上和精神上都有过访捏的时期。幸而，他们中间有几个将自己彷徨的经过记录下来了。你可以向他们学习——只要你愿意。正如你有朝一日如果有什么贡献，别人也可以向你学习。这真是个极妙的轮回安排。而且这不是教育。这是历史。这是诗。</p>
<p>&emsp;&emsp;只有受过教育的和有学问的人才能够对这世界作出伟大的贡献。这样说当然不对。不过我的确要说，受过教育的和有学问的人如果有聪明才智和创造能力——不幸的是，这样的情况并不多——他们留给后世的记录比起那般光有聪明才智和创造能力的人来，确实要宝贵得多。他们表达自己的思想更清楚，他们通常还有热情把自己的思想贯彻到底。而且——最最重要的一点——他们十有九个要比那种没有学问的思想家谦恭得多。</p>
<p>&emsp;&emsp;学校教育还能给你带来别的好处。你受这种教育到了一定程度，就会发现自己脑子的尺寸，以及什么对它合适，什么对它不合适。过了一个时期，你就会心里有数，知道象你这样尺寸的头脑应该具有什么类型的思想。主要是，这可以让你节省不少时间，免得你去瞎试一些对你不合适、不贴切的思想。你惺僵就会知道你自己的正确尺寸，恰如其分地把你的头脑武装起来。</p>
<p>&emsp;&emsp;“不管怎样，我老是在想象，有那么一群小孩子在一大块麦田里做游戏。几千几万个小孩子，附近没有一个人——没有一个大人，我是说——除了我。我呢，就站在那混帐的悬崖边。我的职务是在那儿守望，要是有哪个孩子往悬崖边奔来，我就把他捉住——我是说孩子们都在狂奔，也不知道自己是在往哪儿跑，我得从什么地方出来，把他们捉住。我整天就干这样的事。我只想当个麦田里的守望者。我知道这有点异想天开，可我真正喜欢干的就是这个。我知道这不象话。”</p>
<p>&emsp;&emsp;最后，我打定主意，决计远走高飞。我决意不再回家，也不再到另一个混帐学校里去念书了。我决定再见老菲芘一面，向她告别，把她过圣诞节的钱还她，随后我一路搭人家的车到西部去。我想先到荷兰隧道不花钱搭一辆车，然后再搭一辆，然后再一辆、再一辆，这样不多几天我就可以到达西部，那儿阳光明媚，景色美丽；那儿没有人认识我，我可以随便找个工作做。我揣摩自己可以在一个加油站里找个工作，给人家的汽车加油什么的。不过我并不在乎找到的是什么样的工作，反正只要人家不认识我、我也不认识人家就成。我又想起了一个主意，打算到了那儿，就装作一个又袭又哑的人。这样我就可以不必跟任何人讲任何混帐废话了。要是有人想跟我说什么，他们就得写在纸上递给我。用这种方法交谈，过不多久他们就会腻烦得要命，这样我的下半辈子就再也用不着跟人谈话了。人人都会认为我是个可怜的又聋又哑的杂种，谁都不会来打扰我。他们会让我把汽油灌进他们的混帐汽车，他们会给我一份工资，我用自己挣来的钱造一座小屋，终身住在里面。我准备把小屋造在树林旁边，而不是造在树林里面，因为我喜欢屋里一天到晚都有充足的阳光。一日三餐我可以自己做了吃，以后我如果想结婚什么的，可以找一个同我一样又聋又哑的美丽姑娘。我们结婚以后，她就搬来跟我一起佐在我的小屋里，她如果想跟我说什么话，也得写在一张混帐纸上，象别人一样。</p>
<p>&emsp;&emsp;我们如果生了孩子，就把他们送到什么地方藏起来。我们可以给他们买许许多多书，亲自教他们读书写字。</p>
<p>&emsp;&emsp;我要定出这么个规则，凡是来看我的人，都不准在我家里做任何假模假式的事。谁要是想在我家里作假，就马上请他上路。</p>
<p>&emsp;&emsp;嘿，雨开始下大了。是倾盆大雨，我可以对天发誓。所有做父母的、做母亲的和其他人等，全都奔过去躲到转台的屋檐下，免得被雨淋湿，可我依旧在长椅上坐了好一会儿。我身上都湿透了，尤其是我的脖子上和裤子上。我那顶猎人帽在某些部分的确给我挡住了不少雨，可我依旧淋得象只落汤鸡。不过我并不在乎。突然间我变得他妈的那么快乐，眼看着老菲芘那么一圈圈转个不停。我险些儿他妈的大叫大嚷起来，我心里实在快乐极了，我老实告诉你说。我不知道什么缘故。她穿着那么件蓝大衣，老那么转个不停，看去真他妈的好看极了。</p>
<p>&emsp;&emsp;老天爷，我真希望你当时也在场——</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《黑客与画家》读书笔记</title>
    <url>/2017/10/22/%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><em>本文是早期读书摘抄笔记2017&#x2F;10&#x2F;22</em></p>
<h3 id="好设计是简单的设计"><a href="#好设计是简单的设计" class="headerlink" title="好设计是简单的设计"></a>好设计是简单的设计</h3><p>&emsp;&emsp;当你被迫把东西做的很简单时，你就被迫直接面对真正的问题。当你不能用表面的装饰交差时，你就不得不做好真正的本质部分。</p>
<span id="more"></span>


<h3 id="好设计是永不过时的设计"><a href="#好设计是永不过时的设计" class="headerlink" title="好设计是永不过时的设计"></a>好设计是永不过时的设计</h3><p>&emsp;&emsp;以永不过时作为目标是一种帮助自己找到最佳答案的方法:如果你不愿意别人的答案取代你的答案，你就只好自己做出最佳答案。<br>&emsp;&emsp;以永不过时作为目标也是一种避开时代风潮的方法。</p>
<h3 id="好设计是解决主要问题的设计"><a href="#好设计是解决主要问题的设计" class="headerlink" title="好设计是解决主要问题的设计"></a>好设计是解决主要问题的设计</h3><p>&emsp;&emsp;答案可以不断改进，同样，问题本身也可以不断改进。</p>
<h3 id="好设计是启发式的设计"><a href="#好设计是启发式的设计" class="headerlink" title="好设计是启发式的设计"></a>好设计是启发式的设计</h3><p>&emsp;&emsp;在建筑学和设计学中，这条原则意味着，一栋建筑或一个物品应该允许你按照自己的愿望来使用。在软件业中，这条原则意味着，你应该为用户提供一些基本模块，使得他们可以随心所欲自由组合，就像玩乐高积木那样。</p>
<h3 id="好的设计通常是有点趣味性的设计"><a href="#好的设计通常是有点趣味性的设计" class="headerlink" title="好的设计通常是有点趣味性的设计"></a>好的设计通常是有点趣味性的设计</h3><p>&emsp;&emsp;好的设计并非一定有趣，但是很难想象完全无趣的设计会是好的设计。</p>
<h3 id="好设计是艰苦的设计"><a href="#好设计是艰苦的设计" class="headerlink" title="好设计是艰苦的设计"></a>好设计是艰苦的设计</h3><p>&emsp;&emsp;在困难地点和预算不足的条件下，建筑师就只能做出很简练的设计。当解决难题成为压倒一切的任务时，那些流行样式和华丽装饰就被抛到一边去了。<br>&emsp;&emsp;你需要的是咬牙向前冲刺的痛苦，而不是脚被钉子扎破的痛苦。<br>&emsp;&emsp;功能应当决定形式。</p>
<h3 id="好设计是看似容易的设计"><a href="#好设计是看似容易的设计" class="headerlink" title="好设计是看似容易的设计"></a>好设计是看似容易的设计</h3><p>&emsp;&emsp;但看似容易的设计，背后都需要大量的练习。</p>
<h3 id="好设计是对称的设计"><a href="#好设计是对称的设计" class="headerlink" title="好设计是对称的设计"></a>好设计是对称的设计</h3><p>&emsp;&emsp;对称也许只是简洁性的一种体现，但是它十分重要。</p>
<h3 id="好设计是模仿大自然的设计"><a href="#好设计是模仿大自然的设计" class="headerlink" title="好设计是模仿大自然的设计"></a>好设计是模仿大自然的设计</h3><p>&emsp;&emsp;并不是说模仿大自然这种行为本身有什么好，而是说大自然在长期的进化中已经解决了很多设计问题。所以，如果你的设计与大自然很接近，那基本上不会很差。</p>
<h3 id="好设计是一种再设计"><a href="#好设计是一种再设计" class="headerlink" title="好设计是一种再设计"></a>好设计是一种再设计</h3><p>&emsp;&emsp;很少有人一次就可以把事情做对。专家的做法是先完成一个早期原型，然后提出修改计划，最后再把原型扔掉。<br>&emsp;&emsp;你应该培养对自己的不满。并且不要把犯错误看成灾难，要勇于承认、勇于改正。犯错误是很正常的事情。</p>
<h3 id="好设计是能够复制的设计"><a href="#好设计是能够复制的设计" class="headerlink" title="好设计是能够复制的设计"></a>好设计是能够复制的设计</h3><p>&emsp;&emsp;有时候把事情做对，比原创更重要。<br>&emsp;&emsp;但也不要满足于一味的模仿。<br>&emsp;&emsp;最伟大的大师最终会达到一种超脱自我的境界。他们一心想找到正确答案，如果别人已经回答出了一部分，那就没理由不拿来用。他们足够自信地使用他人的成果，完全不担心因此丧失自己的特点。</p>
<h3 id="好设计常常是奇特的设计"><a href="#好设计常常是奇特的设计" class="headerlink" title="好设计常常是奇特的设计"></a>好设计常常是奇特的设计</h3><p>&emsp;&emsp;如计算机中的Lisp语言。<br>&emsp;&emsp;但它是结果，而不是原因。爱因斯坦并不想让相对论变得很奇特，他只想找出真理，是真理本身显得很奇特。<br>&emsp;&emsp;你最后发展出来的风格是自然而然的结果。</p>
<h3 id="好设计是成批出现的"><a href="#好设计是成批出现的" class="headerlink" title="好设计是成批出现的"></a>好设计是成批出现的</h3><p>&emsp;&emsp;推动人才成批出现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。<br>&emsp;&emsp;互相激励比天赋更重要。<br>&emsp;&emsp;在历史的任何时刻都有一些热点项目，一些团体在这些项目上做出了伟大的成绩。如果你远离这些中心，几乎不可能单靠自己取得伟大成果。在某种程度上，你个人最多可以对趋势产生一定的影响，但是你不可能决定趋势，实际上是趋势决定了你。（或许有人办得到，但是米兰的达芬奇显然没有办到。）</p>
<h3 id="好设计常常是大胆的设计"><a href="#好设计常常是大胆的设计" class="headerlink" title="好设计常常是大胆的设计"></a>好设计常常是大胆的设计</h3><p>&emsp;&emsp;在任何一段历史中，人们都会把某些荒诞的东西当作正确的，并且深信不疑，以至于一旦你出言质疑，就有被排挤或者被暴力伤害的危险。<br>&emsp;&emsp;今天的实验性错误是明天的新理论。<br>&emsp;&emsp;大多数做出优美成果的人好像只是为了修正他们眼中的丑陋。伟大作品的出现常常来源于某人看到一样东西后，心想我能做得比这更好。<br>&emsp;&emsp;单单是无法容忍丑陋的东西还不够，只有对这个领域非常熟悉，你才可能发现哪些地方可以动手改进。你必须锻炼自己。只有在成为某个领域的专家之后，你才会听到心里有一个细微的声音说:“这样解决太糟糕了！一定有更好的选择。”不要忽视这种声音，要培育它们。优秀作品的秘诀就是:非常严格的品味，再加上贯实现这种品味的能力。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>伯特兰罗素：《我为什么活着》摘抄</title>
    <url>/2021/01/09/%E4%BC%AF%E7%89%B9%E5%85%B0-%E7%BD%97%E7%B4%A0%EF%BC%9A%E3%80%8A%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B4%BB%E7%9D%80%E3%80%8B%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<p><em>该文是其自传序言，可‘感染’其情感和精神之一面。</em></p>
<span id="more"></span>
<p>&lt;正文&gt;<br>&emsp;&emsp;对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情，这三种纯洁但无比强烈的感情支配着我的一生。这三种感情就像飓风一样，在深深的苦海上，肆意地把我吹来吹去，吹到濒临绝望的边缘。<br>&emsp;&emsp;我寻求爱情，首先因为爱情给我带来狂喜，它如此强烈，以致于我经常愿意为了几小时的欢愉而牺牲生命中的其他一切。我寻求爱情，其次是因为爱情解除孤寂——那是一颗震颤的心，在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊。我寻求爱情，最后是因为在爱情的结合中，我看到圣贤和诗人们所想象的仙境的神秘缩影。这就是我所寻求的，虽然它对人生似乎过于美好，然而最终我还是得到了它。<br>&emsp;&emsp;我以同样的热情寻求知识，我希望了解人的心灵。我希望知道星星为什么闪闪发光，我试图理解毕达哥拉斯的思想威力，即数字支配着万物流转。这方面我获得一些成就，然而并不多。<br>&emsp;&emsp;爱情和知识，尽可能地把我引上云霄，但同情心总把我带回尘世。痛苦的呼号的回声在我心中回荡，饥饿的儿童，被压迫者折磨的受害者，被儿女视为可厌负担的无助的老人，以及充满孤寂、贫穷和痛苦的整个世界，都是对人类应有生活的嘲讽。我渴望减轻这些不幸，但是我无能为力，而且我自己也深受其害。<br>&emsp;&emsp;这就是我的一生，我觉得我活着值得。如果有机会的话，我还乐意再活一次。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Clang/LLVM 构建 Linux 内核</title>
    <url>/2025/02/21/%E4%BD%BF%E7%94%A8Clang-LLVM%E6%9E%84%E5%BB%BALinux%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 内核是用 C 语言编写的，但其并不完全符合 <code>ANSI C</code> 标准，实际上，内核开发者使用的 C 语言涵盖了 ISO C99 标准和 GNU C 扩展特性，这使得内核的构建长期依赖 gcc。</p>
<p><code>Clang</code> 和 <code>LLVM</code> 的持续性工作改变了这种现状，使得其可作为构建内核的替代工具。一些发行版，例如 Android、ChromwOS、OpenMandriva 等都在使用 Clang 编译的内核。</p>
<p>关于 LLVM 的简单介绍，参考 <a href="/2022/11/06/LLVM-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" title="LLVM 项目介绍">[LLVM 项目介绍]</a>。Clang 是 LLVM 的前端，支持 C 语言和内核所需要的 GNU C 扩展。</p>
<span id="more"></span>

<h2 id="使用-LLVM-构建"><a href="#使用-LLVM-构建" class="headerlink" title="使用 LLVM 构建"></a>使用 LLVM 构建</h2><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p>安装 LLVM 和 对应的链接器 lld： <code>$ sudo apt-get install clang lld</code>，该命令会自动安装所依赖的其他软件包。</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=clang LD=ld.lld AR=llvm-ar NM=llvm-nm STRIP=llvm-strip \</span></span><br><span class="line"><span class="language-bash">  OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump READELF=llvm-readelf AS=llvm-as \</span></span><br><span class="line"><span class="language-bash">  HOSTCC=clang HOSTCXX=clang++ HOSTAR=llvm-ar HOSTAS=llvm-as HOSTLD=ld.lld</span></span><br></pre></td></tr></table></figure>

<p>目前支持的架构参考 <a href="https://docs.kernel.org/translations/zh_CN/kbuild/llvm.html#id5">使用 Clang&#x2F;LLVM 构建 Linux</a>。</p>
<h2 id="使用-lldb-调试"><a href="#使用-lldb-调试" class="headerlink" title="使用 lldb 调试"></a>使用 lldb 调试</h2><p>安装 LLVM 的调试器 lldb </p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>编译器</category>
        <category>Linux Kernel</category>
        <category>LLVM Project</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Octave 编写机器学习应用原型</title>
    <url>/2025/02/23/%E4%BD%BF%E7%94%A8Octave%E7%BC%96%E5%86%99%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%94%E7%94%A8%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://octave.org/#">Octave</a> 是开源的科学数值计算工具，类似于 <code>matlab</code>，它的语言的语法绝大部分与 matlab 兼容。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>人工智能</category>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>关于计算机操作系统启动引导的总结</title>
    <url>/2018/04/02/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;对于现代CPU而言，当其上电启动时，必须知道指令在什么地方，这是很简单的道理。现代大多数计算机的做法是将这第一段程序放到称为BIOS的固件（存储材料大都为EEPROM或FLASH芯片）里，该程序会根据配置信息读取磁盘（或其他存储设备，例如外接USB）的特定分区里的程序代码并执行，逐渐启动操作系统的所有组件。</p>
<span id="more"></span>


<p>&emsp;&emsp;总之，在实际应用环境中，要综合考虑操作系统类型、固件类型以及磁盘分区类型这三个主要因素来部署解决 方案。</p>
<h3 id="方案一：-BIOS-MBR"><a href="#方案一：-BIOS-MBR" class="headerlink" title="方案一： BIOS + MBR"></a>方案一： BIOS + MBR</h3><h4 id="1-BIOS-Baisc-Input-output-System-②③"><a href="#1-BIOS-Baisc-Input-output-System-②③" class="headerlink" title="1. BIOS(Baisc Input&#x2F;output System)②③"></a>1. BIOS(Baisc Input&#x2F;output System)②③</h4><p>BIOS是IBM PC兼容机的固件接口（注意与UEFI的区分）。其主要程序包括：</p>
<p>a. 中断例程：处理硬件中断</p>
<p>b. 系统设置程序：该程序负责设置BIOS参数，并将这些参数存储在CMOS RAM芯片中。CMOS中还包含其他一些配置信息（如系统时间），计算机不通电时，由一块主板上的后背电池来维持其信息。</p>
<p>c. POST上电自检：将包括CPU、640K基本内存、1M以上的扩展内存、ROM、主板、 CMOS存贮器、串并口、显示卡、软硬盘子系统及键盘测试。自检中若发现问题，系统将给出提示信息或鸣笛警告。</p>
<p>d.引导程序：在完成POST自检后，BIOS将按照系统CMOS设置中的启动顺序搜寻软硬盘驱动器及CDROM、网络服务器等有效的启动驱动器 ，读入操作系统引导记录，然后将系统控制权交给引导记录，由引导记录完成系统的启动。</p>
<h4 id="2-MBR-Main-Boot-Record-①"><a href="#2-MBR-Main-Boot-Record-①" class="headerlink" title="2. MBR(Main Boot Record) ①"></a>2. MBR(Main Boot Record) ①</h4><p>&emsp;&emsp;通常我们将包含MBR的扇区称为主引导扇区（位置为０&#x2F;0&#x2F;1扇区，大小为512字节），其组成有三部分：</p>
<p>a. MBR（占用446字节），它用于在硬盘启动时将系统控制转给用户指定的并在分区表里登记的操作系统。现代启动装载程序的大小通常超出了 MBR 空间所能容纳的范围，因此必须采用多阶段设计，其中 MBR 部分只知道如何从其他位置加载下一阶段。</p>
<p>b. 磁盘分区表（DPT），由4个分区表项组成（每个16字节）。对于扩展分区类型，其16字节中包含的是其包含的第一个逻辑分区的信息，各逻辑分区呈链表结构。</p>
<p>c. 结束标志（占用2个字节），其值为0xAA55。</p>
<p>MBR程序段的执行流程：</p>
<p>a. 检查硬盘分区表是否完好。<br>b. 在分区表中查找可引导的活动分区。<br>c. 将活动分区的第一逻辑扇区装入内存。因此可以得知，当执行MBR程序段时，BIOS的任务已经结束了。</p>
<p>&emsp;&emsp;一定要清楚的是，MBR程序段执行完成后，跳向哪里？应该有两个方向，一个是活动分区内操作系统的内核文件；另一个就是活动分区内的启动扇区（boot sector），进行任务转交。（如果使用GRUB，第三个方向应该是GRUB的stage1.5）<br>无奈的时，Windows在安装时会覆盖掉原有的MBR和自己所在分区的启动扇区，意思是‘你们别想启动其他系统！！！’，不过多重启动的方法多的是。其他具体细节见参考资料①。</p>
<h4 id="3-GRUB所做的事情③"><a href="#3-GRUB所做的事情③" class="headerlink" title="3. GRUB所做的事情③"></a>3. GRUB所做的事情③</h4><p>&emsp;&emsp;Grub（下文都指GRUB 2）通常被使用于现代Linux系统的引导启动，但它很强大，支持多系统引导，且可以通过chain load引导专有系统（例如Windows）。另外，对于Linux系统，其还可以选择不同的kernel来引导。<br>下文便于说明，将GRUB所做的事情分为几个stage：</p>
<p>a. stage 1<br>通常stage 1就是MBR中的引导代码，具体对应的文件为boot.img。由于它太小，所以不够智能，也不能识别文件系统，而我们的内核文件是基于文件系统的，因此我们需要更多的代码，就是将控制权交给下一阶段。</p>
<p>b. stage 1.5<br>stage1.5位于磁盘主引导扇区和第一分区之间。这部分空间因为历史原因被保留，而GRUB巧妙地抓住这个空子（也许是糟糕的设计！！！）。有些磁盘的第一分区起始位置为第63扇区（有的则为第2048扇区，比如笔者所用的系统），因此stage1.5所能使用的空间大小为62*512 &#x3D; 31722 bytes，（或许）足够容纳该阶段的文件core.img。stage1.5 现在可以识别一些文件系统，包括EXT，FAT，ntfs等。最后stage1.5就根据其支持的文件系统，寻找satge2的&#x2F;boot目录文件并载入，将控制权转交。</p>
<p>c. stage 2<br>该阶段所有文件都位于&#x2F;boot&#x2F;grub2（或者&#x2F;boot&#x2F;grub）目录（和stage1&#x2F;1.5一个单独的image文件不同）。主要工作是定位并载入被选择的内核文件，并将控制权转交给内核。内核及相关文件位于&#x2F;boot目录下，内核文件几乎都以vmlinuz开头来命名，可以有多个。</p>
<p>d. kernel<br>在&#x2F;boot目录下，除了内核文件，还包括initrd.image（initial RAM disk）和System.map文件等。initrd里包含各种可执行程序和驱动程序，用于挂载实际的根文件系统,initrd存在的原因等信息具体参考资料④。关于查看和创建initrd的信息具体参考资料⑤及⑥。在grub命令行里可以通过使用kernel和initrd来指定内核与initrd.img。</p>
<p>e.关于 <code>initrd</code><br><code>initrd</code>使得内核可以简单使用 <code>Ramdisk</code> 的能力，包括：</p>
<ul>
<li>格式化一个 <code>ramdisk</code></li>
<li>加载文件系统内容到 <code>ramdisk</code></li>
<li>将<code>ramdisk</code>作为根文件系统</li>
</ul>
<p>在内核接管 CPU 后，然后内核调用 <code>init()</code> 函数（不是后来的 init 进程）；然后调用 <code>initrd_load()</code> 在内存中加载 initrd 根文件系统（还句话说，就是将一部分内存虚拟化磁盘来使用，并在这个虚拟磁盘上创建根文件系统）；然后调用 <code>mount_root()</code> 函数来创建真正的根文件系统，并进入该目录中；最后，调用<code>run_init_process()</code>函数，使用<code>execve</code>启动 <code>init</code> 进程。</p>
<h3 id="方案二：GPT（GUID-Partition-Table）"><a href="#方案二：GPT（GUID-Partition-Table）" class="headerlink" title="方案二：GPT（GUID Partition Table）"></a>方案二：GPT（GUID Partition Table）</h3><p>&emsp;&emsp;GPT是UEFI规范的一部分，但仍然可以运用到BIOS系统中。它作为MBR的替代解决方案而出现，因为MBR限制了分区的最大可寻址空间为2TB（232 × 512 bytes）,以及其他一些固有的限制（比如CHS，512字节的扇区大小）。GPT为了保持向后兼容性，可以与MBR共存。下图是GUID规范中各字段的布局：</p>
<p>a. LAB 0<br>&emsp;&emsp;为了减少分区表损坏的风险，GPT在硬盘最后保存了一份分区表的副本<br>在支持从GPT启动的操作系统中，这里（Protective MBR）也用于存储第一阶段的启动代码。在这个MBR中，只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表。<br>在使用MBR&#x2F;GPT混合分区表的硬盘中，这部分存储了GPT分区表的一部分分区（通常是前四个分区），可以使不支持从GPT启动的操作系统从这个MBR启动，启动后只能操作MBR分区表中的分区。如Boot camp就是使用这种方式启动Windows。<br>For GRUB to boot from a GPT-partitioned disk on a BIOS-based system, a BIOS Boot Partition is required.</p>
<p>b.LAB 1<br>&emsp;&emsp;GPT分区表头，定义磁盘可用的块，另外也定义分区表项的数量和大小。<br>&emsp;&emsp;详细查看维基百科⑪</p>
<p>c.LAB2-33<br>&emsp;&emsp;该部分为分区表项，描述每个分区的详细信息，每个表项最少使用128个字节。其起始位置及每个表项的大小在分别在头部的72与84字节处定义。默认情况下分配的空间可以定义128个分区，如果需要更多的分区，则分配更多的空间并在GPT头部注明就可以了。</p>
<h4 id="Grub2对BIOS-GPT的支持"><a href="#Grub2对BIOS-GPT的支持" class="headerlink" title="Grub2对BIOS&#x2F;GPT的支持"></a>Grub2对BIOS&#x2F;GPT的支持</h4><p>&emsp;&emsp;由于使用GPT分区表，grub的stage1.5就不能存在了，因为此时我们无法确保在MBR与第一分区之间会留有空间。在这种情况下，需要一个额外的BIOS Boot Partition分区存放grub的core.img。</p>
<h4 id="分区工具总结列表：待补充"><a href="#分区工具总结列表：待补充" class="headerlink" title="分区工具总结列表：待补充"></a>分区工具总结列表：待补充</h4><p>&emsp;&emsp;关于GPT与BIOS方案的选择问题以及分区表的备份与还原可以参考ArchLinux Wiki Partitioning。</p>
<h3 id="方案三：UEFI"><a href="#方案三：UEFI" class="headerlink" title="方案三：UEFI"></a>方案三：UEFI</h3><p>&emsp;&emsp;关于如何在计算机启动时屏蔽UEFI以及安全启动请查看Disable_UEFI_and_Secure_Boot</p>
<h3 id="方案四：U-boot"><a href="#方案四：U-boot" class="headerlink" title="方案四：U-boot"></a>方案四：U-boot</h3><p>&emsp;&emsp;待补充</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>① <a href="https://baike.baidu.com/item/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/7612638?fr=aladdin&fromid=10473976&fromtitle=mbr">MBR 百度百科</a><br>② <a href="https://baike.baidu.com/item/bios/91424?fr=aladdin">BIOS 百度百科</a><br>③ <a href="https://opensource.com/article/17/2/linux-boot-and-startup">An introduction to the Linux boot and startup processes</a><br>④ <a href="https://www.cnblogs.com/leaven/archive/2010/01/07/1641324.html">详解 Linux Initrd</a><br>⑤ <a href="https://baike.baidu.com/item/initrd/3239796?fr=aladdin">initrd 百度百科</a><br>⑥ <a href="https://wiki.archlinux.org/index.php/Mkinitcpio">mkinitcpio ArchLinux Wiki</a><br>⑦ <a href="https://wiki.archlinux.org/index.php/Category:Boot_loaders">Boot Loader ArchLinux Wiki</a><br>⑧ <a href="http://www.178linux.com/15793">UEFI原理小结</a><br>⑨ <a href="https://neosmart.net/wiki/easybcd/">EasyBCD 官方wiki</a><br>⑩ <a href="http://www.178linux.com/15788">UEFI与BIOS对比</a><br>⑪ <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GPT 维基百科</a></p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>制作MultiBoot USB启动盘</title>
    <url>/2022/01/11/%E5%88%B6%E4%BD%9CMultiBoot-USB%E5%90%AF%E5%8A%A8%E7%9B%98/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>该文章介绍如何制作可以启动多个Linux或Windows系统的USB盘.使用grub可以启动多种GNU&#x2F;Linux系统，但启动Windows系统会稍微比较麻烦：首先windows系统的镜像文件可能大于4G，它只能存储在NTFS文件系统分区中，在FAT32分区中是不行的，所以解决方法是分别创建FAT32分区和NTFS分区。<br>另外要做到兼容Lagecy BIOS和UEFI。<br>如果要兼容UEFI，必须增加额外的EFI系统分区。</p>
<span id="more"></span>

<h3 id="创建混合UEFI-GPT-BIOS-GPT-MBR"><a href="#创建混合UEFI-GPT-BIOS-GPT-MBR" class="headerlink" title="创建混合UEFI GPT+ BIOS GPT&#x2F;MBR"></a>创建混合UEFI GPT+ BIOS GPT&#x2F;MBR</h3><p><a href="https://wiki.archlinux.org/title/Multiboot_USB_drive">https://wiki.archlinux.org/title/Multiboot_USB_drive</a></p>
<h3 id="glim"><a href="#glim" class="headerlink" title="glim"></a>glim</h3><p><a href="https://github.com/thias/glim">https://github.com/thias/glim</a><br>glim主要由一系列grub的配置脚本文件构成,还包括一些资源文件,比如grub的背景图片,字体以及启动项logo等.使用时只需要将iso镜像文件拷贝到对应的目录即可,但有些GNU&#x2F;Linux操作系统更新很快,特别是有些boot目录的文件名会有所改动,这时候就要手动修改对应的grub配置脚本. glim目前不支持windows系统.</p>
<h3 id="multisystem"><a href="#multisystem" class="headerlink" title="multisystem"></a>multisystem</h3><p><a href="http://liveusb.info/">http://liveusb.info</a></p>
<h3 id="Aio-Boot"><a href="#Aio-Boot" class="headerlink" title="Aio Boot"></a>Aio Boot</h3><p><a href="https://www.aioboot.com/en/about/">https://www.aioboot.com/en/about/</a><br>Aio Boot是windows下的应用程序,它使用起来比较方便,特别对于Linux系统的新手而言.它的功能更丰富,支持的操作系统也更多,除了Linux还包括Android和和Windows 7&#x2F;8&#x2F;10等.</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>功能安全标准 ISO26262 中的硬件安全机制</title>
    <url>/2025/02/24/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8%E6%A0%87%E5%87%86-ISO26262-%E4%B8%AD%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><span id="more"></span>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>功能安全</category>
      </categories>
  </entry>
  <entry>
    <title>可怜的伊壁鸠鲁</title>
    <url>/2020/05/13/%E5%8F%AF%E6%80%9C%E7%9A%84%E4%BC%8A%E5%A3%81%E9%B8%A0%E9%B2%81/</url>
    <content><![CDATA[<p><em>早期阅读伊壁鸠鲁哲学时所作笔记小诗。</em><br>——————<br>他用地面上所发生的自然现象<br>来类比解释天上的事情</p>
<span id="more"></span>


<p>他急切地想要把神<br>从它那多余的职位上拉下来<br>然后放逐它到宇宙之外安度晚年<br>不要再来管人间的事情</p>
<p>他急功近利地列举各种自然的解释<br>来尝试揭示占星术士是一群疯子</p>
<p>这个无神论者<br>凭持着德谟克里特——<br>那个时代最有力的武器<br>来攻击宗教迷信</p>
<p>他制造了一个花园，并声称<br>在那里，没有恐惧和烦恼</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>四轴飞行器基础知识总结</title>
    <url>/2025/03/14/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>四轴飞行器（Quadrotor）是一种多旋翼飞行器。四轴飞行器的四个螺旋桨都是电机直连的简单机构，十字形的布局允许飞行器通过改变电机转速获得旋转机身的力，从而调整自身姿态。本文就基本原理做一些总结，并以 <code>esp-drone</code> 开源项目作为示例。</p>
<span id="more"></span>

<h2 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h2><p>使用大疆的 <code>Fight Simulator</code> 模拟器。</p>
<p><img src="/2025/03/14/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/dji_flight_simulation.png"></p>
<p>注意使用 <code>S</code>、 <code>D</code> 和 <code>←</code>、<code>↓</code> 4个键同时按下启动无人机，然后可以使用手柄控制。  </p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><code>ESP-Drone</code> 是基于乐鑫 <code>ESP32/ESP32-S2/ESP32-S3</code> 开发的小型无人机解决方案，可使用手机 APP 或游戏手柄通过 <code>Wi-Fi</code> 网络进行连接和控制。</p>
<h3 id="关于手柄"><a href="#关于手柄" class="headerlink" title="关于手柄"></a>关于手柄</h3><p>在 Linux 系统上一般会生成 <code>/dev/input/js0</code> 的设备，直接读取该字符设备的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">cat</span> /dev/input/js0 | hexdump</span></span><br><span class="line">0000000 893c 0f5d 0000 0081 893c 0f5d 0000 0181</span><br><span class="line">0000010 893c 0f5d 0000 0281 893c 0f5d 0000 0381</span><br><span class="line">0000020 893c 0f5d 0000 0481 893c 0f5d 0000 0581</span><br><span class="line">0000030 893c 0f5d 0000 0681 893c 0f5d 0000 0781</span><br><span class="line">0000040 893c 0f5d 0000 0881 893c 0f5d 0000 0981</span><br><span class="line">0000050 893c 0f5d 0000 0a81 893c 0f5d 0000 0082</span><br><span class="line">0000060 893c 0f5d 0000 0182 893c 0f5d 8001 0282</span><br><span class="line">0000070 893c 0f5d 0000 0382 893c 0f5d 0000 0482</span><br><span class="line">0000080 893c 0f5d 8001 0582 893c 0f5d 0000 0682</span><br></pre></td></tr></table></figure>

<p>也可以使用测试套件 <code>joystick</code> 中的命令 <code>jstest</code> 来进行测试，可以将读取的数据对应到具体的按钮：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> jstest /dev/input/js0</span></span><br><span class="line">Driver version is 2.1.0.</span><br><span class="line">Joystick (Microsoft X-Box 360 pad) has 8 axes (X, Y, Z, Rx, Ry, Rz, Hat0X, Hat0Y)</span><br><span class="line">and 11 buttons (BtnA, BtnB, BtnX, BtnY, BtnTL, BtnTR, BtnSelect, BtnStart, BtnMode, BtnThumbL, BtnThumbR).</span><br><span class="line">Testing ... (interrupt to exit)</span><br><span class="line">Axes:  0:     0  1:     0  2:-32767  3:     0  4:     0  5:-32767  6:     0  7:     0 Buttons:  0:off  1:off  2:off  3:off  4:off  5:off  6:off  7:off  8:off  9:off 10:off</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
        <category>四轴飞行器</category>
      </categories>
  </entry>
  <entry>
    <title>基于 4G 模组的 GPS 小型定位器</title>
    <url>/2024/11/16/%E5%9F%BA%E4%BA%8E-4G-%E6%A8%A1%E7%BB%84%E7%9A%84-GPS-%E5%B0%8F%E5%9E%8B%E5%AE%9A%E4%BD%8D%E5%99%A8/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>使用 4G Cat.1 模组可以满足一些中低速数据传输的应用场景，如进行实时定位。本文介绍使用 QUECTEL 的 EG800K-CN<br>模组进行 GPS 定位的方法以及进行实际场景追踪测试的流程。</p>
<span id="more"></span>

<h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><h4 id="通信模组"><a href="#通信模组" class="headerlink" title="通信模组"></a>通信模组</h4><p><img src="/2024/11/16/%E5%9F%BA%E4%BA%8E-4G-%E6%A8%A1%E7%BB%84%E7%9A%84-GPS-%E5%B0%8F%E5%9E%8B%E5%AE%9A%E4%BD%8D%E5%99%A8/1732537646579.jpg"></p>
<h4 id="串口转换器"><a href="#串口转换器" class="headerlink" title="串口转换器"></a>串口转换器</h4><p><img src="/2024/11/16/%E5%9F%BA%E4%BA%8E-4G-%E6%A8%A1%E7%BB%84%E7%9A%84-GPS-%E5%B0%8F%E5%9E%8B%E5%AE%9A%E4%BD%8D%E5%99%A8/1732537646573.jpg"></p>
<h4 id="天线"><a href="#天线" class="headerlink" title="天线"></a>天线</h4><h4 id="物联网卡"><a href="#物联网卡" class="headerlink" title="物联网卡"></a>物联网卡</h4><h3 id="软件工具准备"><a href="#软件工具准备" class="headerlink" title="软件工具准备"></a>软件工具准备</h3><p>在 Ubuntu 22.04 上如果无法为 ch340串口转 USB 工具生成 ttyUSBx 设备文件，并显示下面的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usb 3-1: usbfs: interface 0 claimed by ch341 while &#x27;brltty&#x27; sets config #1</span><br></pre></td></tr></table></figure>
<p>表明出现了驱动占用问题，此时卸载 <strong>‘brltty’</strong> 即可：</p>
<p><code>$ sudo apt-get remove brltty</code></p>
<p>最后重新插拔设备。</p>
<h4 id="串口工具"><a href="#串口工具" class="headerlink" title="串口工具"></a>串口工具</h4><p>在 Ubuntu 下可以使用 CuteCom 串口工具，连接设备后，发送 <code>ATI</code> 命令，获取如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[17:31:24:250] Quectel␍␊</span><br><span class="line">[17:31:24:250] EG800K␍␊</span><br><span class="line">[17:31:24:250] Revision: EG800KCNGCR07A04M04␍␊</span><br><span class="line">[17:31:24:255] ␍␊</span><br><span class="line">[17:31:24:255] OK␍␊</span><br></pre></td></tr></table></figure>
<p>表明通信正常</p>
<h3 id="AT-命令测试"><a href="#AT-命令测试" class="headerlink" title="AT 命令测试"></a>AT 命令测试</h3><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ATI       # 获取 MT 的 ID 信息</span><br><span class="line">$ AT+GMI    # 请求制造商信息</span><br><span class="line">$ AT+GSN    # 请求国际移动设备识别码</span><br><span class="line">$ AT+</span><br></pre></td></tr></table></figure>

<h4 id="SIM卡信息"><a href="#SIM卡信息" class="headerlink" title="SIM卡信息"></a>SIM卡信息</h4><p>将 SIM 物联网卡 插入 4G 模组中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ AT+CIMI       # 查询 IMSI</span><br><span class="line">460066613329084␍␊</span><br><span class="line"></span><br><span class="line">$ AT+CLCK=&quot;SC&quot;,2    # 查询 SIM 的锁定状态</span><br><span class="line">+CLCK: 0␍␊          # 未锁定</span><br><span class="line"></span><br><span class="line">$ AT+QCCID      # 查询 CCID</span><br><span class="line">+QCCID: 89860622330027340843␍␊</span><br><span class="line"> </span><br><span class="line">$ AT+QINISTAT   # 查询 SIM 卡初始状态</span><br><span class="line">+QINISTAT: 3␍    # CPIN READY + SMS Done</span><br><span class="line"></span><br><span class="line">$ AT+CPIN=?     # 查询 SIM 卡是否需要密钥解锁</span><br><span class="line">+CPIN: READY␍␊  # 无密码等待输入 MT</span><br><span class="line"></span><br><span class="line">$ AT+QSIMDET=1,0    # 设置(U)SIM 卡插入时，(U)SIM 检测引脚为低电平。</span><br><span class="line">$ AT+QSIMSTAT=1     # 使能(U)SIM 卡的插拔状态上报功能。</span><br><span class="line">$ AT+QSIMSTAT?      # 查询当前(U)SIM 卡的插拔状态。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h4><p>连接上 GNSS 天线（可使用有源天线或者无源天线）和 LTE 天线。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ AT+QCFG=&quot;nwscanmode&quot;  # 查询支持的网络制式</span><br><span class="line">+QCFG: &quot;nwscanmode&quot;,3␍␊  # 3 代表仅支持 LTE</span><br><span class="line"></span><br><span class="line">$ AT+QCFG=&quot;band&quot;   # 查询 UE 的网络搜索频段</span><br><span class="line">+QCFG: &quot;band&quot;,0x0,0x1e200000095␍␊    </span><br><span class="line"># 不改变 GSM 和 WCDMA 的频段；支持 LTE B38、LTE B39、LTE B40、LTE B41 、LTE B34、LTE B8、 LTE B5、LTE B3 和 LTE B1 频段。 </span><br><span class="line"></span><br><span class="line">$ AT+COPS?      # 查询当前找网模式和当前所选运营商</span><br><span class="line">+COPS: 0,0,&quot;CHN-UNICOM&quot;,7␍␊</span><br><span class="line"># 自动搜网；长字符串格式；中国联通；网络接入技术（E-UTRAN）</span><br><span class="line"></span><br><span class="line">$ AT+CREG=2     # 启用带有位置信息的网络注册 URC</span><br><span class="line">OK␍␊</span><br><span class="line"></span><br><span class="line">$ AT+CREG?      # 查询网络注册状态</span><br><span class="line">+CREG: 2,1,&quot;XXXX&quot;,&quot;YYYYYY&quot;,7␍␊</span><br><span class="line"># 带有位置信息的网络注册URC；已注册；位置区编号；小区ID；接入技术（E-UTRAN）</span><br><span class="line"></span><br><span class="line">$ AT+QNWINFO    # 查询网络信息</span><br><span class="line">+QNWINFO: &quot;FDD LTE&quot;,&quot;46001&quot;,&quot;LTE BAND 3&quot;,1506␍␊</span><br><span class="line"></span><br><span class="line">$ AT+CSQ        # 信号强度</span><br><span class="line">+CSQ: 30,99␍␊</span><br><span class="line"></span><br><span class="line">$ AT+QCSQ        # 信号强度</span><br><span class="line">+QCSQ: &quot;LTE&quot;,53,-86,130,-14␍␊</span><br><span class="line"># RSSI(接收信号强度)；RSRP(参考信号接收功率); SINR(信号与干扰加噪声比); RSRQ(参考信号接收质量)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于接入技术：<br><img src="/2024/11/16/%E5%9F%BA%E4%BA%8E-4G-%E6%A8%A1%E7%BB%84%E7%9A%84-GPS-%E5%B0%8F%E5%9E%8B%E5%AE%9A%E4%BD%8D%E5%99%A8/E_UTRAN.png" alt="E-UTRAN的结构图"></p>
<h4 id="硬件相关信息"><a href="#硬件相关信息" class="headerlink" title="硬件相关信息"></a>硬件相关信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ AT+CCLK?      # 查询模块实时时钟（RTC）</span><br><span class="line">+CCLK: &quot;70/01/01,00:06:05+00&quot;␍␊</span><br><span class="line"></span><br><span class="line">$ AT+CBC        # 查询电池充电状态和电量</span><br><span class="line">+CBC: 0,0,3875␍␊</span><br><span class="line"># ME 未充电；电池剩余0%；电压(mv)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="分组域相关信息"><a href="#分组域相关信息" class="headerlink" title="分组域相关信息"></a>分组域相关信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>测试 GPS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ AT+QGPSCFG=&quot;outport&quot;, &quot;uartdebug&quot;     # 配置 NMEA 语句输出端口</span><br><span class="line"></span><br><span class="line">$ AT+QGPSCFG=&quot;gnssconfig&quot;,5             # 设置 GNSS 卫星导航系统</span><br><span class="line">OK</span><br><span class="line"># GPS + BDS + Galileo 混合定位</span><br><span class="line"></span><br><span class="line">$ AT+QGPSCFG=&quot;gnssconfig&quot;               # 查询支持的 GNSS 卫星导航系统</span><br><span class="line">+QGPSCFG: &quot;gnssconfig&quot;,5␍␊</span><br><span class="line"></span><br><span class="line">$ AT+QGPSCFG=&quot;autogps&quot;,1                # 设置模块启动时自动启动 GNSS</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ AT+QGPSCFG=&quot;nmeasrc&quot;                  # 用于启用或禁用通过 AT+QGPSGNMEA 获取 NMEA 语句</span><br><span class="line">+QGPSCFG: &quot;nmeasrc&quot;,1␍␊</span><br><span class="line"></span><br><span class="line">$ AT+QGPSCFG=&quot;apflash&quot;,0</span><br><span class="line"></span><br><span class="line">$ AT+QGPS=1                             # 打开 GNSS</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ AT+QGPSEND                            # 关闭 GNSS</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ AT+QGPSLOC=2                          # 获取定位信息</span><br><span class="line">+QGPSLOC: 141445.00,31.26329,121.68116,1.24,62.8,3,,0.184,0.101,251124,22␍</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建云平台实例"><a href="#创建云平台实例" class="headerlink" title="创建云平台实例"></a>创建云平台实例</h3><p>在<a href="https://iot.console.aliyun.com/lk/summary/new">阿里云物联网平台</a> 开通公共实例，如下图所示：</p>
<p><img src="/2024/11/16/%E5%9F%BA%E4%BA%8E-4G-%E6%A8%A1%E7%BB%84%E7%9A%84-GPS-%E5%B0%8F%E5%9E%8B%E5%AE%9A%E4%BD%8D%E5%99%A8/aliiot.png"></p>
<h4 id="创建产品"><a href="#创建产品" class="headerlink" title="创建产品"></a>创建产品</h4><p><img src="/2024/11/16/%E5%9F%BA%E4%BA%8E-4G-%E6%A8%A1%E7%BB%84%E7%9A%84-GPS-%E5%B0%8F%E5%9E%8B%E5%AE%9A%E4%BD%8D%E5%99%A8/createProduct.png"></p>
<h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p><img src="/2024/11/16/%E5%9F%BA%E4%BA%8E-4G-%E6%A8%A1%E7%BB%84%E7%9A%84-GPS-%E5%B0%8F%E5%9E%8B%E5%AE%9A%E4%BD%8D%E5%99%A8/createdevice.png"></p>
<p>注意生成的设备证书和 MQTT 连接参数。</p>
<h3 id="使用-MQTT-协议连接云平台"><a href="#使用-MQTT-协议连接云平台" class="headerlink" title="使用 MQTT 协议连接云平台"></a>使用 MQTT 协议连接云平台</h3><h4 id="不使用-SSL"><a href="#不使用-SSL" class="headerlink" title="不使用 SSL"></a>不使用 SSL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置消息接收模式</span><br><span class="line">$ AT+QMTCFG=&quot;recv/mode&quot;,0,0,1    # client_idx = 0; 消息内容和消息长度均包含在 URC 中</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 配置阿里云设备信息（product_key + device_name + device_secret）</span><br><span class="line">$ AT+QMTCFG=&quot;aliauth&quot;,0,&quot;k21omXYRDQU&quot;,&quot;EG800KCN&quot;,&quot;3c6bc85d94f6dfa58b5c1c812a56f64e&quot;</span><br><span class="line"></span><br><span class="line"># Open 网络端口</span><br><span class="line">$ AT+QMTOPEN=0,&quot;iot-06z00i7jerba07i.mqtt.iothub.aliyuncs.com&quot;,1883</span><br><span class="line">+QMTOPEN: 0,0␍␊</span><br><span class="line"></span><br><span class="line"># 建立连接</span><br><span class="line">$ AT+QMTCONN=0,&quot;clientEG800K_CN&quot;</span><br><span class="line"></span><br><span class="line"># 订阅 Topic</span><br><span class="line">$ AT+QMTSUB=0,1,&quot;/k21omXYRDQU/EG800KCN/user/get&quot;,2</span><br><span class="line">OK</span><br><span class="line">+QMTSUB: 0,1,0,1</span><br><span class="line"></span><br><span class="line">$ AT+QMTSUB=0,1,&quot;/sys/k21omXYRDQU/EG800KCN/thing/event/property/post_reply&quot;,2</span><br><span class="line">OK</span><br><span class="line">+QMTSUB: 0,1,0,1</span><br><span class="line"></span><br><span class="line"># 发布属性</span><br><span class="line">$ AT+QMTPUBEX=0,0,0,0,&quot;/sys/k21omXYRDQU/EG800KCN/thing/event/property/post&quot;,30</span><br><span class="line">&gt; &#123;id:0, version: 1.0&#125;</span><br><span class="line">OK</span><br><span class="line">+QMTPUBEX: 0,0,0</span><br><span class="line"></span><br><span class="line"># 关闭连接</span><br><span class="line">$ AT+QMTDISC=0</span><br><span class="line">+QMTDISC: 0,0␍␊</span><br><span class="line">+QMTSTAT: 0,5␍␊</span><br><span class="line"></span><br><span class="line"># Close 网络端口</span><br><span class="line">$ AT+QMTCLOSE=0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于安全"><a href="#关于安全" class="headerlink" title="关于安全"></a>关于安全</h3><blockquote>
<p>参考 <a href="https://help.aliyun.com/zh/iot/user-guide/overview-1?spm=a2c4g.11186623.help-menu-30520.d_2_2_1_1_0.2d53765eP6WrKo">设备安全认证-阿里云IOT平台</a><br>参考 <a href="https://www.secrss.com/articles/17647">物联网身份认证方案的安全挑战</a><br>参考 <a href="https://help.aliyun.com/document_detail/2361103.html">IoT设备身份认证免费试用的教程指南</a></p>
</blockquote>
<h4 id="使用-SSL"><a href="#使用-SSL" class="headerlink" title="使用 SSL"></a>使用 SSL</h4>]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>基于流程的debian包管理体系快速命令参考手册</title>
    <url>/2018/01/28/%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%A8%8B%E7%9A%84debian%E5%8C%85%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB%E5%BF%AB%E9%80%9F%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="基于流程的快速命令参考手册"><a href="#基于流程的快速命令参考手册" class="headerlink" title="基于流程的快速命令参考手册"></a>基于流程的快速命令参考手册</h2><h3 id="流程1：系统bug修复（暂时指Ubuntu-系列的系统）"><a href="#流程1：系统bug修复（暂时指Ubuntu-系列的系统）" class="headerlink" title="流程1：系统bug修复（暂时指Ubuntu 系列的系统）"></a>流程1：系统bug修复（暂时指Ubuntu 系列的系统）</h3><h3 id="流程2：维护现有的debian包"><a href="#流程2：维护现有的debian包" class="headerlink" title="流程2：维护现有的debian包"></a>流程2：维护现有的debian包</h3><h3 id="流程3：打包上游软件"><a href="#流程3：打包上游软件" class="headerlink" title="流程3：打包上游软件"></a>流程3：打包上游软件</h3><span id="more"></span>

<h3 id="1-系统bug修复"><a href="#1-系统bug修复" class="headerlink" title="1. 系统bug修复"></a>1. 系统bug修复</h3><h4 id="①定位软件source包"><a href="#①定位软件source包" class="headerlink" title="①定位软件source包"></a>①定位软件source包</h4><p>方法a：根据包名关键字查找</p>
<p><code>dpkg -l | grep &lt;keyword&gt;</code>（只包括已安装的软件包）</p>
<p>或者<br><code>apt list | grep &lt;keyword&gt;</code>（包括未安装的软件包）</p>
<p>方法b：根据某个文件名查找</p>
<p><code>dpkg -S &lt;filename&gt;</code></p>
<p>或者<br><code>apt-file search &lt;filename&gt;</code></p>
<p>注意：apt-file search命令获得的为binary包名，下条命令根据binary包名获得对应的source包名</p>
<p><code>apt-cache showsrc &lt;binary-package-name&gt; | grep ^Package</code></p>
<h4 id="②获取软件source包"><a href="#②获取软件source包" class="headerlink" title="②获取软件source包"></a>②获取软件source包</h4><p>方法a：从库中获取</p>
<p><code>apt-get source &lt;package-name&gt;</code> （不包含revision信息）</p>
<p>如果需要导入bzr版本控制系统：</p>
<p><code>bzr init &lt;package-name&gt;-&lt;version&gt;</code></p>
<p><code>cd &lt;package-name&gt;-&lt;version&gt;</code></p>
<p><code>bzr import-dsc ../&lt;package-name&gt;_&lt;version&gt;.dsc</code></p>
<p>方法b：从launchpad上获取</p>
<p><code>bzr branch lp:&lt;package-name&gt;</code> （默认是trunk分支）</p>
<p>或<code>bzr branch lp:&lt;package-name/Series-name&gt;</code>（指定分支名）</p>
<p>或<code>bzr branch lp:ubuntu/&lt;release&gt;/&lt;package-name&gt;</code></p>
<h4 id="③在source包上fix"><a href="#③在source包上fix" class="headerlink" title="③在source包上fix"></a>③在source包上fix</h4><p>建立bug分支，简单命名为fix-bug-123456</p>
<p><code>bzr branch &lt;branch-directory-name&gt; fix-bug-123456</code></p>
<p><code>cd fix-bug-123456</code></p>
<p><code>bzr log</code> 或 <code>bzr qlog</code>（查看revision信息）</p>
<p><code>bzr revert -r &lt;revision-num&gt; </code>（代码回滚）</p>
<p>然后，</p>
<p>方法a：直接修改或新增某个文件（针对非quilt包）</p>
<p><code>bzr add &lt;modified-files&gt;</code></p>
<p><code>bzr commit</code></p>
<p>方法b：使用quilt补丁系统</p>
<p>（已经对quilt进行了配置,且位于分支根目录树下）</p>
<p><code>quilt applied</code> （检查已经应用的patches）</p>
<p><code>quilt pop</code> （移除处于top位置的patch）</p>
<p><code>quilt push</code> （应用处于top位置的patch）</p>
<p><code>quilt new newpatch-name.diff</code> （建立新的patch，该patch会处于top位置）</p>
<p><code>quilt add</code> &lt;要修改或新增的文件名&gt;</p>
<p><code>quilt refresh</code></p>
<p><code>bzr add debian/patches/newpatch-name.diff</code></p>
<p><code>bzr add .pc/*</code></p>
<p><code>bzr commit</code></p>
<p>方法c：使用edit-patch补丁操作命令（对于没有使用quilt而是使用其他patch系统的软件包）:</p>
<p>&#96;edit-patch newpatch-name （然后根据提示完成一系列工作）</p>
<p><code>patch -p1 &lt; upstream -patch.patch</code> （导入某个上游patch）</p>
<h4 id="④测试fix"><a href="#④测试fix" class="headerlink" title="④测试fix"></a>④测试fix</h4><p>方法a：使用pbuilder（在一个独立干净的环境里）</p>
<p><code>pbuilder create</code> （如果没有构建pbuilder环境）</p>
<p><code>bzr builddeb -- -S  </code></p>
<p><code>pbuilder-dist &lt;release&gt; build ../&lt;package&gt;_&lt;version&gt;.dsc</code></p>
<p><code>sudo dpkg -i ~/pbuilder/&lt;release&gt;_result/&lt;package&gt;_&lt;version&gt;.deb</code></p>
<p>方法b：直接使用debuild</p>
<p><code>apt-get build-dep &lt;package-name&gt;</code> （获取依赖）</p>
<p><code>debuild</code></p>
<p><code>sudo dpkg -i ../&lt;package&gt;_&lt;version&gt;.deb</code></p>
<p>方法c：使用launchpad上的ppa</p>
<p><code>debuild -S -sa</code> （该版本的包在Ubuntu库中已经存在）</p>
<p>或<code>debuild -S -sd</code> （如果不存在）</p>
<p>然后：</p>
<p><code>dput ppa:&lt;your-lp-id&gt;/ppaname &lt;source.changes&gt;</code></p>
<p>最后从launchpad上下载.deb文件进行安装测试</p>
<p>注意：以下为对deb包操作的命令</p>
<p><code>ar tv &lt;package&gt;_&lt;version&gt;.deb</code> （打开包）<br><code>dpkg -c &lt;package&gt;_&lt;version&gt;.deb</code> （列出包中所有文件名）<br><code>dpkg -I &lt;package&gt;_&lt;version&gt;.deb</code> （包的信息）<br><code>sudo dpkg -i ../&lt;package&gt;_&lt;version&gt;.deb</code> （安装该包）</p>
<p>如果测试没通过回到③，通过则到⑤。</p>
<h4 id="⑤文档化fix（必要的情况下执行该步骤）"><a href="#⑤文档化fix（必要的情况下执行该步骤）" class="headerlink" title="⑤文档化fix（必要的情况下执行该步骤）"></a>⑤文档化fix（必要的情况下执行该步骤）</h4><p><code>dch -i</code> （如果使用了edit-patch就不需要再执行该命令）</p>
<h4 id="⑥提交fix"><a href="#⑥提交fix" class="headerlink" title="⑥提交fix"></a>⑥提交fix</h4><p><code>bzr push  lp:~&lt;yourlpid&gt;/ubuntu/&lt;release&gt;/&lt;package-name&gt;/fix-bug-123456</code></p>
<p><code>bzr lp-propose</code> （将打开launchpad上对应的页面，在此处申请分支合并）</p>
<h3 id="2-维护现有的debian包"><a href="#2-维护现有的debian包" class="headerlink" title="2. 维护现有的debian包"></a>2. 维护现有的debian包</h3><h4 id="①获取软件包"><a href="#①获取软件包" class="headerlink" title="①获取软件包"></a>①获取软件包</h4><p>方法a：1.②.a</p>
<p>方法b：1.②.b</p>
<p>方法c：从Internet上</p>
<p><code>dget &lt;url&gt;.dsc</code></p>
<p><code>dpkg-source -x file.dsc</code></p>
<h4 id="②升级软件包"><a href="#②升级软件包" class="headerlink" title="②升级软件包"></a>②升级软件包</h4><h4 id="③构建软件包"><a href="#③构建软件包" class="headerlink" title="③构建软件包"></a>③构建软件包</h4><p>方法：1.④.a&#x2F;b&#x2F;c</p>
<h4 id="④发布软件包"><a href="#④发布软件包" class="headerlink" title="④发布软件包"></a>④发布软件包</h4><h3 id="3-打包上游软件"><a href="#3-打包上游软件" class="headerlink" title="3. 打包上游软件"></a>3. 打包上游软件</h3><h4 id="①获取上游软件"><a href="#①获取上游软件" class="headerlink" title="①获取上游软件"></a>①获取上游软件</h4><p><code>wget &lt;URL&gt;</code> 或 <code>curl -O &lt;URL&gt;</code></p>
<p>改名为<source_package>_<upstream_version>.orig.tar.gz</p>
<p>然后解压</p>
<p><code>tar xf &lt;source_package&gt;_&lt;upstream_version&gt;.tar.gz</code></p>
<h4 id="②生成debian目录"><a href="#②生成debian目录" class="headerlink" title="②生成debian目录"></a>②生成debian目录</h4><p><code>cd &lt;source_package&gt;-&lt;upstream_version&gt; &amp;&amp; dh_make</code></p>
<h4 id="③编辑debian目录下的文件"><a href="#③编辑debian目录下的文件" class="headerlink" title="③编辑debian目录下的文件"></a>③编辑debian目录下的文件</h4><p>获取debian&#x2F;control文件所需要的依赖的方法：</p>
<p><code>dpkg-depcheck -d ./configure</code> （根据configure文件）</p>
<p>或<code>objdump -p /usr/bin/foo | grep NEEDED</code> （根据编译后的可执   行文件获得依赖的共享库）</p>
<h4 id="④构建包"><a href="#④构建包" class="headerlink" title="④构建包"></a>④构建包</h4><p>方法：1.④.a&#x2F;b&#x2F;c</p>
<h4 id="⑤使用lintian检查错误"><a href="#⑤使用lintian检查错误" class="headerlink" title="⑤使用lintian检查错误"></a>⑤使用lintian检查错误</h4><p><code>lintian &lt;*&gt;.dsc</code></p>
<p><code>lintian &lt;*&gt;.deb</code></p>
<h4 id="⑥发布包"><a href="#⑥发布包" class="headerlink" title="⑥发布包"></a>⑥发布包</h4><p>方法a：1.④.c（使用自己的ppa）</p>
<p>从ppa安装软件的命令 ：</p>
<p><code>sudo add-apt-repository ppa:&lt;your-lp-id&gt;/ppaname</code></p>
<p><code>sudo apt-get update</code></p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式系统中的WatchDog</title>
    <url>/2023/05/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84WatchDog/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <strong>WatchDog</strong> 是一种软件或硬件定时器，用于检测计算机故障或者从故障中恢复。它还可以用于保护计算机免受出错程序或者恶意程序的破坏。<br>&emsp;&emsp; 在正常操作期间，计算机周期性的重置 <code>WatchDog</code> 以防止它超时（“elapsing”）。如果因为硬件故障或者软件错误导致重置<code>WatchDog</code>失败，<code>WatchDog</code>就会超时并且会生成超时信号。这个信号可以被用于重新初始化系统到正确、安全的状态。</p>
<span id="more"></span>

<p>&emsp;&emsp; 对于一些特殊的硬件设备（例如远程空间探测器），如果系统出现故障，想要通过人工手动恢复几乎是不可能的，这时候设备需要“自力更生”，<code>WatchDog</code>定时器就可以派上用场了。另外，在运行不受信任的代码时，也可以使用 <code>WatchDog</code>，以限制该代码对 CPU 的使用时间，从而防止某些类型的<code>拒绝服务攻击（DOS Attack）</code>。</p>
<blockquote>
<p>参考 <a href="https://interrupt.memfault.com/blog/firmware-watchdog-best-practices">《A Guide to Watchdog Timers for Embedded Systems》</a> - By <strong>Chris Coleman</strong>.<br>参考  <a href="https://encyclopedia.thefreedictionary.com/Watchdog+timer">Wikipedia - WatchDog timer</a>.</p>
</blockquote>
<h2 id="硬件-WatchDog"><a href="#硬件-WatchDog" class="headerlink" title="硬件 WatchDog"></a>硬件 WatchDog</h2><p>&emsp;&emsp; 许多芯片厂商在他们的 MCU 中包含了一个分立的 RTL 模块，称为”WatchDog 定时器”。该外围设备（peripheral）由一个随时钟周期信号自动递减的计数器组成，当计数器到达零时，硬件将自动重置（Reset）设备。</p>
<p>&emsp;&emsp; <code>WatchDog 定时器</code>通常在默认情况下是禁用的，程序员有责任对其进行配置并且在软件中对其使能（enable）。一旦使能后，软件需要周期性地重置计数器，以防止设备被重启（Reset）。这个操作通常被称为“喂（Feeding）”、 “踢（Kicking）” 或者 “拍（Patting）” 狗。这样做的理由是，如果软件不能够重置 WatchDog 定时器，表明系统没有处于预期的运行状态，这时就需要将系统重置到正常状态。</p>
<h2 id="为什么需要-WatchDog-定时器"><a href="#为什么需要-WatchDog-定时器" class="headerlink" title="为什么需要 WatchDog 定时器"></a>为什么需要 WatchDog 定时器</h2><p>&emsp;&emsp; 嵌入式系统在很多情况下都会被挂起（Hang），最常见的情况列举如下：</p>
<ul>
<li>内存已损坏，代码陷于无限循环中（infinite loop）。</li>
<li>一个硬件组件（例如 HRM、加速度计或者 NOR Flash芯片）被卡住（wedged），不能响应请求。</li>
<li>一个或者多个任务进入死锁（互斥体被按照错误的顺序占用或者没有被释放）。</li>
<li>一个高优先级的 RTOS 任务占用了太多 CPU 时间，导致低优先级任务饥饿。</li>
</ul>
<p>对于嵌入式系统，<strong>应该</strong>在适当的位置包含 WatchDog 定时器子系统。这是识别系统挂起并收集足够信息以从根本上解决潜在问题（issue）并提供修复的最佳方法。</p>
<h2 id="配置-WatchDog"><a href="#配置-WatchDog" class="headerlink" title="配置 WatchDog"></a>配置 WatchDog</h2><h3 id="什么时候对-WatchDog-的配置进行重置"><a href="#什么时候对-WatchDog-的配置进行重置" class="headerlink" title="什么时候对 WatchDog 的配置进行重置?"></a>什么时候对 WatchDog 的配置进行重置?</h3><p>通过情况下，有下面两种选择：</p>
<ul>
<li>WatchDog 可以被 使能(enable) 或者禁用（disable）多次，并且在每次重启时<strong>必须</strong>被配置。</li>
<li>WatchDog 只能被配置和使能一次。一旦被使能后，只有特定类型的重置才能禁用（disable）WatchDog.</li>
</ul>
<h3 id="WatchDog-超时后会发生什么"><a href="#WatchDog-超时后会发生什么" class="headerlink" title="WatchDog 超时后会发生什么?"></a>WatchDog 超时后会发生什么?</h3><p>通常的选择有下面几种：</p>
<ul>
<li>当 WatchDog 超时后，硬件将立即对系统进行重置（Reset）。</li>
<li>可以使能中断，并且当 WatchDog <strong>接近超时时</strong>触发中断；在中断处理程序中，软件可以决定“喂狗”来防止系统被重置（Reset）。</li>
<li>可以使能中断，并且当 WatchDog <strong>超时时</strong>触发中断；MCU 将分配软件额外的一些时钟周期来做一些清理，然后重置系统。但这种做法往往是令人失望的，除非软件<strong>非常小心地</strong>分配清理工作执行所需的时钟周期数，否则硬件很可能在清理工作未完成前重置系统。</li>
</ul>
<h2 id="WatchDog-类型"><a href="#WatchDog-类型" class="headerlink" title="WatchDog 类型"></a>WatchDog 类型</h2><h3 id="单级-WatchDog"><a href="#单级-WatchDog" class="headerlink" title="单级 WatchDog"></a>单级 WatchDog</h3><p>Watchdog 定时器可以有多种配置，而且许多允许修改其配置。MCU 通常有一个集成的 Watchdog 。在其他计算机设备中，Watchdog 可能直接位于在 CPU 附近且直接相连的芯片中，或者位于计算机机箱中的外部扩展卡中。Watchdog 可以和 CPU 共用同一个时钟信号，如下图所示，或者它们可以有独立的时钟信号。</p>
<p><img src="/2023/05/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84WatchDog/SimpleWatchdogTimer.png"></p>
<h3 id="多级-WatchDog"><a href="#多级-WatchDog" class="headerlink" title="多级 WatchDog"></a>多级 WatchDog</h3><p>多级 Watchdog 计时器通常由多个计时器级联而成。</p>
<p><img src="/2023/05/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84WatchDog/Watchdog3stage.png"></p>
]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式系统介绍</title>
    <url>/2021/04/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;<em>本系列文章主要是重新整理 <a href="http://users.ece.utexas.edu/%7Evalvano/Volume1/E-Book/">Embedded Systems-Shape The World</a> 课程的相关学习笔记，另外会增加一些延伸的知识点或者资源材料等。</em></p>
<p>&emsp;&emsp;嵌入式系统和传统的计算机系统及其他复杂的大型系统相比，有很多不同的地方，至少在现代的电子系统爱好者看来，自己动手设计嵌入式系统要更加容易上手、更加富有乐趣，这也与嵌入式系统本身的特点有关。自底向上的学习方式有三个优势：首先是没有操作系统，因此几乎很容易理解所有的程序组件并且可以动手修改，相反，比如如果直接使用Linux内核，我们就不得不去理解复杂的进程管理、内存管理以及复杂的设备驱动框架等；第二，嵌入式系统包含真实世界环境的输入&#x2F;输出而不是构建在大量抽象概念的系统上（当然抽象方法是构建大型系统的基本方法）；最后，嵌入式系统遍布在各种产品中，我们随处可见也就随处可以学习。</p>
<span id="more"></span>

<p>&emsp;&emsp;嵌入式系统的基本结构主要包括微控制器（Microcontroller）和与其交互的外部设备:</p>
<p><img src="/2021/04/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/emebdedsystem.png"></p>
<p>嵌入式系统的一个重要的特点是实时性（Real Time），它是指输入-处理-输出流程的时间延迟存在一个上限，这种响应时间（response time）也称为接口延迟（interface latency）。特别对于一些周期性任务，嵌入式系统保证在一个小的上限时间误差内执行连续的两次周期性任务。<br>&emsp;&emsp;嵌入式系统大多数是解决某个特定的问题或者实现特定的功能，这与通用计算机不同。嵌入式系统的开发调试过程也有些不同，如今在模拟的软硬件仿真环境中进行开发，最后再下载到实际硬件上测试的流程越来越重要。</p>
<h3 id="I-O接口（I-O-Interface）"><a href="#I-O接口（I-O-Interface）" class="headerlink" title="I&#x2F;O接口（I&#x2F;O Interface）"></a>I&#x2F;O接口（I&#x2F;O Interface）</h3><p>&emsp;&emsp;I&#x2F;O接口被定义为I&#x2F;O端口、外部电路、硬件设备和软件的集合，它们组合起来使得计算机可以与外部世界通信。一般来说，我们可以将I&#x2F;O接口分为四类：</p>
<ol>
<li>并行接口（Parallel Interface）</li>
<li>串行接口（Serial Interface）</li>
<li>模拟接口（Analog Interface）</li>
<li>时钟接口（Time Interface）<br>如TM4C123G微控制器的架构如下：</li>
</ol>
<p><img src="/2021/04/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/tm4c123g_io.png"></p>
<h3 id="设备驱动（Device-Driver）"><a href="#设备驱动（Device-Driver）" class="headerlink" title="设备驱动（Device Driver）"></a>设备驱动（Device Driver）</h3><p>&emsp;&emsp;设备驱动是一种中间层的角色，它对下直接与底层硬件通信，按照设备具体的工作方法，读写设备寄存器，处理轮询、中断和DMA，以及内存映射等；对上则提供更加抽象的API接口，使得上层软件开发者从过多的硬件细节中解脱出来，更重要的是，这也体现了一种分层设计的思想。设备驱动不依赖操作系统的存在，在某些应用场景可直接由应用层调用。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>&emsp;&emsp;嵌入式微处理器可以有更直接的的地址空间布局，相反，如果支持操作系统的MMU，这种布局相对来说就不那么直接了，如果再引入用户空间和内核空间的区分，那么它的结构就会变得更加复杂。</p>
<h3 id="并行IO端口（GPIO）"><a href="#并行IO端口（GPIO）" class="headerlink" title="并行IO端口（GPIO）"></a>并行IO端口（GPIO）</h3><p>&emsp;&emsp;GPIO是最简单的IO端口，它可以分为输入端口和输出端口。在大多数微控制器上，每一个GPIO端口都可以被软件配置为输入和输出，这是通过组合触发器和三态门来实现的。对于大多数微控制器来说，都使用内存映射来访问IO端口，即通过一个内存地址来读或者写某个IO端口，但它和访问真正的内存并不完全相同。IO端口被映射的内存区域有着特殊的限制，有些bit位只能读或者只能写，或者不能被修改，或者只能被设置等。以TM4C123G为例，它提供方向寄存器（GPIO_PORTX_DIR_R）来设置端口是输入还是输出端口；提供数据寄存器（GPIO_PORTX_DATA_R）来进行实际的输入输出访问，而这些宏实际对应的都是一个特定的内存地址。另外，微控制器还会复用某些pin口来执行不同的功能，如支持串口、ADC等，这同样是通过设置特定的控制寄存器（对应一个内存地址）来完成的。<br>&emsp;&emsp;<strong>并口大都只适合近距离通信。</strong></p>
<h3 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h3><p>&emsp;&emsp; UART是全双工串口通信，RXd&#x2F;TXd分别用来传输数据和接收数据。通信协议相对简单，在有效数据位上增加起始位、停止位以及可选的校验位，同时在结构上还包括FIFO和移位寄存器。UART之所以称为异步通信，是它的通信双方只需要保持波特率的一致，各自的时钟频率可以不同（但差异要保持在5%以内）。相对UART的异步特征，SSI（或SPI）则提供同步通信，即通信双方之间的连接线包括同步时钟线。<br>&emsp;&emsp; 异步通信:<br>&emsp;&emsp; 同步通信:</p>
<h3 id="忙等、轮询和中断"><a href="#忙等、轮询和中断" class="headerlink" title="忙等、轮询和中断"></a>忙等、轮询和中断</h3><p>&emsp;&emsp;<strong>在不同的场景使用要不同的策略。</strong>中断策略适合与IO设备复杂多样、延迟时间不确定的场景；忙等（Busy-Wait）适合延时相对确定，IO设备简单的场景。</p>
<h3 id="Systick定时器"><a href="#Systick定时器" class="headerlink" title="Systick定时器"></a>Systick定时器</h3><p>&emsp;&emsp;Systick是一个计数器可以实现定时延迟或者周期性的中断。在TM4C123G上，同样是通过访问特定寄存器来对其进行配置和控制。Systick还可以用来实现调试功能，测试代码执行时间等。<br>&emsp;&emsp;Systick周期性中断适合于无法直接生成中断请求的IO设备或者需要并发执行IO操作的设备。</p>
<h3 id="Phase-Lock-Loop-PLL"><a href="#Phase-Lock-Loop-PLL" class="headerlink" title="Phase-Lock-Loop(PLL)"></a>Phase-Lock-Loop(PLL)</h3><p>&emsp;&emsp;PLL可以实现对系统运行时钟更好的控制，可以用来平衡<code>功耗和性能</code>；另外它也可以提供更精确的系统时间。PLL利用反馈原理，来实现<code>稳定的</code>高频信号。PLL通常由鉴相器（PD,Phase Detector）、环路滤波器（LF,Loop Filter）和压控振荡器（VCO,Voltage Controlled Oscillator）三部分组成。</p>
<h3 id="数模转换（DAC）与模数转换（ADC）"><a href="#数模转换（DAC）与模数转换（ADC）" class="headerlink" title="数模转换（DAC）与模数转换（ADC）"></a>数模转换（DAC）与模数转换（ADC）</h3>]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>我们的村庄和传统</title>
    <url>/2021/01/22/%E6%88%91%E4%BB%AC%E7%9A%84%E6%9D%91%E5%BA%84%E5%92%8C%E4%BC%A0%E7%BB%9F/</url>
    <content><![CDATA[<p>&emsp;&emsp;对于我们每个人来说，如何去认识、感受和思考自己过去、现在和将来生活的环境是非常重要的问题。人的心灵很容易受环境的影响，或者说它也是环境的产物，认识我们的环境的根本目的是认识我们自己，也就是在内容上去认识我们的习惯、思想、观念和情感是如何形成的。在充分的自我认识基础上我们才能去认识他人，和他人的关系的互动又反过来促进对自我的认识。除了这个根本目的外，还有一个实用目的就是对美好、快乐事物消失的一种反抗，并有可能去创造、改变我们的环境。</p>
<span id="more"></span>


<p>&emsp;&emsp;一直以来，我们的家庭、村庄和传统发生了什么样的变化？我们对这样的变化抱有什么样的情感？是激动？失望？还是无动于衷漠然视之？我们处在什么样的时代环境？从总体上看，是各种各样的局部的单一的传统环境正在被解体而开始从属于以现代城市为中心的新环境，而在这种解体中最严重的就是文化的解体。我们是否想过我们的村庄是如何形成的？我们应该建设什么样的村子？在目前的时代环境下，当一个地方的政治、经济处于附属地位时，它的文化就会面临解体的危险，不管这种文化曾经是怎么样的、不管它现在看来显得多么落后与过时。我们可能已经感觉到过去的文化、传统正在不断消失，而新的称之为‘文化’的东西只不过是经济的奴隶。这种现象小到一个村子，大到一个国家。在一个文化处于附属地位或者被解体的环境中，人与人之间关系也会解体，因为文化本身是一种凝聚的力量。伴随而来的就是人与人之间的不信任，以及更严重的导致创造力的普遍缺失。对于这种环境下的儿童，就很难培养自信和创造力，热情和勇气也会随之缺失。</p>
<p>&emsp;&emsp;现代城市又如何呢？现代城市中的文化本身几乎也都是外来强势文化和本地弱势传统文化的一种不和谐的融合，处于一种“隔”的状态。再加上我们越来越多的人处于‘解体移民’的大潮中，向现代城市转移，那我们是否还有心去创造自己的文化？城市的经济几乎都是非自然的经济。越是原始的经济结构就越能产生原始的群体部落;反之，越是结构化、协议化的经济就越能产生非自然的社会组织。而任何文化的构建，在我看来，都与自然有着紧密的联系，自然的心灵是一种‘不隔。协调‘隔’与‘不隔’是现代城市生活中的每一个人必须面对的问题。</p>
<p>&emsp;&emsp;我们如何看待自己的过去呢？如果我们认为过去儿时的某种快乐、幸福正在消失，不要轻易把它归结为进入成年后的正常现象。对这种‘正常现象’一旦习以为常，我们自身心灵的文化主体意识就会不断衰退。<br>&emsp;&emsp;我们为什么要建立自己的文化主体意识呢？什么是文化主体意识呢？在我看来，人类一切实践活动和创造活动并经过传承的精神性或物质性的东西都可以称之为文化。在现实世界，甚至虚拟世界中都包含着许许多多的文化部落，在社会的各个领域，几乎都是如此。在人类世界，文化促成凝聚，进而产生力量，而这种力量创造了我们今天的文明。我们每个人都可以成为文化的主体，但它绝不是单纯精神或者艺术性的东西，它同样包含切实的实践，种上一棵树、栽上一颗花、拍一张照片、写上一些字，甚至做一件勇敢的小事件等等，这些我们都可以称之为文化主体意识。在一些精神性、智力要求更高的领域，比如数学等，它的文化是人们获取该领域的创造力不可或却的来源。</p>
<p>&emsp;&emsp;所以，不管城市或者乡村，我们都不应该是一种附庸或者旁观的地位或态度。不管我们‘移’到那里，都要试着把根深深扎到那里的土地，而终有一天可成为参天大树。而那些将自己的双脚远离大地的人，就再也不能仰望星空了，而且或许会迷失在宇宙的黑暗中去了。</p>
]]></content>
      <categories>
        <category>散文创作</category>
      </categories>
  </entry>
  <entry>
    <title>智能硬件设备固件提取和分析</title>
    <url>/2022/02/18/%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; 现代智能设备大都使用 Flash&#x2F;EEPROM 芯片来存储固件，这些芯片的容量已经足够大，甚至可以容纳小型的操作系统。固件提取和分析技术可以使我们有能力对系统作出更改或者调整，甚至将整个固件进行替换。但对于很多设备来说，其安全性要求较高，其采取的安全加密和校验手段对分析人员提出了很大的阻碍，所以这项任务充满了困难，但也可能是充满乐趣和挑战的过程。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://www.kancloud.cn/geiyu86/iot-security-wiki/1836200">物联网安全百科</a></p>
</blockquote>
<h2 id="物理提取"><a href="#物理提取" class="headerlink" title="物理提取"></a>物理提取</h2><p><strong>软&#x2F;硬工具</strong>：</p>
<p>a. <code>CH341A</code> 微型编程器<br>b. <code>flashrom</code> 软件 ：<code>sudo apt-get install flashrom</code></p>
<p><strong>命令：</strong></p>
<ul>
<li><code>flashrom --programmer=ch341a_spi</code> 探测设备</li>
<li><code>flashrom --programmer=ch341a_spi -c &lt;设备类型&gt; --read &lt;file&gt;</code> 读取固件</li>
<li><code>flashrom --programmer=ch341a_spi -c &lt;设备类型&gt; --write &lt;file&gt;</code> 烧录固件</li>
</ul>
<h2 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h2><p><code>binwalk</code> :  <code>binwalk -e xxxxx.bin</code></p>
<h2 id="Flash-操作工具"><a href="#Flash-操作工具" class="headerlink" title="Flash 操作工具"></a>Flash 操作工具</h2><p>安装 <code>mtd-utils</code> 工具</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>求知之心</title>
    <url>/2020/04/18/%E6%B1%82%E7%9F%A5%E4%B9%8B%E5%BF%83/</url>
    <content><![CDATA[<p>&emsp;&emsp;我们是否还有求知之心？</p>
<span id="more"></span>


<p>&emsp;&emsp;自卑之心不可求知。自卑者所寻求的只是让自己摆脱卑微的东西。自卑者极易产生对其他人或事物是否真诚的不信任，而陷入一种盲目的怀疑和排斥中。这种心境很容易产生将事物和自己对立起来的思维习惯，进而再也看不到事物的真实，这样的话又如何求知呢？这种心境也会助长恐惧，容易使人变得软弱。几乎对于所有人来说，自卑是缺乏自我认识的表现，而深刻的自我认识是学习的基础，而这种认识并不依托物质、财富和地位，也不依赖任何特定的知识。<br>&emsp;&emsp;恐惧之心不可求知。这里所说的主要是一种对自己所追求的是无价值的恐惧，或者说是一种因无用而觉得会被孤立的恐惧，它也是一种担心不被认可的恐惧。在我们今天看来很有价值的东西，在其出现的时代却被认定是‘异端邪说’或者‘毫无用处’的例子比比皆是。我们内在对自己的认可要远比外在的认可重要，但并不代表我们盲目否定外在的看法。我们喜欢的东西可能永远不能给我们带来半毛钱的利益，但那又如何呢！<br>&emsp;&emsp;依赖之心不可求知。依赖有很多形式，它绝不仅仅是指依赖权威等某种有形的东西，更多情况下它指得是某种传统的信仰、观念和道德等无形的东西。我们说，我们可以站在巨人的肩膀上继续前行，但那绝不是依赖，一旦我们发现这个巨人站在错误的地方，我们就决然地将它推倒。对于我们来说，几乎没有所谓的绝对的、一帆风顺的道路，我们可以也敢于去走一条属于我们自己的与众不同的道路。<br>&emsp;&emsp;忧虑之心不可求知。忧虑往往来源于责任，家庭责任也好，社会责任等也好。但忧虑并不能给我们掌握我们生活和工作的全部提供什么帮助，而掌握生活和工作的全部是我们追求现实幸福的主要方式。忧虑其实也是患得患失的表现，其实没有得失就没有事物的平衡，我们做的每一个选择几乎都是得失的选择。<br>&emsp;&emsp;功利之心不可求知。这里的功利不是指实用主义，实用主义者更多的是关注问题而不是利益，至少不是狭隘的个人利益，很多时候它表现为不断地解决问题而可以帮助其他人。无方向的功利之心很容易助长对权威的依赖之心，以及学习上的教条主义和盲目依赖记忆的学习方式，更不要说面对困难时的脆弱和忧虑。有方向的功利之心很容易形成对知识的贪欲。<br>&emsp;&emsp;贪欲之心不可求知。这里所说的对知识的贪欲有着两面性。一方面它可以催生一些创造性的成就；但另一方面它就像速成食品，以及和其他贪婪形式一样，很容易失去自我。这种心境远离自然、和谐与美。</p>
<p>&emsp;&emsp;我们如何培养求知之心？<br>&emsp;&emsp;审美之心。在我看来，审美之心是最重要和最基础的东西。这里所说的审美绝不是肤浅地停留在表象的东西，而是包括创造美和对美的强烈感受力以及不懈追求。在现代科学文明的思想根源——古希腊的哲学家那里，美一直占有极其重要的地位。他们认为，宇宙的设计是严格遵循几何原理的，是由最简单的几何对象构造而成的，那是美的。他们又说，万物皆数，这种设计是最美的。后来的数学家说，丑陋在数学中没有栖身之地。虽然从历史的角度看，过度追求美学在很多情况下成为思想家认识世界的一种局限，但它仍然赋予了不同时代大量的哲学家、数学家、科学家和艺术家直观的创造力。在工程设计中，优雅和美也几乎被普遍认为是评价设计优劣的最高标准，其次才是是否满足需求。美同样是一种联结力量。在我看来，人与人之间以及人与外在世界之间情感联系的核心就是美，但这种美绝不仅仅是表象的东西，品格之美、精神之美始终是人与人之间美的核心。爱只是美的表现形式。<br>&emsp;&emsp;好奇与探索之心。学习应该就是发现未知的新的东西。我们越是自己去追问、去探索、去实践，我们就越能获得快乐。那些教条式的学习其实是在剥夺我们的快乐。很多时候，对万事万物的好奇心都离不开我们对自己的好奇心，所以，摧毁一个人的好奇心只要使他（她）不再对自己感兴趣就可以了。而上面的众多不可求知之心其实都在起着这个作用。我们对任何我们不熟悉的或者未知的领域都可以提出核心的、基本的问题，而并不需要急于解答。这些核心问题并没有锁在政客的保险箱或埋在学者的浩繁纸堆中。<br>&emsp;&emsp;勇敢与不屈服之心。我们几乎都体验过有一个学习的竞争对手实际上是多么快乐的事情。竞争在个人学习和成长中实际上发挥着巨大作用，我们可以寻找现实世界或者虚拟世界的对手，并向其发起一次次挑战或者抛出一系列问题来让自己回答，如此往复，就可以激发个人的潜能，增强面对困难的勇气和信心。即使多次失败，仍然不气馁，继续努力。擅于提出问题来找出对方思维方式或者行为做法上的‘漏洞’或者弱点。古人说，虽千万人吾往矣！坚持自己的观点就是一种勇敢。<br>&emsp;&emsp;快乐与乐观之心。快乐是很重要的，但并不代表在不快乐时表现的那种无法面对困难的脆弱。乐观使得我们面对困难不但不会退缩，反而会变得兴奋。<br>&emsp;&emsp;责任之心。将责任放在最后，是因为它有着更突出的两面性。因为责任产生的往往不是内在的发自我们真实情感的行为，而是外在环境作用下的行为。特别是责任越大，越容易使人在思想和行为上落入虚荣的陷阱。某种程度上来说，一个人越是想要承担更大的责任，就越想要建立自己的权威，而权威很容易使人腐化和虚荣。我们不止一次听过那种以‘救世主’自居的论调吧！但无论怎样，对于古往今来大多数卓越的有识之士来说，我们都可以相信他（她）们抱有对某种东西有着不可推卸的责任，这种东西是某个家庭或者群体的利益也好，某种信念也好，某种思想也好。这种责任发自我们内心真实的情感，也就是包含了上面所说的几种品质，所以持久、自然和充满力量。</p>
<p>&emsp;&emsp;读书与求知的关系。<br>&emsp;&emsp;读书是求知很重要的方式，但不是它的全部内容。我们很多时候会陷入对书籍的贪欲之中，这很容易成为一种依赖方式，或者说一种自我安慰的方式。有多少读书人、学者皓首穷经，埋头纸堆呢？然后却没有提出任何新的有普遍价值的东西。近代科学的诞生其实就伴随着对这种求知方式的反叛，它注重实践和从实际经验中总结普遍规律，并不断在实践中加以验证和完善。</p>
<p>—— 顽石 2020.04.18</p>
]]></content>
      <categories>
        <category>散文创作</category>
      </categories>
  </entry>
  <entry>
    <title>[经典论文]Bitcoin: A Peer-to-Peer Electronic Cash System</title>
    <url>/2024/12/31/%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87-Bitcoin-A-Peer-to-Peer-Electronic-Cash-System/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>中本聪发布于 2008 年的论文：<a href="https://bitcoin.org/bitcoin.pdf">Bitcoin: A Peer-to-Peer Electronic Cash System</a> 首次提出了比特币的概念。该论文介绍的关键思想是一种完全的点对点电子现金，对等体之间转移付款不需要第三方信任体(Trusted Third party)。</p>
<p>比特币所使用的技术并非都是新的，而是建立在数十年的密码学和分布式网络等技术之上的，包括默克尔树、哈希函数、公钥密钥学和数学签名等。另外，<strong>BitGold</strong>、<strong>B-money</strong>、<strong>HashCash</strong> 和<strong>加密时间戳记</strong>等技术也为比特币提供了理论基础。</p>
<p>比特币中已经解决的关键问题包括：<code>双重支付问题(double-spending problem)</code> 的实用解决方案和<code>拜占庭将军问题</code>的解决方案。</p>
<span id="more"></span>

<h2 id="共识及其证明"><a href="#共识及其证明" class="headerlink" title="共识及其证明"></a>共识及其证明</h2><p>共识机制（consensus mechanism）<br>赌徒破产问题</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>隔与不隔</title>
    <url>/2020/07/17/%E9%9A%94%E4%B8%8E%E4%B8%8D%E9%9A%94/</url>
    <content><![CDATA[<p>&emsp;&emsp;什么是隔？什么是不隔？<br>&emsp;&emsp;我们很容易明白房子是隔，窗户是不隔，这种隔与不隔的设计理念遍布在各种领域。特别是对于中国古代的园林，这种理念发挥得淋漓尽致:镂空的窗户、似透非透的围墙、曲折的小径、以水为核心的动静结合等，比比皆是。</p>
<span id="more"></span>
<p>&emsp;&emsp;我们为什么要去理解隔与不隔？<br>&emsp;&emsp;凡是人所创造的东西都反映着人的心灵，而人的心灵，在我看来，就是隔与不隔的一种混合。<br>&emsp;&emsp;在现代商业环境下诞生的东西很多都摆脱不了“隔”的命运，这种产品强调排它性来建立自己的优越感，优越是一种“隔”。这种“隔”被包装以后很容易演变成“精致”，而“精致”从来都不等于美，在我看来，美是隔与不隔的自然协调，它需要时间、耐心和痛苦的追寻。我们很多时候意识不到精致和美的区别，一味追求精致只会使心灵趋向“隔”的境地，远离自然，远离美。<br>&emsp;&emsp;不隔如水，隔如土，只有水土融合才有创造的力量。隔促进结构化，不隔反结构化。水具有融合的力量，更重要的是，它代表着在古人看来心灵的最高境界;但水的反结构化力量却象征着一种社会的变革，这种变革的隐喻在一些宗教神话里强化到了“末日预言”的地步，这种预言说世界将被大水淹没，所有的土地房屋被摧毁，然后大水退去，世界重新开始。这种预言其实是在表明对社会结构化（往往被说成是人的罪恶）的一种排斥和反抗。<br>&emsp;&emsp;现代城市几乎很难处理隔与不隔的协调，生活在其中的人更难使得自己的心灵宁静。我们是否思考过自己对城市的看法？我们是否思考过对城市是否有感情？我们为什么要建造城市？我们为什么对自己的家乡有很深的感情？家乡是否代表着我们心灵中不隔的重要部分。我们如何在城市的生活中不隔呢？我们是否走过城市的每一条街道，每一座桥，记住它们的名字？我们是否看过城市中每一个人他（她）们的面容？我们是否想象过自己是服务生、快递员、店铺小商人、保安、交警、保洁员、流浪汉甚至乞讨者？我们是否观察过路边的树、落叶、飞鸟、河流和墙边的小虫？<br>&emsp;&emsp;当我们开始思考这些问题的时候实际上我们的心灵就在“不隔”，而这种隔与不隔的协调对于我们任何人来说都不应该是被忽略的事情，我们越早去发现它，它就越早对我们产生重要的意义。</p>
<p>—— 顽石 2020.07.17</p>
]]></content>
      <categories>
        <category>散文创作</category>
      </categories>
  </entry>
  <entry>
    <title>黑客文化</title>
    <url>/2021/03/27/%E9%BB%91%E5%AE%A2%E6%96%87%E5%8C%96/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;最近重读《黑客：计算机革命的英雄》一书，仍然有不少收获。几年前第一次阅读时的那种非凡的知识、历史和思想感染仍记忆犹新。它完全没有那种普通人对黑客的一种片面和局限的理解，这种理解往往由网络入侵、信息窃取和犯罪等灰暗面组成，而其很大部分来自于新闻媒体的一种带有‘猎奇心理’的宣传。</p>
<span id="more"></span>
<p>&emsp;&emsp;相反，它描述了一些个性鲜明、具有强烈热情和探索精神的‘英雄’人物，他们代表了最传统、最纯粹的黑客精神，是一种带有强烈理想主义的计算机文化的重要组成部分，这种精神贯穿了整个计算机领域发展的历史，更重要的是它和其他任何一种文化形式相同，即它是一种发展的内在动力。<br>&emsp;&emsp;可以说，我们每一天都在使用着、领略着这些‘英雄’人物带给世界的变革所带来的新的思想、新的方法、新的作品。<br>&emsp;&emsp;&emsp;&emsp;</p>
<h3 id="第一代真正的黑客"><a href="#第一代真正的黑客" class="headerlink" title="第一代真正的黑客"></a>第一代真正的黑客</h3><p>TMRC俱乐部<br>太空大战: <a href="https://www.masswerk.at/spacewar/">第一款Spacewar模拟网站</a><br><a href="https://www.spacewaronline.com/">SpacewarOnline</a><br><a href="https://spacewar.oversigma.com/">Spacewar模拟</a>包含源代码</p>
<h3 id="第二代硬件黑客"><a href="#第二代硬件黑客" class="headerlink" title="第二代硬件黑客"></a>第二代硬件黑客</h3><h3 id="第三代游戏黑客"><a href="#第三代游戏黑客" class="headerlink" title="第三代游戏黑客"></a>第三代游戏黑客</h3><h3 id="黑客伦理"><a href="#黑客伦理" class="headerlink" title="黑客伦理"></a>黑客伦理</h3><p>I．对计算机的访问（以及任何可能帮助你认识我们这个世界的事物）应该是不受限制的、完全的。任何人都有动手尝试的权力。<br>II．所有的信息都应该可以自由获取。<br>III．不迷信权威－－促进分权。<br>IV．评判黑客的标准应该是他们的技术，而不是那些没有实际用途的指标，比如学位、年龄、种族和职位。<br>V．你可以在计算机上创造艺术和美。<br>VI．计算机可以让你的生活更美好。<br>VII．就像阿拉丁神灯，你可以让它听从你的召唤。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>1.<a href="http://www.dnbwg.com/">电脑古董室</a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>FreeRTOS 介绍</title>
    <url>/2022/06/01/FreeRTOS-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;<a href="https://www.freertos.org/zh-cn-cmn-s/">FreeRTOS</a> 是<code>实时操作系统(RTOS)</code>的一种，它非常小巧，被专门设计运行在 MCU 上。<code>FreeRTOS (kernel)</code> 只提供核心的<strong>实时调度</strong>、<strong>内部任务通信</strong>、<strong>定时器</strong>和<strong>同步原语</strong>，所以更准确地说它是一个实时内核。它的一些特性包括：</p>
<span id="more"></span>

<ul>
<li>支持40多种架构，为这些不同架构和开发工具提供同一的解决方案。</li>
<li>可靠，可裁减、简单易用。</li>
<li>包含丰富的特性和活跃的持续开发。</li>
<li>资源占用非常小。通常，一个二进制的 kernel image 只占用 6k-12k 字节。</li>
<li>非常简单小巧。内核的核心部分只包含 3 个 C 文件(<code>tasks.c</code>、<code>queue.c</code>和<code>list.c</code>)。</li>
<li>完全 <strong>free</strong> 。</li>
<li>可以迁移到 <a href="https://www.highintegritysystems.com/">SafeRTOS</a>。</li>
<li>稳定且仍在增长的用户群。</li>
<li>详细完整的示例以及支持论坛。</li>
</ul>
<blockquote>
<p>下文部分参考 <a href="https://www.freertos.org/RTOS.html">FreeRTOS - 官方文档</a>。</p>
</blockquote>
<h3 id="基本原理-Fundamentals"><a href="#基本原理-Fundamentals" class="headerlink" title="基本原理(Fundamentals)"></a>基本原理(Fundamentals)</h3><h4 id="多任务-Multitasking"><a href="#多任务-Multitasking" class="headerlink" title="多任务(Multitasking)"></a>多任务(Multitasking)</h4><p>多任务是现代操作系统的基本特性，它是一种降低系统设计复杂性的抽象方法：</p>
<ul>
<li>多任务和任务间内部通信特性可以使得复杂应用被分解为更小、更易管理的子应用。</li>
<li>这种任务的划分便于进行软件测试，团队协作和代码重用。</li>
<li>任务间复杂的时序或执行顺序问题可以交给操作系统来完成。</li>
</ul>
<h4 id="调度-Scheduling"><a href="#调度-Scheduling" class="headerlink" title="调度(Scheduling)"></a>调度(Scheduling)</h4><p>&emsp;&emsp;调度模块是<code>多任务 os </code>的核心，调度算法及实现的优劣直接影响系统的多方面性能，比如吞吐率、实时性、可靠性等。不同的场景可能会采取不同的调度策略(Policy)。对于非实时（no-realtime）多用户系统，每个任务被分配 <em>接近公平</em> 的CPU资源，高优先级的任务可以获得 <em>软实时</em> 能力，及操作系统会尽量优先执行该任务，但不保证满足该任务的时间延迟或者响应要求。<strong>RTOS</strong> 则提供 <em>硬实时</em> 特性，它保证满足任务的严格的时间约束、响应及可预测的行为。</p>
<h4 id="上下文切换-Context-Switching"><a href="#上下文切换-Context-Switching" class="headerlink" title="上下文切换(Context Switching)"></a>上下文切换(Context Switching)</h4><p>&emsp;&emsp;每个任务都是任务代码和任务环境的一种抽象，任务环境就是当前任务所占用的资源：包括寄存器、RAM(栈)、ROM、IO端口等。所以当一个任务被内核暂停（suspended）前，内核会负责保存任务的执行环境，当该任务重新调度执行时，再进行恢复。这种机制形成一种每个任务都独占计算资源的假象。切换的效率以及频率会影响系统的实时性能。<br>&emsp;&emsp; <strong>注意上下文切换与中断的区别，上下文切换可能由中断触发，例如SysTick，但在其他情况下，可由用户编写软件来完成，即它可以是一种软件特性。</strong></p>
<h4 id="实时应用"><a href="#实时应用" class="headerlink" title="实时应用"></a>实时应用</h4><p>&emsp;&emsp;在现实世界，很多事件必须在严格时间内获得响应，这个时间称为 <strong>deadline</strong>，实时&#x2F;嵌入式系统的调度策略则是必须满足事件的 <strong>deadline</strong> 。实时调度策略首先可以是基于 <strong>优先级</strong>的，高优先级任务可以<strong>抢占</strong>低优先级任务，而相同优先级的任务则进行 “公平” 调度。优先级的分配一般由用户完成。例如，<code>EDF</code> 调度算法是一种基本的实时调度算法，它优先调度 <strong>deadline</strong> 最早的任务，但该算法需要已知所有任务的 <strong>deadline</strong>。</p>
<h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><p>FreeRTOS 的任务类似于非RTOS（例如<code>Linux</code>）中的线程，每个任务都有自己独立的栈，但可以同步访问共享数据（例如信号量、共享队列、互斥锁、事件组等）。内核调度器负责在不同任务间进行切换。每个任务在内核中都对应一个 <code>TCB</code> 数据结构，<code>TCB</code>中会包含任务的栈指针、优先级、状态、计数器等信息，这些信息可以被调度器使用，来进行任务切换。</p>
<p><strong>状态：</strong><br>任务的状态转换如下：</p>
<img src="https://www.freertos.org/fr-content-src/uploads/2018/07/tskstate.gif" width="50%">  

<p><strong>优先级：</strong><br>任务的优先级范围是：<code>0</code> - <code>configMAX_PRIORITIES - 1</code>，<strong>值越小优先级也越小。</strong>** idle task**的优先级为0。</p>
<p><code>要特别注意任务优先级和中断优先级的区别:</code></p>
<ul>
<li>任务是一种<strong>软件特性</strong>，它的优先级由应用开发者指定，并由软件算法（调度器）来决定哪一个任务进入<code>Running</code>状态。它和 正在运行 FreeRTOS 的硬件无关。</li>
<li><code>ISR</code> 虽然使用软件编写，但却是<strong>硬件特性</strong>，因为硬件将控制哪一个 ISR 运行以及什么时候运行。以 TM4C123GH6PM 为例，它包含很多中断事件，例如 <code>GPIO</code>、<code>UART</code>、<code>Timer</code>、<code>ADC/DAC</code>、<code>SysTick</code>、<code>PWM</code>等，这些事件的中断优先级由 NVIC 等相关寄存器设置和管理。任何一个任务只有在当前没有 <code>ISR</code> 运行的情况下才能运行，<strong>即最低优先级的中断也可以抢占最高优先级的任务，反之不行。</strong></li>
</ul>
<p><strong>调度:</strong><br>单核下默认的调度策略：</p>
<ul>
<li>优先级固定：任务的优先级一旦确认就不再改变；相比而言，Linux 内核采用一种<code>动态优先级策略</code>，动态优先级有很多优点，但稍显复杂。</li>
<li>可抢占：优先级高的任务总是可以抢占优先级低的任务。</li>
<li>时间片：对于优先级相同的任务，调度器会在每个 tick 中断时进行切换。相邻 tick 中断的时间间隔称为一个时间片。</li>
</ul>
<p>&emsp;&emsp;抢占策略容易产生<strong>饥饿</strong>问题，即低优先级任务可能长时间不能被调度。在Linux系统上，使用 <strong>Aged</strong>策略来解决饥饿问题，但 FreeRTOS 将问题的解决交给用户：高优先级的任务在等待事件时要<code>主动放弃 CPU（Blocked）</code>，而不是<code>忙等（Busy-loop-wait）</code>。当事件发生时，可以利用任务间通信机制和同步原语来唤醒高优先级任务。这种模型称为<strong>事件驱动</strong>编程模型。</p>
<p>AMP下调度策略：每个 core 上运行单独的 FreeRTOS 实例，因此每个 core 的调度策略与上面相同。</p>
<p>SMP下调度策略：SMP下只有单个 FreeRTOS 实例，因此调度策略与上面大体相同，只是允许多个任务进入 <code>Running</code> 状态，这些任务或被分配到不同的 core 上运行。，高优先级任务和低优先级任务可能在不同 core 上<strong>并行</strong>执行。在SMP下，任务可以设置 <code>configUSE_CORE_AFFINITY</code> 来强制自己在特定 core 上运行。</p>
<p><strong>空闲任务：</strong><br>&emsp;&emsp;<strong>Idle Task</strong> 是 FreeRTOS 启动调度时自动生成的任务，确保当前至少有一个任务可以运行。该任务的优先级最低，它负责回收被删除任务的内存。其他任务也可以设定为与空闲任务相同的优先级，但这些任务的行为可以通过配置 <code>configIDLE_SHOULD_YIELD</code> 来调整。但很多情况下，尽量将任务的优先级设置高于空闲任务的优先级。如果用户想要一些应用运行在最低优先级，则有两种选择，一是使用空闲任务挂钩 <code>void vApplicationIdleHook( void )</code>，<strong>该回调函数不能阻塞</strong>；二是生成最小优先级的新任务，但这种做法更加消耗内存。</p>
<h3 id="队列、互斥量和信号量"><a href="#队列、互斥量和信号量" class="headerlink" title="队列、互斥量和信号量"></a>队列、互斥量和信号量</h3><p>&emsp;&emsp;<code>queue</code> 是主要的任务间通信形式，可以把它看作线程安全的 <code>FIFO</code>。消息是被拷贝进入 <code>queue</code> 的，而不是仅仅在<code>queue</code>中放入消息数据的引用。</p>
<ul>
<li>小的消息可以直接包含在 c 变量中，这些变量可以直接被发送到 queue 或者从 queue 中读取，不需要中间过程。</li>
<li>变量本身仍可以马上重用，因为它先前的数据已经拷贝到 queue 中。</li>
<li>当然，queue 也可以传递指针或者引用，特别是当指针指向的数据块较大时，例如 UDP 网络数据包。</li>
<li>queue 内存的分配完全交由内核管理。</li>
<li>支持可变字节的消息，queue 支持特殊的结构体，该结构体中可以存放消息的具体大小。</li>
<li>支持不同类型的消息，这由特殊的结构体来支持。消息的解析也根据消息类型来进行。</li>
<li>这种实现适合在带有内存保护的环境中使用。通过 queue 可以在不同保护区内传递消息，因为 queue 工作在内核特权级别，它可以进入所有保护区。</li>
<li>使得 API 更简单。</li>
</ul>
<p>&emsp;&emsp;任务读空 queue 或者写已经满的 queue 都会阻塞（进入 <code>Blocked状态</code>）。当有多个任务阻塞在 queue 上时，高优先级的任务在 queue 可访问时首先被唤醒。</p>
<p>&emsp;&emsp;<code>二进制信号量</code>可以用于任务间同步，更重要的是任务不会在信号量上忙等，如果信号量被占用，任务会在信号量上阻塞（Blcoked），进而不再占用CPU资源。<br><code>计数信号量</code>用于多个共享资源的访问，也可以用于特殊的读者-写者问题。</p>
<p>&emsp;&emsp;<code>互斥体</code>是包含优先级继承机制的二进制信号量，<strong>互斥体更适合用于资源的互斥访问</strong>。（互斥体的优先级集成机制可以解决可能发生的<strong>死锁</strong>问题。）即一个高优先级的任务在某个互斥体上阻塞，因为该互斥体已经被一个低优先级的任务占用，那么占用者的优先级会被临时提高到阻塞者的优先级。这样做可以尽量减少高优先级任务的阻塞时间，也可以尽量减少低优先级任务的“优先级反转”。</p>
<p>注意，<code>queue</code> 和<code>二进制信号量</code>也可以用于中断与任务间通信，但在中断中,同步原语 API 函数要使用以 <code>FromISR</code> 结尾的。<br><code>互斥体</code>不应该在中断中使用。&#96;</p>
<h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><p>&emsp;&emsp;每个任务都有一组任务通知（<em>task notifications</em>），每个任务通知都有一个通知状态，<em>pending</em>或者<em>no-pending</em>。事件可以直接发送到任务通知，此时任务通知的状态变为<em>pending</em>，而不用通过中间机制，即如 queue。任务可以阻塞在某个通知上，直到该通知状态因事件而变为<em>pending</em>。注意，任务在任何时间只能阻塞在一个通知上。</p>
<p>任务通知相比其他中间机制有着性能优势，但使用时也有下面的限制：</p>
<ul>
<li><strong>事件的接收者只有一个</strong>。</li>
<li><strong>当接收者阻塞在通知上时，发送者在发送未完成前不能阻塞</strong>。</li>
</ul>
<p>在下面的场景,则不能使用任务通知:</p>
<ul>
<li>向 ISR 发送事件或者数据</li>
<li>当有多个事件接收者时</li>
</ul>
<h3 id="流和消息缓存"><a href="#流和消息缓存" class="headerlink" title="流和消息缓存"></a>流和消息缓存</h3><p>&emsp;&emsp;<code>Stream 缓存</code>用于任务间或者任务与中断间通信，它被优化用于<code>单写者-单读者场景</code>。但对于多个写任务或者多个读任务，它不是线程安全的。<strong>流</strong>是面向字节的，即可以读写任意长度的字节，类似于<code>socket</code>。<code>Stream 缓存</code>使用任务通知，因此调用其 API 函数会使得任务阻塞，也会改变该任务的任务通知的状态。<br>&emsp;&emsp;<code>Trigger Level</code>被阻塞任务设置，如果一个读任务阻塞在空的 Stream 上，除非 Strem 中有这么多字节，该阻塞任务不会被唤醒。当然，如果任务在调用 API 函数时设置了超时值，超时后仍然没有满足<code>Trigger Level</code>，那么 API 返回当前已经可用的字节数据。</p>
<p>&emsp;&emsp;<code>Message缓存</code>工作在<code>Stream缓存</code>的上层，它是面向消息的，且消息的长度可变。</p>
<p>&emsp;&emsp;<code>在中断中，API函数要使用以 &quot;FromISR&quot; 结尾的。</code></p>
<h3 id="软定时器"><a href="#软定时器" class="headerlink" title="软定时器"></a>软定时器</h3><p>&emsp;&emsp; FreeRTOS 的软定时器的回调函数<strong>不工作</strong>在中断上下文中，而是<strong>工作</strong>在 <em>Timer service Task</em> 的上下文中。这与很多定时器的机制不太相同。当然，回调函数不同阻塞。<code>Timer</code> 的很多 API 都是利用一个 queue 来向<em>Timer service Task</em> 发送命令，这个 queue 是私有的，其他任务不能直接访问。Timer 需要在使用前进行配置，比如 <em>Timer service Task</em> 的优先级、私有命令 queue 的长度、栈大小。<em>one-shot</em>定时器只执行一次，<em>auto-loaded</em>定时器是周期性定时器。<br>&emsp;&emsp;<strong>要特别注意<code>软Timer</code>和<code>硬Timer</code>的区别</strong>。</p>
<h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><h3 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h3><p><code>FreeRTOSConfig.h</code>中包含所有的定制选项，任何应用都要包含该文件。这些配置选项包括：</p>
<ul>
<li>抢占调度或者协作调度、任务最大优先级、时间片、<strong>内核中断优先级</strong></li>
<li>一些回调函数：内存分配失败回调、Daemon任务启动回调、Tick回调</li>
<li>内部时钟频率以及 Tick 变量大小</li>
<li>Tick 中断频率</li>
<li>软定时器、定时器 daemon 任务的优先级、定时器命令队列长度、Daemon任务的栈深度</li>
<li>最小的栈空间、栈溢出检查、栈深度类型、栈类型</li>
<li>使能任务通知、互斥体、递归互斥体、计数信号量、队列</li>
<li>静态内存分配（如果设置则必须手动为 <code>Idle任务</code> 和<code>Timer任务</code>实现内存分配函数）</li>
<li>动态内存分配、堆大小、堆类型（FreeRTOS 堆或者用户堆）</li>
<li>SMP支持</li>
<li>面向特定架构的选项</li>
<li>其他</li>
</ul>
<p><strong>任何使用 FreeRTOS API 的中断都必须设置与内核相同的优先级（configKERNEL_INTERRUPT_PRIORITY）。</strong></p>
<h3 id="静态内存分配和动态内存分配"><a href="#静态内存分配和动态内存分配" class="headerlink" title="静态内存分配和动态内存分配"></a>静态内存分配和动态内存分配</h3><p>动态分配的特性：</p>
<ul>
<li>可以很大程度上较少内存的使用</li>
<li>对象生成函数更加简单</li>
<li>用户不需要自己分配内存，对象由内核动态生成，如：task、软timer、队列、事件组、信号量、互斥体等。</li>
<li>可以动态监控堆大小进而进行优化</li>
<li>对象释放后，所占用的内存可以重用</li>
<li>可选的动态内存分配策略</li>
</ul>
<p>静态分配的特性：</p>
<ul>
<li>对象可以放置在特定的内存位置</li>
<li>最大内存空间可以在链接时决定</li>
<li>不需要处理内存分配错误的处理</li>
<li>其他</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>&emsp;&emsp;FreeRTOS 的内存管理比较灵活，它没有设置单一的分配策略，而是将内存分配模块放到可移植层，即用户可以根据自己的实际情况使用不同的分配策略。</p>
<ul>
<li><strong>heap_1.c</strong>：最简单，内存一旦分配不允许释放。适用于：不需要释放对象的应用；行为确定（执行时间总是很稳定）和不会导致内存碎片化的应用；不需要或者不允许动态内存分配到应用。</li>
<li><strong>heap_2.c</strong>：使用<strong>Best fit 算法</strong>，允许分配的内存被释放。适用于动态内存分配大小总是不变的任务（且重复生成和释放对象），否则如果内存分配大小比较随机或者不稳定，则很容易导致内存碎片化。这种实现并不是确定性（deterministic）的，但比一些标准的 malloc实现更有效。</li>
<li><strong>heap_3.c</strong>：malloc和free的包装器，使其线程安全。这种实现也不是确定性的，而且需要编译库（例如libc）的支持，也可能增加内核代码的大小。</li>
<li><strong>heap_4.c</strong>：使用<strong>first fit算法</strong>，而且它会自动将紧邻的空闲区进行合并（使用一些合并算法。）适用于重复性生成和释放对象的应用，与<code>heap_2.c</code>中的实现相比，内存分配大小比较随机时，它的内存碎片化问题大大改善。它也不是确定性的，但比一些标准的 malloc 实现更有效。</li>
<li><strong>heap_5.c</strong>：使用<strong>first fit算法</strong>和<strong>合并算法</strong>，但允许堆分配在不连续的内存区域。</li>
</ul>
<h3 id="栈使用以及内存溢出检测"><a href="#栈使用以及内存溢出检测" class="headerlink" title="栈使用以及内存溢出检测"></a>栈使用以及内存溢出检测</h3><p>&emsp;&emsp;每个任务的栈可以动态分配或者静态分配。内存溢出检测可以在开发与测试阶段使用。方法：</p>
<ul>
<li>由内核在上下文切换的时候检测任务的栈指针是否在合法的栈空间。如果超出了合法空间，一个回调函数将被调用。这种方法不保证可以捕获所有的栈溢出。</li>
<li>使用已知的值初始化栈，并且在上下文切换的时候检测栈空间的最后16个字节是否被重写，如果被重写，一个回调函数会被调用。这种方法类似于 <strong>金丝雀法</strong>。这种方法同样不保证可以捕获所有的栈溢出。</li>
</ul>
<h3 id="SMP支持"><a href="#SMP支持" class="headerlink" title="SMP支持"></a>SMP支持</h3><p>&emsp;&emsp;FreeRTOS API在单核和SMP下基本上是相同的，除了在SMP下增加了对core亲和性及抢占使能的API。在单核和SMP下编程，有些微妙的不同，例如在单核下可以通过设置不同的优先级来完成互斥访问，而在SMP下就不能成立了，因为不同优先级的任务可以并行运行，对共享资源的访问不再是互斥的。在这种情况下，用户可以采取的方法：一是使用同步原语进行互斥访问；二是强制相关任务不能并行，即让它们在同一个core上运行；三是配置FreeRTOS，使得只有相同优先级的任务才能并行，这样做或许使得某些core空闲而降低系统整体吞吐率。另外在SMP下，多个ISR或者ISR与任务间也可能并行，因此需要确保互斥访问。</p>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>FreeRTOS为下面的架构提供官方的MPU单元：</p>
<ul>
<li>ARMv7-M (Cortex-M3，Cortex-M4 和 Cortex-M7 微控制器)</li>
<li>ARMv8-M (Cortex-M23 and Cortex-M33 microcontroller) 核</li>
</ul>
<p>MPU的使用可以使系统获得更多安全特性，但也使得系统设计变得复杂。使用MPU可以将信任的代码与不信任的第三方代码分别运行在不同的内存空间。FreeRTOS的MPU模块支持将任务分为特权任务和非特权任务，特权任务可以访问整个内存空间，而非特权任务只能访问自己的栈空间和用户指定的其他有限的空间</p>
<h3 id="线程本地存储（TLS）"><a href="#线程本地存储（TLS）" class="headerlink" title="线程本地存储（TLS）"></a>线程本地存储（TLS）</h3><p>&emsp;&emsp;在单线程应用中，使用全局变量是方便的，但在多线程应用中，使用全局环境在很多时候是不适合的，每个线程都可能需要有自己独有的变量，这些变量可以存放在线程的控制块内。FreeRTOS使用线程本地存储指针数组来实现TLS。</p>
<h3 id="延迟中断处理"><a href="#延迟中断处理" class="headerlink" title="延迟中断处理"></a>延迟中断处理</h3><p>&emsp;&emsp;延迟中断处理大都适用于大数据传输的场景，这种场景下，如果所有的数据传输均在ISR中完成，则会使得系统实时性变差，也会使得系统变得脆弱。延迟中断处理是指ISR会唤醒一个任务，并让该任务去执行繁重的工作，自己可以很快退出。这种机制类似于Linux中断处理的 <em>top half</em> 和  <em>bottom half</em> 之分。</p>
<p>&emsp;&emsp; 延迟中断处理可以通过二进制信号量或者计数信号量等同步原语来实现。延迟中断处理可以使用单独的一个task或者使用 daemon task（使用 <em>xTimerPendFunctionCallFromISR</em>  API）。<strong>注意如果要使用队列，则必须视情况而定，如果数据接收频率很快，则队列不太适用，此时应使用DMA或者RAM buffer来提高效率和性能。</strong></p>
<p>&emsp;&emsp;*<em>特别注意：在ISR中调用 <em>_FromISR 函数可能会使得某个高优先级任务退出阻塞状态，这要不要进行上下文切换要视情况而定。注意使用 xHigherPriorityTaskWoken 参数。调用portYIELD_FROM_ISR 或者 portEND_SWITCHING_ISR函数，根据xHigherPriorityTaskWoken参数的值决定是否切换。</em></em></p>
<h3 id="事件组-Event-Groups"><a href="#事件组-Event-Groups" class="headerlink" title="事件组(Event Groups)"></a>事件组(Event Groups)</h3><p>&emsp;&emsp;<strong>Event Groups</strong> 有着和queue与信号量不同的特性:</p>
<ul>
<li>允许阻塞任务等待一个或者多个事件的发生</li>
<li>允许同时对多个任务解除阻塞，当这些任务正在等待同一个事件或者同一组事件</li>
</ul>
<p>这些特性对于<strong>多对多</strong>的模型很有用。另外，事件组可以减少内存消耗，比多个二进制信号量可以完全由一个事件组来替代。</p>
<h3 id="QEMU-模拟器"><a href="#QEMU-模拟器" class="headerlink" title="QEMU 模拟器"></a>QEMU 模拟器</h3><p>以MPS2为例，参考下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ qemu-system-arm -machine mps2-an385 -cpu cortex-m3 -kernel [path-to]/RTOSDemo.out -monitor none -nographic -serial stdio -s -S</span><br></pre></td></tr></table></figure>
<p>其中<code>[path-to]RTOSDemo.out</code>为编译 demo 生成的固件；<code>-s</code> 选项用于 gdb 调试，是选项<code>-gdb tcp:1234</code>的缩写形式。</p>
<p>然后安装  <strong>gdb-multiarch</strong> 包，安装后调用<code>gdb-multiarch</code> 打开新的会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb-multiarch</span><br><span class="line">gdb&gt; set architecture armv5te</span><br><span class="line">gdb&gt; target remote localhost:1234</span><br><span class="line">gdb&gt; continue</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>LLVM 1: IR 汇编语言参考</title>
    <url>/2023/02/18/LLVM-1-IR-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; <code>LLVM IR</code> 是基于 <strong>SSA</strong> 的 中间代码表示格式。它提供安全类型、底层操作、灵活性及完全性（能够自描述”所有”高级语言）。它也是 LLVM 编译框架中各个阶段间通用的代码表示形式。</p>
<p>&emsp;&emsp; LLVM IR 可以使用三种不同的格式：<code>in-memory</code>、<code>on-disk bitcode</code>和<code>汇编文本格式</code>。本文就第三种格式的 LLVM IR 做一些总结，更多信息见参考链接。</p>
<span id="more"></span>


<blockquote>
<p>参考<a href="https://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a>。<br>参考<a href="https://blog.csdn.net/qq_29674357/article/details/78731713">LLVM SSA 介绍</a>。</p>
</blockquote>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>&emsp;&emsp; LLVM 区分两种基本类型标识符：全局标识符和局部标识符。全局标识符（函数和全局变量）以<code>@</code>开头，局部标识符以<code>%</code>开头。另外在格式上又可以分为三类：</p>
<ul>
<li>命名标识符：带有<code>@</code>或<code>%</code>前缀的字符串，如<code>%foo</code>、<code>@bar123</code>等。</li>
<li>非命名标识符：带有<code>@</code>或<code>%</code>前缀的数字，如<code>%2</code>、<code>@42</code>等。</li>
<li>常量（<code>Constant</code>）</li>
</ul>
<p>所有<strong>保留字</strong>都不带<code>%</code>或<code>@</code>前缀，所有不会与变量标识符冲突。这些保留字包括操作类型关键字（如<code>add</code>、<code>bitcast</code>、<code>ret</code>等）、原语类型（如<code>void</code>、<code>i32</code>等）及其他。</p>
<p>所有以 <code>!</code>开头的为 <code>Metadata 标识符</code>。</p>
<p>另外，注释信息以 <code>;</code> 开头。</p>
<h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module(模块)"></a>Module(模块)</h3><p>LLVM 程序由各个<code>Module</code>组成，它是输入程序转换为 IR 后的顶层单元。<code>Module</code>包括函数、全局变量和符号表。不同的 <strong>Modules</strong> 可以被 <code>LLVM Linker</code>链接到一起。下面以 <strong>HelloWorld</strong>模块示例：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; Declare the string constant as a global constant.</span></span><br><span class="line"><span class="title">@.str</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">13</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;hello world\0A<span class="char escape_">\00</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; External declaration of the puts function</span></span><br><span class="line"><span class="keyword">declare</span> <span class="type">i32</span> <span class="title">@puts</span>(<span class="type">ptr</span> <span class="keyword">nocapture</span>) <span class="keyword">nounwind</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Definition of main function</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="comment">; Call puts function to write out the string to stdout.</span></span><br><span class="line">  <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@puts</span>(<span class="type">ptr</span> <span class="title">@.str</span>)</span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>.str</code>、<code>puts</code>和<code>main</code>为全局变量，全局变量均为指针，并指向一个内存位置。任何全局变量都必须指定<code>链接类型（Linkage Type）</code>，如<code>.str</code>指定为<code>private</code>。</p>
<h3 id="链接类型"><a href="#链接类型" class="headerlink" title="链接类型"></a>链接类型</h3><ul>
<li><code>private</code>： 这类全局变量只能被当前模块内的对象访问，且在与其他模块链接时可能会被重命名。另外，它不会出现在 Object 文件的任何符号表中。</li>
<li><code>internal</code> ：与 <code>private</code>类似，但会作为局部符号出现在符号表中，它对应于 C 语言中使用 <code>static</code>声明的变量或函数。</li>
<li><code>available_externally</code>：从链接器角度看，该类型等价于<code>external</code>类型。它可以允许被优化或者内联。该类型变量不会被发送到 Object 文件，而只会被优化器使用。</li>
<li><code>linkonce</code>：可以用于实现<strong>内联</strong>、<strong>模板</strong>等高级语言特性。未被引用的<code>linkonce</code>变量会被废弃。另外，使用<code>linkonce</code>类型的函数<strong>并不一定</strong>允许优化器内联它的函数体（Body）到引用它的地方，因为优化器可能<strong>并不知道</strong>当前函数体就是最后的定义，也不知道将来是否会被更强的定义覆盖。如果要使能内联或者其他优化，可以使用<code>linkonce_odr</code>链接类型。</li>
<li><code>weak</code>：在<strong>merge</strong>语义上与<code>linkonce</code>相同，除了未被引用的<code>weak</code>全局变量<strong>不会</strong>被废弃。</li>
<li><code>common</code>：大多数情况下类似于<code>weak</code>，但它用于 C 语言中未初始化的全局变量定义，例如 <code>int x;</code>。<code>common</code>类型的符号在<strong>merge</strong>时的行为与<code>weak</code>类型符号相同，而且在未被引用时，<strong>可能不会</strong>被删除。<code>common</code>类变量必须声明<code>零初始化器(Zero Initializer)</code>。</li>
<li><code>appending</code>：该类型可能只能应用于数组指针。</li>
<li><code>extern_weak</code>：</li>
<li><code>linkonce_odr, weak_odr</code>：该类型的变量只允许等价的全局变量可以被合并。</li>
<li><code>external</code>：默认链接类型，该类型变量对外部可见，并可以在链接阶段用于外部符号解析。</li>
</ul>
<p>任何<strong>声明的全局变量或函数</strong>（与<strong>定义</strong>区分）具有除<code>external</code>或<code>extern_weak</code>之外的任何链接类型都是非法的。</p>
<h3 id="调用规范"><a href="#调用规范" class="headerlink" title="调用规范"></a>调用规范</h3><p>LLVM 支持多种调用规范：</p>
<ul>
<li><code>ccc</code> : 默认类型，匹配 C 语言的调用规范。它支持<code>varargs</code>函数调用，并在一定程度上容许函数原型声明和函数定义间的不匹配。</li>
<li><code>fastcc</code>：该类型尝试使得函数调用尽量快速完成，它允许目标使用任何技巧来加速函数调用（它可以不遵循当前平台的 ABI 规范）。它不支持<code>varargs</code>函数调用，并要求函数声明和定义的完全匹配。</li>
<li><code>coldcc</code>：用于很少被执行的函数调用。</li>
<li><code>cc 10</code>：<strong>GHC（Glasgow Haskell Compiler ）</strong> 规范，它使用寄存器传递所有参数，通过禁止使用 <code>CSR（Callee-Saved-Registers）</code> 来达到该目的。该规范只在一些特殊情况下使用。另外，它支持 <code>tailcall（尾调用）</code> 优化。目前只有 X86 有限地支持该规范。</li>
<li><code>cc 11</code>：<strong>HiPE（ High-Performance Erlang）</strong> 规范，它使用（相比于 <code>ccc</code> 规范）更多的寄存器来传递参数，并且没有定义 <code>CSR</code>。它使用和<code>GHC</code>规范相同的 <em>register pinning</em> 机制，用于将频繁访问的运行时组件固定到特定的硬件寄存器。目前只有 X86 支持该规范。</li>
<li><code>webkit_jscc</code>：<strong>WebKit</strong>的 <strong>JavaScript</strong> 调用规范。它已经被 <code>WebKit FTL JIT</code>实现。它将参数从右到左依次保存到栈上，然后通过平台特定的返回寄存器返回结果值。</li>
<li><code>anyregcc</code>：该规范使用寄存器传递参数，但允许动态分配所用寄存器。</li>
<li><code>preserve_mostcc</code>：该规范尝试尽量使得调用者的代码尽量少地被干扰。它与 <code>ccc</code> 规范在参数和返回值传递方式上是相同的，但使用不同的 <strong>caller&#x2F;callee-saved 寄存器</strong> 集合，这使得可以减轻调用者在<em>保存&#x2F;恢复大量寄存器</em>操作上的开销。该规范与<code>coldcc</code>相比，更多地被用于频繁调用的函数。目前，它仍然是实验性的，但在未来会作为<code>Object-C Runtime</code>的调用规范。</li>
<li><code>preserve_allcc</code>：该规范比 <code>preserve_mostcc</code> 更进一步地减少调用者代码所受到的干扰。</li>
<li><code>cxx_fast_tlscc</code>：</li>
<li><code>tailcc</code>：该规范确保在尾部的函数调用可以进行<strong>尾调用优化</strong>。<strong>尾调用优化</strong>就是直接使用被调用者的<strong>栈帧</strong>替代调用者的<strong>栈帧</strong>，这样可以节省内存，但需要确保被调用者不再引用调用者内部的变量。</li>
<li><code>swiftcc</code>：<code>swift</code>语言的调用规范。</li>
<li><code>cc &lt;n&gt;</code>：使用编号为 <code>n</code> 的调用规范。</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>LLVM 支持下面几种<code>可见性样式（Visibility Styles）</code>：</p>
<ul>
<li><code>default</code>：</li>
<li><code>hidden</code>：通常，<code>hidden</code>代表该符号不会被放到动态符号表中。</li>
<li><code>protected</code>：</li>
</ul>
<p>任何使用<code>private</code>或<code>internal</code>链接类型的符号的可见性都为<code>default</code>。</p>
<h3 id="线程本地存储模型"><a href="#线程本地存储模型" class="headerlink" title="线程本地存储模型"></a>线程本地存储模型</h3><p><code>TLS(Thread Local Stroage)</code> 是指一个变量可以被定义为 <code>thread_local</code>，即它不会被线程共享（每个线程都会有一个该变量的拷贝），也就不存在线程间数据竞争问题。TLS 不一定被所有目标平台支持，另外，它包括以下几种模型：</p>
<ul>
<li><code>localdynamic</code> ： 只在当前共享库中使用的变量。</li>
<li><code>initialexec</code>：在模块中不会被动态载入的变量。</li>
<li><code>localexec</code> ： 在可执行文件中定义且只在其中使用的变量。</li>
</ul>
<p>默认使用 <code>general dynamic</code>模型。</p>
<p>对于 <code>pthread</code> 库，可以使用相应的 API 来使用 TLS。<br>对于 GCC 可以使用语言级别的特殊语法，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__thread <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">extern</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">state</span> <span class="title">s</span>;</span></span><br><span class="line"><span class="type">static</span> __thread <span class="type">char</span> *p</span><br></pre></td></tr></table></figure>

<h3 id="运行时抢占说明符"><a href="#运行时抢占说明符" class="headerlink" title="运行时抢占说明符"></a>运行时抢占说明符</h3><p><code>Runtime Preemption Specifiers</code> 主要用于全局变量、函数和别名（alias），它有下面的类型：</p>
<ul>
<li><code>dso_preemptable</code>：默认类型。表示函数或者变量在运行时会被外部的链接单元替换。</li>
<li><code>dso_local</code> ：表示函数或变量将解析为同一链接单元中的符号。即使定义不在此编译单元内，也将生成直接访问，例如使用 <code>declare</code>声明的函数。</li>
</ul>
<h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>LLVM IR 支持定义 C 语言中的结构体<code>struct</code>类型；同样的，C++ 中的<code>类(class)</code>也可以使用相同的底层原语。<code>structure types</code> 包括 <code>identified</code>和<code>literal</code>类型。示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span><span class="type">int</span> X; <span class="type">int</span> Y&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Root</span> =</span> &#123;<span class="number">0</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">Origin</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>转换为 LLVM IR 后：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%struct.Node</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="variable">%struct.Node</span>* &#125;</span><br><span class="line"><span class="variable">%struct.Point</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">@Root</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> <span class="variable">%struct.Node</span> <span class="keyword">zeroinitializer</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line"><span class="title">@Origin</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> <span class="variable">%struct.Point</span> <span class="keyword">zeroinitializer</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>结合前面的叙述以及本节内容，我们可以总结全局变量的几个特性：</p>
<ul>
<li>全局变量存储在<strong>编译阶段</strong>分配的区域内（例如<code>.data</code>段），<strong>也可以显式地指定某个段</strong>。</li>
<li>全局变量的<strong>定义</strong>必须初始化，但对于<strong>声明</strong>的全局变量（在其他模块中定义）可以不用初始化。</li>
<li>全局变量可以指定一个<code>链接类型</code>（如果没有声明，则使用默认类型）。</li>
<li>全局变量可以指定一个<code>运行时抢占说明符</code>。</li>
<li>全局变量可以指定<strong>数据对齐格式</strong>，使用<code>align &lt;n&gt;</code>。</li>
<li>全局变量可以指定为<code>constant</code>，代表该变量的值不会被修改。</li>
<li>全局变量总是定义一个指针指向它的内容（content）。</li>
<li>全局变量可以指定为<code>unnamed_addr</code>，表明地址并不重要，仅指内容。两个该类型变量如果拥有相同地初始化器（或相同地定义）可以进行合并。</li>
<li>全局变量可以指定为<code>local_unnamed_addr</code>，表明地址在<code>Module</code>内不重要。</li>
<li>全局变量可以被声明为驻留在目标特定的已经编号的地址空间中。</li>
<li>全局变量可以指定全局属性（<code>#&lt;n&gt;</code>），或者一个附加的元数据列表。</li>
<li>变量和别名可以指定 TLS 模型。</li>
<li>全局变量（或者全局数组的成员）不能是<code>可扩展向量类型</code>，因为它们的大小在编译阶段未知。</li>
</ul>
<p>语法表示</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">@&lt;GlobalVarName&gt; <span class="operator">=</span> [Linkage] [PreemptionSpecifier] [Visibility]</span><br><span class="line">                   [DLLStorageClass] [ThreadLocal]</span><br><span class="line">                   [(<span class="keyword">unnamed_addr</span>|local_unnamed_addr)] [AddrSpace]</span><br><span class="line">                   [ExternallyInitialized]</span><br><span class="line">                   &lt;<span class="keyword">global</span> | <span class="keyword">constant</span>&gt; &lt;Type&gt; [&lt;InitializerConstant&gt;]</span><br><span class="line">                   [<span class="punctuation">,</span> <span class="keyword">section</span> <span class="string">&quot;name&quot;</span>] [<span class="punctuation">,</span> partition <span class="string">&quot;name&quot;</span>]</span><br><span class="line">                   [<span class="punctuation">,</span> comdat [($name)]] [<span class="punctuation">,</span> <span class="keyword">align</span> &lt;Alignment&gt;]</span><br><span class="line">                   [<span class="punctuation">,</span> no_sanitize_address] [<span class="punctuation">,</span> no_sanitize_hwaddress]</span><br><span class="line">                   [<span class="punctuation">,</span> sanitize_address_dyninit] [<span class="punctuation">,</span> sanitize_memtag]</span><br><span class="line">                   (<span class="punctuation">,</span> <span class="title">!name</span> <span class="title">!N</span>)*</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一些示例：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@G</span> <span class="operator">=</span> <span class="keyword">addrspace</span>(<span class="number">5</span>) <span class="keyword">constant</span> <span class="type">float</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="keyword">section</span> <span class="string">&quot;foo&quot;</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="title">@G</span> <span class="operator">=</span> <span class="keyword">external</span> <span class="keyword">global</span> <span class="type">i32</span></span><br><span class="line"><span class="title">@G</span> <span class="operator">=</span> <span class="keyword">thread_local</span>(<span class="keyword">initialexec</span>) <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数定义语法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [<span class="keyword">ret</span> attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(<span class="keyword">unnamed_addr</span>|local_unnamed_addr)] [AddrSpace] [fn Attrs]</span><br><span class="line">       [<span class="keyword">section</span> <span class="string">&quot;name&quot;</span>] [partition <span class="string">&quot;name&quot;</span>] [comdat [($name)]] [<span class="keyword">align</span> N]</span><br><span class="line">       [<span class="keyword">gc</span>] [<span class="keyword">prefix</span> Constant] [prologue Constant] [<span class="keyword">personality</span> Constant]</span><br><span class="line">       (<span class="title">!name</span> <span class="title">!N</span>)* &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>函数声明语法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> [linkage] [visibility] [DLLStorageClass]</span><br><span class="line">        [cconv] [<span class="keyword">ret</span> attrs]</span><br><span class="line">        &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">        [(<span class="keyword">unnamed_addr</span>|local_unnamed_addr)] [<span class="keyword">align</span> N] [<span class="keyword">gc</span>]</span><br><span class="line">        [<span class="keyword">prefix</span> Constant] [prologue Constant]</span><br></pre></td></tr></table></figure>

<p>函数定义由单个或多个<code>基本块</code>组成，它们构成了函数的 <code>CFG（控制流图）</code>。每个基本块可以在开头显式地声明一个<code>label</code>，如果没有指定，LLVM会自动为其分配一个非命名标识符作为<code>label</code>。</p>
<p>如果没有指定地址空间，则默认设置为<code>布局字符串</code>中指定的程序地址空间（“A”、“G”或“P”）。</p>
<h3 id="Alias-和-IFunc"><a href="#Alias-和-IFunc" class="headerlink" title="Alias 和 IFunc"></a>Alias 和 IFunc</h3><h3 id="COMDATS"><a href="#COMDATS" class="headerlink" title="COMDATS"></a>COMDATS</h3><p><code>COMDAT</code> 段被多个目标文件所定义的辅助段。该段的作用是将在多个已编译模块中重复的代码和数据的逻辑块组合在一起。COMDAT 在 C++ 的<strong>虚函数表</strong>和<strong>模板</strong>的编译链接中，起着非常重要的作用。</p>
<p>例如，在头文件<code>myclass.h</code>中定义了模板类<code>MyClass&lt;T&gt;</code>，然后 <code>x.cpp</code> 和 <code>y.cpp</code> 都包含了该头文件，并且都使用<code>int</code>实例化这个模板类，即在<code>x.o</code>和<code>y.o</code>中都有<code>MyClass&lt;int&gt;</code>的实例代码。但可执行文件中只需要一份代码即可，因此在链接时会有一个重复代码消除的步骤。</p>
<p>LLVM 定义 <code>COMDAT</code> 的语法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$&lt;Name&gt; <span class="operator">=</span> comdat SelectionKind</span><br></pre></td></tr></table></figure>

<p><code>Name</code> 代表 <code>comdat key</code>，在两个 Object 文件中相同 <code>comdat key</code> 的 COMDAT 段将会被合并，合并的方式由 <code>SelectionKind</code> 指定。它包括下面几种：</p>
<ul>
<li><code>any</code>：任意选择</li>
<li><code>exactmatch</code>：任意选择，但段中必须包含相同的数据。</li>
<li><code>largest</code></li>
<li><code>nodeduplicate</code></li>
<li><code>samesize</code></li>
</ul>
<p>目前，<code>ELF</code> 只支持<code>any</code>和<code>nodeduplicate</code>，<code>COFF</code>支持所有类型。</p>
<h3 id="命名元数据"><a href="#命名元数据" class="headerlink" title="命名元数据"></a>命名元数据</h3><p>语法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; Some unnamed metadata nodes, </span></span><br><span class="line"><span class="comment">; which are referenced by the named metadata.</span></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> !&#123;!<span class="string">&quot;zero&quot;</span>&#125;</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> !&#123;!<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line"><span class="title">!2</span> <span class="operator">=</span> !&#123;!<span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line"><span class="comment">; A named metadata.</span></span><br><span class="line"><span class="title">!name</span> <span class="operator">=</span> !&#123;<span class="title">!0</span><span class="punctuation">,</span> <span class="title">!1</span><span class="punctuation">,</span> <span class="title">!2</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>DWARF</code> 调试数据可以使用<code>Metadata</code>表示。</p>
<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>函数的返回类型和参数类型都可以关联一组<code>参数属性（Parameter Attributes）</code>。参数属性是函数的一部分，而不是函数类型的一部分。一些示例如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="type">i32</span> <span class="title">@printf</span>(<span class="type">ptr</span> <span class="keyword">noalias</span> <span class="keyword">nocapture</span><span class="punctuation">,</span> ...)</span><br><span class="line"><span class="keyword">declare</span> <span class="type">i32</span> <span class="title">@atoi</span>(<span class="type">i8</span> <span class="keyword">zeroext</span>)</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">signext</span> <span class="type">i8</span> <span class="title">@returns_signed_char</span>()</span><br></pre></td></tr></table></figure>
<p>目前支持的参数属性如下：</p>
<ul>
<li><code>signext</code>：指示<code>代码生成器</code> 进行符号扩展。</li>
<li><code>zeroext</code>：指示<code>代码生成器</code> 进行零扩展。</li>
<li><code>inreg</code>：</li>
<li><code>byval(&lt;ty&gt;)</code>：按值传递参数</li>
<li><code>byref(&lt;ty&gt;)</code>：按引用传递参数</li>
<li><code>noalias</code>:</li>
<li><code>nocapture</code>: 表明<strong>被调用函数</strong>不能<a href="https://llvm.org/docs/LangRef.html#pointercapture">捕获指针</a>。</li>
<li><code>nonnull</code>：表明参数或返回指针非空。</li>
<li><code>readonly</code>:</li>
<li><code>writeonly</code>：</li>
</ul>
<p>注意与下文中的<em>函数属性</em>区分。</p>
<h3 id="GC-策略名"><a href="#GC-策略名" class="headerlink" title="GC 策略名"></a>GC 策略名</h3><p>在上文中提及，在函数定义和声明中可以指定 <code>gc</code>。其语法为:</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">void</span> <span class="title">@f</span>() <span class="keyword">gc</span> <span class="string">&quot;name&quot;</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <a href="https://llvm.org/docs/GarbageCollection.html#builtin-gc-strategies">LLVM 内置的 GC 策略名</a> ，或者使用插件提供的策略名。LLVM 本身不包含 GC 支持，它局限于生成特定的机器代码，该机器代码可以与外部提供的 GC 交互。</p>
<h3 id="Prologue-数据"><a href="#Prologue-数据" class="headerlink" title="Prologue 数据"></a>Prologue 数据</h3><p><code>Prologue</code> 属性使得允许在函数开头插入任意代码。它可以用来实现函数<code>hot-patching</code>和<code>instrumentation</code>。Prologue 数据基本上都是和具体目标相关的。</p>
<h3 id="属性组"><a href="#属性组" class="headerlink" title="属性组"></a>属性组</h3><p>在 LLVM IR 中可能有多个对象使用相同的属性集，使用属性组，可以使得 IR 减少冗余，更加具有可读性。示例如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; Target-independent attributes:</span></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">alwaysinline</span> <span class="keyword">alignstack</span><span class="operator">=</span><span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Target-dependent attributes:</span></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#1</span> <span class="operator">=</span> &#123; <span class="string">&quot;no-sse&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function @f has attributes: alwaysinline, alignstack=4, and &quot;no-sse&quot;.</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">void</span> <span class="title">@f</span>() <span class="variable">#0</span> <span class="variable">#1</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><p>示例如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">void</span> <span class="title">@f</span>() <span class="keyword">noinline</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">define</span> <span class="type">void</span> <span class="title">@f</span>() <span class="keyword">alwaysinline</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">define</span> <span class="type">void</span> <span class="title">@f</span>() <span class="keyword">alwaysinline</span> <span class="keyword">optsize</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">define</span> <span class="type">void</span> <span class="title">@f</span>() <span class="keyword">optsize</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><code>函数属性</code>是函数的一部分，而不是函数类型的一部分，即具有不同<code>函数属性</code>的函数可以具有相同的函数类型。</p>
<p>目前支持的函数类型种类如下：</p>
<ul>
<li><code>alignstack(&lt;n&gt;)</code>：</li>
<li><code>alwaysinline</code>：</li>
<li><code>allockind(&quot;KIND&quot;)</code>：</li>
<li><code>alwaysinline</code> ：指示内联器总是<strong>尝试</strong>内联该函数。</li>
<li><code>cold</code>:</li>
<li><code>hot</code>:</li>
<li><code>noinline</code>：指示内联器绝不会内联该函数。</li>
<li><code>noreturn</code>:</li>
<li><code>norecurse</code>:</li>
<li><code>nosync</code>:</li>
<li><code>nounwind</code>: 表明函数绝不会抛出异常。</li>
<li><code>optnone</code>: 表明除了<strong>过程间优化 Pass</strong>，其他<em>大多数</em><strong>优化 Pass</strong> 都应该跳过该函数。</li>
<li><code>speculative_load_hardening</code>: <a href="https://zhuanlan.zhihu.com/p/571395488">消减幽灵攻击</a>。</li>
<li><code>ssp</code>: 表明该函数需要<code>emit</code>**栈溢出保护器(Stack Sashing Protector)**。</li>
<li><code>uwtable</code>：</li>
<li><code>mustprogress</code></li>
</ul>
<h3 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h3><p>语法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;layout specification&quot;</span></span><br></pre></td></tr></table></figure>
<p><em>布局规范</em>包含一个子规范列表，子规范之间通过<code>&#39;-&#39;</code>符号分隔，例如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br></pre></td></tr></table></figure>
<p>子规范类型如下：</p>
<ul>
<li><code>E</code>：目标以<strong>大端</strong>格式进行数据布局。</li>
<li><code>e</code>：目标以<strong>小端</strong>格式进行数据布局。</li>
<li><code>S&lt;size&gt;</code> ：指定栈的<code>natural 对齐</code>，以<code>bit</code>为单位。</li>
<li><code>P&lt;address space&gt;</code>：指定程序code 所在的地址空间。</li>
<li><code>G&lt;address space&gt;</code>：指定全局变量所在的地址空间，如果没有指定，则默认为 <code>0</code> 。</li>
<li><code>A&lt;address space&gt;</code>：指定由<code>alloca</code>创建的对象所在的地址空间，默认为<code>0</code>。</li>
<li><code>p[n]:&lt;size&gt;:&lt;abi&gt;[:&lt;pref&gt;][:&lt;idx&gt;]</code>：指定地址空间<code>n</code>的指针类型的大小<code>size</code>和对齐。</li>
<li><code>i&lt;size&gt;:&lt;abi&gt;[:&lt;pref&gt;]</code>：指定<code>size</code>大小的整数的对齐方式。</li>
<li><code>v&lt;size&gt;:&lt;abi&gt;[:&lt;pref&gt;]</code>：指定<code>size</code>大小的向量（vector）的对齐方式。</li>
<li><code>f&lt;size&gt;:&lt;abi&gt;[:&lt;pref&gt;]</code>：指定<code>size</code>大小的浮点数的对齐方式。</li>
<li><code>a:&lt;abi&gt;[:&lt;pref&gt;]</code>：指定聚合类型对象的对齐方式。</li>
<li><code>F&lt;type&gt;&lt;abi&gt;</code>：指定函数指针的对齐方式。</li>
<li><code>m:&lt;mangling&gt;</code>：指定<code>Name Mangling</code>的方式，具体有以下几种：<ul>
<li><code>e</code>：使用<code>ELF</code>方式，对于私有符号使用<code>.L</code>前缀。</li>
</ul>
</li>
<li><code>n&lt;size1&gt;:&lt;size2&gt;:&lt;size3&gt;...</code>：指定目标 CPU 所支持的整数的类型。</li>
</ul>
<h3 id="目标三元组信息"><a href="#目标三元组信息" class="headerlink" title="目标三元组信息"></a>目标三元组信息</h3><p>语法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target</span> <span class="keyword">triple</span> <span class="operator">=</span> <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br></pre></td></tr></table></figure>

<p>格式：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM</span><br><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT</span><br></pre></td></tr></table></figure>

<h3 id="指针别名规则"><a href="#指针别名规则" class="headerlink" title="指针别名规则"></a>指针别名规则</h3><h3 id="指针捕获"><a href="#指针捕获" class="headerlink" title="指针捕获"></a>指针捕获</h3><p>给定一个函数调用，而且一个指针作为该调用的参数或者存储在该调用之前的内存中，如果该调用拷贝该指针的任一部分到该函数外部的某个地方，则称该函数<code>捕获</code>该指针。</p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2>]]></content>
      <categories>
        <category>编译器</category>
        <category>LLVM Project</category>
      </categories>
  </entry>
  <entry>
    <title>Linux Kernel Introduction</title>
    <url>/2023/03/08/Linux-Kernel-Introduction/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://www.kernel.org/">Linux kernel</a> 是开源的<code>单内核</code>(Monolithic Kernel)、<code>模块化</code>和<code>多任务</code>的<code>类Unix</code>操作系统。</p>
<p>在本系列文章中，使用 “Linux” 均代指 “Linux 内核”，如果要指代像 Ubuntu 这样的 Linux 发行版系统，我们使用 “GNU&#x2F;Linux”。</p>
<span id="more"></span>

<blockquote>
<p>参考 <a href="https://encyclopedia.thefreedictionary.com/linux+kernel">Linux Kernel - wikipedia</a><br>参考《Understanding the Linux Kernel, Third Edition》 By Daniel P. Bovet &amp; Marco Cesati.<br>参考 <a href="https://0xax.gitbooks.io/linux-insides/content/">linux-insides</a> - By <strong>0xax</strong> | <a href="https://www.bookstack.cn/read/linux-insides-zh/README.md">Linux内核揭秘-中文版</a>。<br>参考 <a href="https://linux-kernel-labs.github.io/">kernel teaching</a><br>参考 《Linux内核驱动开发详解》By 宋宝华</p>
</blockquote>
<h2 id="Unix-渊源"><a href="#Unix-渊源" class="headerlink" title="Unix 渊源"></a>Unix 渊源</h2><p>Unix 系统最初在 1969 年诞生于贝尔实验室。Unix 衍生出了很多变种，例如 <code>OpenBSD</code>等，它的很多设计理念也深刻影响了 GNU&#x2F;Linux（<em>准确来说，主要影响的是内核上层的应用程序和环境</em>） 。更重要的是，<code>Unix</code>有着开放源码和同僚复审的传统，这种理念产生的优势被 Linux 充分的发挥和利用。关于这个主题，可以阅读经典的《The Art of UNIX Programming》 (在 <a href="http://1.117.83.246/index.php/archives/187/">Unix编程艺术笔记</a> 中有一些摘要总结)。</p>
<p>Linux 的成长伴随着互联网的崛起，这就使得它与 <code>Unix</code> 在开发模式上有些不同。Linux 几乎是通过来源于”网络部落“的一些“松散”的开发者贡献给世界的，但它现在已经变得十分强大。《大教堂与集市》一书中有详细和精彩的描述。</p>
<blockquote>
<p>乐趣是一个符号，意味着效能、效率和高产。 —— TAOUP</p>
</blockquote>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="内核-用户-API"><a href="#内核-用户-API" class="headerlink" title="内核-用户 API"></a>内核-用户 API</h3><h3 id="内核-用户-ABI"><a href="#内核-用户-ABI" class="headerlink" title="内核-用户 ABI"></a>内核-用户 ABI</h3><p>当前针对在不同的 <code>GNU/Linux</code>系统间保持应用和二进制兼容的标准是 <strong>LSB(Linux Standard Base)<strong>。LSB 中和内核相关的标准包括：</strong>General ABI</strong>、<strong>System V ABI</strong>、<strong>ELF</strong>和<strong>Processor Specific ABI</strong>。其中，和处理器相关的 ABI 定义了在函数调用时如何传递系统调用号及其他参数（例如，使用寄存器还是栈，以及使用哪些寄存器）。</p>
<h3 id="系统调用规范"><a href="#系统调用规范" class="headerlink" title="系统调用规范"></a>系统调用规范</h3><p>系统调用和用户空间中的函数调用存在一些不同点，以<code>x86_64</code>架构为例：</p>
<ol>
<li>进程内核栈除了需要保存内核空间过程调用外，还需要保存用户空间栈的数据和返回地址，以便 在返回用户空间继续执行。</li>
<li>过程调用中寄存器调用约定不同。<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Registers on entry:</span><br><span class="line"> rax  system call number</span><br><span class="line"> rcx  return address</span><br><span class="line"> r11  saved rflags (note: r11 is callee-clobbered register in C ABI)</span><br><span class="line"> rdi   arg0</span><br><span class="line"> rsi    arg1</span><br><span class="line"> rdx  arg2</span><br><span class="line"> r10  arg3 (needs to be moved to rcx to conform to C ABI)</span><br><span class="line"> r8    arg4</span><br><span class="line"> r9    arg5</span><br><span class="line"> (note: r12-r15, rbp, rbx are callee-preserved in C ABI)</span><br></pre></td></tr></table></figure>
具体定义可查看源代码<code>arch/x86/entry/common.c</code>。</li>
</ol>
<p>在代码 <code>arch/x86/entry/entry_64.S</code> 中可查看切换的具体过程：</p>
<ol>
<li>用户栈到进程内核栈的切换（修改 <code>rsp</code> 寄存器的值）。</li>
<li>依次将用户空间寄存器压栈，和数据结构<code>struct pt_regs</code> 成员一一对应（顺序固定且是倒序）。</li>
</ol>
<img src="https://pic2.zhimg.com/80/v2-53e4c9fb41f2300d15c560d054e30bb5_720w.webp" width="70%">


<h2 id="内核的整体结构"><a href="#内核的整体结构" class="headerlink" title="内核的整体结构"></a>内核的整体结构</h2><p>用一句话来总结内核的角色：<code>内核是最懒的资源管理者</code>。这里的资源可以分为三大类：<code>CPU</code>、<code>内存</code>和 <code>I/O</code>。内核通过抽象这些资源形成<code>进程</code>、<code>线程</code>、<code>文件</code>和<code>虚拟内存</code>等概念。抽象是对抗复杂性的很有效的手段之一。换句话说，内核也可以看作用户进程执行的<code>环境</code>。</p>
<p>内核的<code>懒</code>是它的特点也是对它的要求，特别是对于支持多任务并发的内核来说。除非被唤醒，它应该什么都不做；即使被唤醒，也应该做的尽量少、尽量快，然后继续”睡觉“。这种特性与整个系统并发的效率紧密相关。</p>
<h3 id="进程-内核模式"><a href="#进程-内核模式" class="headerlink" title="进程&#x2F;内核模式"></a>进程&#x2F;内核模式</h3><p>将内核唤醒的方式几乎都是事件驱动的，这些事件简单来说分为<code>中断</code>和<code>异常</code>，<code>中断</code>又可以大致分为<code>硬中断</code>和<code>软中断</code>。<code>POSIX</code>定义了系统调用接口 API，系统调用也可以认为是软中断的一种，支持从用户程序唤醒内核，但标准并没有限制内核如何设计。</p>
<p>类Unix内核区分<code>内核态</code>和<code>用户态</code>。用户进程几乎不与硬件资源直接交互，而是使用系统调用进入内核态请求资源。</p>
<h3 id="单内核-Monolithic-kernel-与微内核-Microkernel"><a href="#单内核-Monolithic-kernel-与微内核-Microkernel" class="headerlink" title="单内核(Monolithic kernel)与微内核(Microkernel)"></a>单内核(Monolithic kernel)与微内核(Microkernel)</h3><p>可以用下面一张图来描述二者的不同:</p>
<img src="https://img2.tfd.com/pp/wikiimg.ashx?p=commons%2fthumb%2f6%2f67%2fOS-structure.svg%2f750px-OS-structure.svg.png" width=80%>

<p>很容易看出，微内核更简单、更模块化，但模块间的通信交互开销会更高。另外，微内核的 RAM利用效率会更高，因为不被调用的系统进程可以被<code>换出</code>。Linux 为了既吸收微内核的优势又不影响性能，提供了<code>模块（Module）</code>。模块是一个目标文件，可以在运行时链接到内核或者从内核解除链接。<strong>模块不是作为一个特殊的进程来执行，它代表当前进程在内核态下执行。</strong></p>
<h3 id="可重入内核"><a href="#可重入内核" class="headerlink" title="可重入内核"></a>可重入内核</h3><p>可重入内核也必须是可抢占内核。也就是说，即使当前 CPU 处于内核态，也仍然可以被抢占，这使得内核具有很高的<code>实时性</code>。可重入内核必须引入同步机制来访问共享数据结构。大多数传统的 Unix 内核都是非抢占内核，但 Linux 是可抢占内核，特别在 SMP 系统上，可抢占内核可以获得更好的并行性能。</p>
<p>同步机制可以包括<code>禁止中断</code>、<code>信号量</code>、<code>自旋锁（针对SMP系统）</code>。</p>
<h3 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h3><p><img src="/2023/03/08/Linux-Kernel-Introduction/linux_kernel_subsystem.png"></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>我们说内核是最懒的资源管理者，从内核的角度看，进程的目的就是担当分配系统资源（CPU时间、内存）的实体。</p>
<p>Linux 2.6 以后版本中的线程采用<code>NPTL</code>（Native POSIX Thread Library，本地POSIX 线程库）模型，操作速度得以极大提高，相比于Linux 2.4 内核时代的<code>LinuxThreads</code>模型，它也更加遵循<code>POSIX</code>规范的要求。</p>
<h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>进程的核心数据结构是<code>进程描述符（Process Descriptor, PCB）</code>，它的子段包含了与一个进程相关的所有信息。PCB 是相当复杂的，它不仅包含了很多进程属性的子段，而且包括了指向其他数据结构的指针。其大致结构如下（具体定义位于头文件<code>include/linux/sched.h:624</code>中，以 5.4 版本为例）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state;               <span class="comment">// 进程状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>  <span class="title">thread_info</span>;</span>   <span class="comment">// 进程基本信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">void</span>  *<span class="built_in">stack</span>;                      <span class="comment">// 指向内核栈</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">mm</span>;</span>               <span class="comment">// 指向进程内存空间描述符的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">real_parent</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> * <span class="title">fs</span>              // 文件系统（当前目录）</span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>        <span class="comment">// 指向打开文件的描述符的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span>      <span class="comment">// 所接收信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span>            <span class="comment">// 进程链表</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>状态转换图：</p>
<!--
<pre class="mermaid">stateDiagram-v2
    S00: 就绪(RUNNING)
    S0: 正运行(RUNNING)
    S1: 可中断等待或不可中断等待
    S4: 暂停(STOPPED)
    S8: 跟踪(TRACED)
    S20: 僵死(ZOMBIE)
    S10: 僵死撤消(DEAD)
    S00 \-\-> S0
    S0 \-\-> S00
    S0 \-\-> S1
    S1 \-\-> S00
    S0 \-\->  S10</pre>
-->
<p><img src="/2023/03/08/Linux-Kernel-Introduction/linux_task_fsm.png"></p>
<h3 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h3><p>进程与进程描述符之间有严格的一一对应关系，可以使用<strong>进程描述符地址</strong>描述进程。另外，内核也允许用户使用 <strong>PID</strong>来标识进程，<strong>PID</strong>存放在 PCB 的 <code>pid</code>  字段中。另外<code>tgid</code>字段代表所在线程组中领头线程的 <strong>PID</strong>。 PID是 32 位的无符号整数，它被顺序编号。<strong>PID 是 内核提供给用户操作进程的接口</strong>。</p>
<p>内核必须有效地从进程 <strong>PID</strong> 导出它的进程描述符指针，效率非常重要。内核使用 pid 哈希链表<code>pidhash</code>来建立映射关系，内核引入了<code>PIDTYPE_MAX</code> 个 pid 哈希链表，在 PCB 中对应字段<code>struct hlist_node pid_links[PIDTYPE_MAX]</code>。</p>
<h3 id="内核栈"><a href="#内核栈" class="headerlink" title="内核栈"></a>内核栈</h3><p>在每一个进程的生命周期中，经常会通过系统调用（SYSCALL）陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先用户空间中的栈，而是一个内核空间的栈，这个称作进程的<code>内核栈</code>。每个 task 的栈都包含用户栈和内核栈两部分。进程内核栈的定义如下（<code>include/linux/sched.h:1628</code>）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARCH_TASK_STRUCT_ON_STACK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>THREAD_SIZE</code> 在 32 位系统是 8KB，64 位系统里是 16KB。那么，其中 <code>thread_info</code> 有什么用呢？<br>在不同的体系结构里，进程需要存储的信息不尽相同，Linux 使用<code>task_struct</code>存储通用的信息，将体系结构相关的部分存储在<code>thread_info</code>中。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* x86 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>        flags;    <span class="comment">/* low level flags */</span></span><br><span class="line">	u32                  status;   <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARM */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>        flags;             <span class="comment">/* low level flags */</span></span><br><span class="line">	<span class="type">int</span>                  preempt_count;     <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; bug */</span></span><br><span class="line">	<span class="type">mm_segment_t</span>         addr_limit;        <span class="comment">/* address limit */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>   *<span class="title">task</span>;</span>             <span class="comment">/* main task structure */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进程描述符 <code>task_struct</code> 中的字段<code>void *stack</code>指向内核栈。根据宏<code>CONFIG_THREAD_INFO_IN_TASK</code> 是否设置，我们可以分情况讨论。<br>首先，如果<code>thread_info</code>在进程内核栈中，我们可以得到下面的结构图（以 ARM 为例）：</p>
<img src="https://pic2.zhimg.com/80/v2-3f8f0a1ccadf4cf2ca408a0810417679_720w.webp" width="80%">

<p>因此，我们可以获得当前进程内核栈的sp寄存器存储的地址时，根据THREAD_SIZE对齐就可以获取<code>thread_info</code>结构的基地址。</p>
<p>然后，如果 <code>thread_info</code> 结构在进程描述符中，以下面结构图所示：<br><img src="https://pic4.zhimg.com/80/v2-ea673275121a42b4ea81999a9707bbc7_720w.webp" width="80%"></p>
<p>以上复杂的结构，用于实现<code>current</code>宏，来获得当前进程对应的 PCB 地址。例如对于 ARM 架构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arch/arm/include/asm/thread_info.h</span></span><br><span class="line">        <span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">long</span> current_stack_pointer <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;sp&quot;</span>)</span>;</span><br><span class="line">	</span><br><span class="line">        <span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title function_">current_thread_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)</span><br><span class="line">                (current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// include/asm-generic/current.h</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> get_current() (current_thread_info()-&gt;task)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> current get_current()</span></span><br></pre></td></tr></table></figure>

<p>ARM64 不再使用通过计算栈偏移量的方式获得进程 PCB 地址，而是使用寄存器<code>sp_el0</code>，在进程切换时暂存 PCB 地址。</p>
<p>而在 x86 体系结构中，linux 一直采用另一种方式：使用了<code>current_task</code>这个 CPU 变量，来存储当前正在使用的 CPU 的进程 PCB 地址。如下所示（<code>arch/x86/include/asm/current.h</code>）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>;</span></span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">struct</span> task_struct *, current_task);</span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> task_struct *<span class="title function_">get_current</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> this_cpu_read_stable(current_task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current get_current()</span></span><br></pre></td></tr></table></figure>

<p>其中<code>DECLARE_PER_CPU</code> 和 <code>this_cpu_read_stable</code> 用于支持 SMP 系统。</p>
<p>那么如何获得内核栈的栈指针呢？在<code>x86</code>架构中，使用特殊的段类型： <code>TSS</code>，它被用来存放硬件上下文。TSS 反映了 CPU 上的当前进程的特权级。linux 为每一个 cpu 提供一个 <code>TSS段</code>，并且在<code>tr</code>寄存器中保存该段。</p>
<p>在从用户态切换到内核态时，可以通过获取 <code>TSS段</code>中的 <code>esp0</code>来获取当前进程的内核栈 <strong>栈顶指针</strong>，从而可以保存用户态的<code>cs</code>，<code>esp</code>，<code>eip</code>等上下文。相关结构体和宏在<code>arch/x86/include/asm/processor.h</code> 中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_current_top_of_stack cpu_tss_rw.x86_tss.sp1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">x86_hw_tss</span> <span class="title">x86_tss</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> io_bitmap[IO_BITMAP_LONGS + <span class="number">1</span>];</span><br><span class="line">&#125; __aligned(PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">DECLARE_PER_CPU_PAGE_ALIGNED(<span class="keyword">struct</span> tss_struct cpu_tss_rw);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for x86_64</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x86_hw_tss</span> &#123;</span></span><br><span class="line">    u32 reserved1;</span><br><span class="line">    u64 sp0;</span><br><span class="line">    u64 sp1;</span><br><span class="line">    ...</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>linux的<code>tss段</code>中只使用<code>esp0</code>和<code>iomap</code>等字段，并且不用它的其他字段来保存寄存器。在一个用户进程被中断进入内核态的时候，从<code>tss</code>中的硬件状态结构中取出<code>esp0</code>（即内核栈栈顶指针），然后切到<code>esp0</code>，其它的寄存器则保存在<code>esp0</code>指的内核栈上而不保存在<code>tss</code>中。</p>
<h3 id="进程组织"><a href="#进程组织" class="headerlink" title="进程组织"></a>进程组织</h3><p>所有（处于TASK_RUNNING状态的）进程被组织在双向链表中。在每个进程的 PCB 中都包含链表节点（<code>struct list_head tasks</code>），<code>tasks</code>和其他指针字段一起将所有进程组织成<strong>进程树</strong>。</p>
<p>表示进程间亲属关系的字段有<code>parent</code>、<code>real_parent</code>、<code>children</code>和<code>sibling</code>。进程之间还存在非亲属关系，例如一个进程可能是一个进程组或登陆会话的领头进程。这些字段包括<code>group_leader</code>、<code>tgid</code>等。</p>
<p>对于处于等待状态中的进程，内核将它放入被等待事件的<strong>等待队列</strong>中，并可以在未来条件满足时唤醒进程。<strong>等待队列</strong>由双向链表实现。</p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>进程切换任务主要由 <code>siwtch_to</code>宏完成，它定义在<code>include/asm-generic/switch-to.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *,</span></span><br><span class="line"><span class="class">				       <span class="keyword">struct</span> <span class="title">task_struct</span> *);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next, last)					\</span></span><br><span class="line"><span class="meta">	do &#123;								\</span></span><br><span class="line"><span class="meta">		((last) = __switch_to((prev), (next)));			\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><h3 id="竞争和并发控制"><a href="#竞争和并发控制" class="headerlink" title="竞争和并发控制"></a>竞争和并发控制</h3><p><code>SMP</code> 架构</p>
<h3 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h3><p><code>local_irq_enable</code> 和 <code>local_irq_disable</code> 用于单核的本地中断的开关。对于 ARM 处理器而言，其实就是保存和恢复<code>CPSR</code>。</p>
<p><code>local_bh_enable</code> 和 <code>local_bh_disable</code> 用于下半部（tasklet、sortirq）的开启和关闭。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><h4 id="针对整型变量的原子操作"><a href="#针对整型变量的原子操作" class="headerlink" title="针对整型变量的原子操作"></a>针对整型变量的原子操作</h4><h4 id="针对位的原子操作"><a href="#针对位的原子操作" class="headerlink" title="针对位的原子操作"></a>针对位的原子操作</h4><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>自旋锁、互斥体、信号量、读写锁和顺序锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁一般用于 SMP 和内核可抢占的情况。</p>
<p>自旋锁一般和 <code>local_irq_xxxxx</code>、<code>local_bh_xxxxx</code> 的使能和禁止结合使用，使得无论是在核 0 的中断上下文、进程上下文还是核 1 上的中断上下文、进程上下文都可以避免并发的可能性。</p>
<p>使用自旋锁需要注意：</p>
<ul>
<li>自旋锁是忙等锁，因此，只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。但临界区很大时或有共享设备的适合，需要较长时间占用锁，使用自旋锁会降低系统的性能。</li>
<li>自旋锁可能导致系统死锁。</li>
<li>自旋锁所保护的临界区不能睡眠或者其他引起进程调度的函数。</li>
</ul>
<h4 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h4><p>关于 RCU 的经典文档 <a href="https://www.kernel.org/doc/ols/2001/read-copy.pdf">Read-Copy Update</a>。</p>
<p>不同于<code>自旋锁</code>, 使用<code>RCU</code>的读端没有锁、内存屏席、原子指令类的开销，几乎可以认为是直接读（只是简单地标明读开始和读结束），而<code>RCU</code>的写执行单元在访问它的共享资源前首先复制一个副本， 然后对副本进行修改， 最后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据，这个时机就是所有引用该数据的<code>CPU</code>都退出对共享数据读操作的时候， 等待适当时机的这一时期称为<code>宽限期(Grace Period)</code>。</p>
<p><code>RCU</code>可以看作<code>读写锁</code>的高性能版本，相比<code>读写锁</code>，<code>RCU</code>的优点存于既允许多个读执行单元同时访问被保护的数据。又允许多个读执行单元和多个写执行单元同时访问被保护的数据。但是，<code>RCU</code>不能替代<code>读写锁</code>，因为如果写比较多时，对读执行单元的性能不能弥补写执行单元同步导致的损失。因为使用<code>RCU</code>时，写执行单元之间的同步开销会比较大， 它需要延迟数据结构的释放、复制被修改的数据结构， 它也必须使用某种锁机剖来同步并发的其他写执行单元的修改操作。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><h3 id="完成量（Completion）"><a href="#完成量（Completion）" class="headerlink" title="完成量（Completion）"></a>完成量（Completion）</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2023/03/08/Linux-Kernel-Introduction/linux_kernel_mm.png"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>从虚拟内存的角度来看，2.6 之后的内核融合了<code>r-map（反向映射）</code>技术，显著改善虚拟内存在一定大小负载下的性能。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>Linux 在32位系统使用传统的二级页表，在64位系统使用三级或四级页表。<code>分页</code>是内核与硬件共同协作完成的功能。概括来说，每个进程在自己的地址空间中都有属于自己的多级页表，并且在进程描述符中包含第一级页表的指针。该指针使用时会被写入一个特定的控制寄存器（在 <code>80x86</code>中为<code>cr3</code>控制寄存器）。在进程切换时，控制寄存器的值会被保存到前一个进程的进程描述符中，随后的地址翻译几乎全由硬件完成（<code>MMU</code>）。相关头文件：<code>arch/&lt;ARCH&gt;/include/asm/&#123;page.h, pgtable.h&#125;</code>等。</p>
<p>页表的每一项是一个无符号整数，其中包含标志位和（<strong>页或者下一级页表的</strong>）物理地址的高位。对于<code>4k</code>大小的页，页物理地址的低12位为0，所以正好可以放置标志位。重要的几个标志位如下：</p>
<table>
<thead>
<tr>
<th align="left">位</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left"><strong>Present</strong></td>
<td align="left">1: 该页在物理内存中；0: 该页没有分配，其他标志位无意义。</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left"><strong>Writeable</strong></td>
<td align="left">1: 该页可写；0：该页只读。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>User&#x2F;Supervisor</strong></td>
<td align="left">1：用户<strong>可以</strong>访问该页；0：用户<strong>不可以</strong>访问该页。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>PWT</strong></td>
<td align="left">1：该页对应的 cache 使用<code>write through</code>模式；0：使用<code>write back</code>模式。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>PCD</strong></td>
<td align="left">1：该页不能被cache；0：是否可以被cache，由<code>cr0</code>寄存器的<code>CD</code>位决定。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>Access</strong></td>
<td align="left">该页被访问（读&#x2F;写）后，被置1；用户可以置0；此位决定了该页的地址映射关系是否可以被 <code>TLB</code>缓存。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>Dirty</strong></td>
<td align="left">该位只对映射非线性磁盘文件的页有意义。当该页被写入时，则置1；后续需要回收页时，该页被flush到下级存储，然后此位被置0。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>PSE&#x2F;PAT</strong></td>
<td align="left">1：PSE，使用<code>4M或2M</code>的页；0：PAT，使用<code>4k</code>的页。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>Global</strong></td>
<td align="left">该位用于决定在<code>上下文切换</code>时是否需要冲刷(flush) TLB 中的 entry。</td>
</tr>
</tbody></table>
<p><strong>内核页表</strong></p>
<h3 id="高速缓冲和TLB"><a href="#高速缓冲和TLB" class="headerlink" title="高速缓冲和TLB"></a>高速缓冲和TLB</h3><p><code>高速缓存</code>处于内存和寄存器之间，一般使用 SRAM 实现。高速缓存与内存的一致性由 CPU 自动同步；但 <code>TLB</code> 与进程页表的同步需要内核来完成。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><p><img src="/2023/03/08/Linux-Kernel-Introduction/linux_kernel_vfs.png"></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><p>内核一般要做到<code>drivers</code>与<code>arch</code>的软件架构分离，驱动中不包含板级信息，让驱动跨平台。同时内核的通用部分（如<code>kernel</code>、<code>fs</code>、<code>ipc</code>、<code>net</code> 等）则与具体的硬件（<code>arch</code> 和<code>drivers</code>）剥离。</p>
<h3 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h3><p><code>udev</code> 取代 <code>devfs</code>（关于策略与机制的分离，内核负责提供机制，和策略相关的事情放到用户空间来做）。</p>
<p><code>udev</code> 完全在用户态工作， 利用设备加入或移除时内核所发送的<code>热插拔事件</code>(HotplugEvent)来工作，在热插拔时，设备的详细信息会由内核通过<code>netlink</code>套按字发送出来， 发出的事件叫<code>uevent</code>。<code>udev</code>的设备命名策略、权限控制和事件处理都是用户态下完成的， 它利用从内核收到的信息来进行创建设备文件节点等工作。</p>
<h3 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h3><p>Linux 2.6以后的内核引入了<code>sysfs</code>文件系统，<code>sysfs</code>被看成是与<code>proc</code> 、<code>devfs</code>和<code>devpty</code>同类别的文件系统。</p>
<p><code>sysfs</code>把连接在系统上的设备和总线组织成为一个分级的文件。它们可以由用户空间存取，向用户空问导出内核数据结构以及它们的属性。 <code>sysfs</code>的一个目的就是展示设备驱动模型中各组件的层次关系。</p>
<p><img src="/2023/03/08/Linux-Kernel-Introduction/linux_kernel_dev.png"></p>
<p>从代码分析的角度看，<code>struct bus_type</code> 定义总线，<code>struct device_driver</code> 定义驱动，<code>struct device</code> 定义设备，<code>struct class</code> 定义类。驱动和设备是分开注册的，依靠 <code>bus_type</code> 的 <code>match()</code> 函数将两者绑定到一起，一旦配对成功，<code>xxxx_driver</code> 的 <code>probe()</code> 函数就被执行（<code>xxxx</code> 是总线名，如<code>platform</code>、<code>pci</code>、<code>i2c</code>、<code>spi</code>、<code>usb</code>等）。</p>
<blockquote>
<p>总线、驱动和设备最终都会落实为<code>sysfs</code>中的 1 个目录，因为进一步追踪代码会发现，它们实际上都可以认为是<code>kobject</code>的派生类，<code>kobject</code>可看作是所有<code>总线</code>、<code>设备</code>和<code>驱动</code>的抽象基类，1 个<code>kobject</code>对应<code>sysfs</code>中的 1 个目录。<code>总线</code>、<code>设备</code>和<code>驱动</code>的各个 <code>attibute</code> 则直接落实为 <code>sysfs</code> 中的一个文件，<code>attribute</code> 会伴随着<code>show()</code> 和 <code>store()</code> 这两个函数。</p>
</blockquote>
<h3 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h3><p><code>struct cdev</code> 结构体描述了一个字符设备。</p>
<p><img src="/2023/03/08/Linux-Kernel-Introduction/linux_char_device.png"></p>
<p><strong>a. 加载和卸载函数</strong></p>
<p>在加载函数中应该实现设备号的申请和 <code>cdev</code> 的注册，而在卸载函数中应该实现设备号的释放和 <code>cdev</code> 的注销。</p>
<p><strong>b. file_operations 结构体中的成员函数</strong></p>
<p><code>file_operations</code> 结构体中的成员函数是字符设备驱动与内核虚拟文件的接口。</p>
<p>特别注意的是，在这些接口中，很多需要进行内核空间与用户空间的数据拷贝，内核必须检查用户空间缓冲区的合法性显得尤其重要，很多内核漏洞都是因为忽略这一检查造成的。攻击者可以伪造一片内核空间的缓冲区地址传入系统调用的接口，让内核对这个 evil 指针指向的内核空间填充数据。</p>
<p>内核在实现 <code>copy_from_user()</code> 和 <code>copy_to_user()</code> 等函数时会调用 <code>access_ok()</code> 函数，该函数会做用户空间地址合法性检查。</p>
<h3 id="Linux-驱动的软件架构"><a href="#Linux-驱动的软件架构" class="headerlink" title="Linux 驱动的软件架构"></a>Linux 驱动的软件架构</h3><p>Linux 设备驱动非常重视软件的可重用和跨平台能力，驱动和硬件平台信息应该解耦。Linux 设备、驱动和总线结合起来可以做到这一点。另外 Linux 也采用分层机制，将驱动层中通用的部分提炼为一个中间层，减少驱动层的复杂性。</p>
<p>设备和驱动的分离：<br><img src="/2023/03/08/Linux-Kernel-Introduction/linux_bus_dev_dri.png"></p>
<p>Linux 驱动的分层：<br><img src="/2023/03/08/Linux-Kernel-Introduction/linux_driver_layers.png"></p>
<p><strong>分隔</strong>：<br><img src="/2023/03/08/Linux-Kernel-Introduction/software_NN_1N.png">  </p>
<p>Linux 为 SoC 内存空间的外设（SoC中集成的独立外设控制器）发明了一种虚拟的总线，称为 <code>platform</code> 总线，相应的设备称为 <code>platform_device</code>，而驱动称为 <code>platform_driver</code>（与 <code>i2c_driver</code>、<code>spi_driver</code>、<code>usb_driver</code>、<code>pci_driver</code> 对等）。</p>
<p>如前文所述，系统也为 <code>platform</code> 总线定义了 <code>bus_type</code> 的实例 <code>platform_bus_type</code> ，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">	.dev_groups	= platform_dev_groups,</span><br><span class="line">	.match		= platform_match,</span><br><span class="line">	.uevent		= platform_uevent,</span><br><span class="line">	.dma_configure	= platform_dma_configure,</span><br><span class="line">	.pm		= &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_bus_type);</span><br></pre></td></tr></table></figure>

<p>其中 <code>match()</code> 函数用于确定 <code>platform_device</code> 和 <code>platform_driver</code> 的匹配。</p>
<p>四种匹配方法：</p>
<ul>
<li>基于设备树风格的匹配 </li>
<li>基于 <code>ACPI</code> 风格的匹配</li>
<li>匹配 <code>ID</code> 表（即 <code>platform_device</code> 设备名是否出现在 <code>platform driver</code> 的 <code>ID</code> 表中）</li>
<li>匹配 <code>platform_device</code> 设备名和驱动的名字。</li>
</ul>
<p>在设备驱动中引入 <code>platform</code> 的概念至少有如下好处：</p>
<ul>
<li>使设备被挂载在一个总线上，符合 Linux 2.6 以后内核的设备模型。</li>
<li>隔离 <code>BSP</code> 和 <code>驱动</code>。在 <code>BSP</code> 中定义 <code>platform</code> 设备和设备所使用的资源、设备的具体配置信息，而在驱动中，只需要通过调用 <code>API</code> 去获取资源和数据。使得驱动具有更好的可扩展性和跨平台性。</li>
<li>让一个驱动支持多个设备实例。</li>
</ul>
<p>这中分层设计类似于面向对象的编程模型。</p>
<h4 id="Linux-内核输入子系统"><a href="#Linux-内核输入子系统" class="headerlink" title="Linux 内核输入子系统"></a>Linux 内核输入子系统</h4><p><img src="/2023/03/08/Linux-Kernel-Introduction/linux_input_subsystem.png"></p>
<p>驱动的核心层的职责：</p>
<ul>
<li>对上提供接口。file_operations 的接口被中间层完成，各种 IO 模型也被处理。</li>
<li>中间层实现通用逻辑。</li>
<li>对下定义框架。底层的驱动不需要关心 Linux 内核 <code>VFS</code> 的接口和各种可能的 IO 模型，而只需要处理和硬件相关的访问。</li>
</ul>
<p>主机驱动和外设驱动分离的核心思想。</p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>Linux Kernel</category>
      </categories>
  </entry>
  <entry>
    <title>Linux Kernel Security Summary</title>
    <url>/2025/02/28/Linux-Kernel-Security-Summary/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>内核安全是系统安全体系中的核心，但系统管理者和内核开发者在刚开始追求性能和功能的时候，却往往会牺牲安全性。但随着 Linux 应用在更广泛和更复杂的系统中，对增强其安全机制的呼声也越来越强烈，也越来越重要。本文根据相关资料就内核安全的诸多方面做一些总结。</p>
<span id="more"></span>

<blockquote>
<p>参考 《Linx 内核安全模块深入剖析》by 李志<br>参考 《Linux系统安全：纵深防御、安全扫描与入侵检测》by 胥峰<br>参考  <a href="https://xz.aliyun.com/news/14272?time__1311=eqUxuiDtitDQi=D8D9DBLad2rqIzTKreO4D&u_atoken=63518ee0fb5b3e760cf728d9278c8b1b&u_asig=0a47314717410058547638926e0033">Linux内核安全探究：漏洞利用、防御机制与调试技术</a> By Ba1_Ma0<br>参考 <a href="https://blog.csdn.net/shizheng_Li/article/details/145945741">深入剖析Linux sudo的实现原理</a><br>参考 <a href="https://blog.csdn.net/xiao_yi_xiao/article/details/117735278">Linux ACL访问控制权限</a></p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><blockquote>
<p>计算机系统应对安全的办法大致有四种：隔离、控制、混淆和监视。—— 《剖析》</p>
</blockquote>
<h2 id="自主访问控制"><a href="#自主访问控制" class="headerlink" title="自主访问控制"></a>自主访问控制</h2><p>自主访问控制是指<strong>由用户决定</strong>制定访问<strong>策略</strong>。</p>
<p>Unix 的自主访问控制：进程操作文件（<code>r</code>,<code>w</code>, <code>x</code>），<code>root</code> 用户的进程几乎可以做任何事情。</p>
<p>Linux 的自动访问控制：增加了 <code>ACL (Access Control List)</code>，规定某一个用户或者某一个组的操作许可；而是对特权操作细化，就是 <code>Capabilities</code> ，将属于 <code>root</code> 用户的特权细化为互不相关的几十个能力。</p>
<h3 id="凭证-Credentials"><a href="#凭证-Credentials" class="headerlink" title="凭证 (Credentials)"></a>凭证 (Credentials)</h3><p><code>主体（Subjective）</code>凭证和<code>客体（Objective）</code>凭证：进程可以是主体，也可以是客体。</p>
<blockquote>
<p>在大多数情况下，主体凭证和客体凭证的值都是相同的，但在某些情况下内核代码会修改当前进程的主体凭证，以获得某种访问权限，待执行完任务后再将主体凭证改回原值。 ——《剖析》</p>
</blockquote>
<p>进程 TCB 结构体中和凭证相关的成员：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">  ...</span><br><span class="line">	/* Process credentials: */</span><br><span class="line">	</span><br><span class="line">	const struct cred __rcu		*ptracer_cred;    /* Tracer&#x27;s credentials at attach: */</span><br><span class="line">	const struct cred __rcu		*real_cred;       /* Objective and real subjective task credentials (COW): */</span><br><span class="line">	const struct cred __rcu		*cred;            /* Effective (overridable) subjective task credentials (COW): */</span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>struct cred</code> 结构体中包含 <code>ID</code>(gid 和 uid)、<code>能力集</code>、<code>密钥环（keyring）</code>及<code>强制访问控制</code>相关的成员。</p>
<p>可以读取 <code>/proc/[pid]/status</code> 查看进程凭证。</p>
<h4 id="关于-uid、euid、suid-和-fuid"><a href="#关于-uid、euid、suid-和-fuid" class="headerlink" title="关于 uid、euid、suid 和 fuid"></a>关于 uid、euid、suid 和 fuid</h4><p><code>euid</code> 和提升权限有关。</p>
<p>初始时，<code>suid</code> 为 0，当需要提升进程权限时，<code>suid</code> 和 <code>euid</code> 做交换，此时进程拥有特权；执行完特权操作，再将两者做一次交换，进程就失去特权。</p>
<p><code>gid</code> 和 <code>uid</code> 类似，但 <code>group id</code> 与特权无关，<code>egid</code> 或者别的 <code>gid</code> 为 0，进程不会因此获得特权。</p>
<p>（内核在判断是否赋予特权时，依据的是 <code>capabilities</code>，不是 <code>uid</code>）。</p>
<h4 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h4><p><code>setuid</code> 和 <code>seteuid</code>，调用这些系统调用本身也需要特权。</p>
<h4 id="sudo-命令的实现原理"><a href="#sudo-命令的实现原理" class="headerlink" title="sudo 命令的实现原理"></a>sudo 命令的实现原理</h4><p>a. 利用 <code>euid</code> 进行临时权限提升</p>
<p>b. <code>setuid</code>机制</p>
<p><code>sudo</code>本身是一个二进制可执行文件（通常位于&#x2F;usr&#x2F;bin&#x2F;sudo），它被设置了<code>setuid</code>位。通过<code>ls -l</code>查看，可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rwsr-xr-x 1 root root  sudo</span><br></pre></td></tr></table></figure>

<p>这里的<code>s</code>表示<code>setuid</code>位。当普通用户运行<code>sudo</code>时，进程的<code>EUID</code>会自动变为文件拥有者的<code>UID</code>（即<code>root</code>，UID&#x3D;0），从而具备<code>root</code>权限。</p>
<p>c. 配置文件解析</p>
<p><code>sudo</code>启动后，首先以<code>root</code>权限运行，然后解析<code>/etc/sudoers</code>文件，检查调用者的权限。它使用严格的语法解析器，确保规则匹配。</p>
<p>d. 安全检查</p>
<p>在执行命令前，<code>sudo</code>会进行多项安全检查，例如验证用户密码、检查命令是否在允许范围内等。这些检查防止了未授权的操作。</p>
<p>e. 执行目标命令<br><code>sudo</code>通过<code>fork</code>创建一个子进程，并在子进程中调用<code>setuid</code>或<code>seteuid</code>将<code>EUID</code>切换为目标用户ID（通常是<code>root</code>）。然后，它使用<code>execvp</code>或类似函数执行用户指定的命令。</p>
<h3 id="客体标记和文件属性"><a href="#客体标记和文件属性" class="headerlink" title="客体标记和文件属性"></a>客体标记和文件属性</h3><p>在 <code>struct inode</code> 结构体中保存了文件属性，这些属性包括<code>允许位</code>、<code>属主和属组</code>、<code>ACL相关</code>、<code>强制访问控制</code>等。</p>
<p>相关的系统调用：<code>chown</code>(需要特权) 、<code>fchown</code>。</p>
<p>查看：<code>stat</code>、<code>fstat</code> 和 <code>lstat</code> 。</p>
<p>其他客体：<code>目录</code>（一种特殊的文件）、<code>管道</code>、<code>设备</code>、<code>socket</code>、<code>IPC</code>、<code>Key（密钥）</code>。</p>
<p>针对 <code>IPC</code> 和 <code>密钥</code>有专门的系统调用查看和修改属性。</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>主体凭证和客体标记都设置好后，就可以通过系统调用完成主体对客体的操作，更重要的是，内核需要在系统调用中判断相应的操作许可，进而实现访问控制。</p>
<p>操作：<code>读</code>、<code>写</code>、<code>执行</code> 和部分客体特有的操作。</p>
<h4 id="允许位"><a href="#允许位" class="headerlink" title="允许位"></a>允许位</h4><p>普通文件使用 9 个bit 的允许位。</p>
<h4 id="设置位"><a href="#设置位" class="headerlink" title="设置位"></a>设置位</h4><p>Unix 在 9 个允许位的基础上增加了允许位 <code>setuid</code>、<code>setgid</code>、<code>set-other-bit or sticky bit</code>，这三个允许位与操作许无关。</p>
<p><code>setuid</code>的机制 ： 进程调用 <code>execve</code> 执行了允许位 <code>setuid</code> 为 1 的文件后，进程的 <code>euid</code>，还有 Linux 特有的 <code>fsuid</code>，被改变为所执行文件的属主 id，于是，进程可以操作一些之前不能操作的客体。比如 <code>/usr/bin/sudo</code> 文件。</p>
<p><code>setgid</code>的机制 ： 与 <code>setuid</code> 类似。</p>
<p><code>sticky bit</code>的机制 ：在 Linux 中不再使用。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><code>chmod</code> 和 <code>fchmod</code> 可以修改文件和目录上的允许位。</p>
<h3 id="ACL（访问控制列表）"><a href="#ACL（访问控制列表）" class="headerlink" title="ACL（访问控制列表）"></a>ACL（访问控制列表）</h3><p><code>ACL</code> 只作用于文件和目录。在普通权限中，用户对文件只有三种身份，就是属主、属组和其他；但在实际场景中，这三种身份是不够的，Linux 使用 ACL 对此进行了扩展，来实现更细粒度的访问控制。</p>
<p>在很多 Linux 系统上，<code>ACL</code> 权限默认是开启的，可以通过查看根分区文件系统信息进行确认：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dumpe2fs -h /dev/sdx</span></span><br><span class="line">...</span><br><span class="line">Filesystem flags:         unsigned_directory_hash</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在 <code>Default mount options</code> 中可以看到是否开启 <code>ACL</code> 权限。</p>
<h4 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h4><p>在 <code>inode</code> 结构体中有指向和 <code>ACL</code> 相关的扩展属性<code>i_acl</code> 及 <code>i_default_acl</code> 的指针。</p>
<p>这两个属性的类型是 <code>struct posix_acl</code>，它是一个变长数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_acl_entry</span> &#123;</span></span><br><span class="line">	<span class="type">short</span>			e_tag;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		e_perm;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">kuid_t</span>		e_uid;</span><br><span class="line">		<span class="type">kgid_t</span>		e_gid;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> &#123;</span></span><br><span class="line">	<span class="type">refcount_t</span>		a_refcount;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">a_rcu</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		a_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl_entry</span>	<span class="title">a_entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct posix_acl_entry</code> 可以记录一个用户或者一个组的操作许可，也就实现了细粒度访问控制。</p>
<h4 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h4><p><code>setxattr</code> 、 <code>getxattr</code>、<code>removexattr</code> 等</p>
<h4 id="权限设置指导"><a href="#权限设置指导" class="headerlink" title="权限设置指导"></a>权限设置指导</h4><p>a.  查看 <code>ACL</code> 权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> getfacl &lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<p>b.  设置 <code>ACL</code> 权限到特定用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> tmp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">chown</span> root:my_group tmp/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 700 tmp/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> getfacl tmp/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> useradd test_user</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> setfacl -m u:test_user:rx tmp/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> getfacl tmp/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: tmp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: my_group</span></span><br><span class="line">user::rwx</span><br><span class="line">user:test_test_user:r-x</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>

<p>c.  设置 <code>ACL</code> 权限到特定用户组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> groupadd test_group</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> setfacl -m g:test_group:rwx tmp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> getfacl tmp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: tmp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: my_group</span></span><br><span class="line">user::rwx</span><br><span class="line">user:test_test_user:r-x</span><br><span class="line">group::rwx</span><br><span class="line">group:test_group:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>

<p>d. 删除 <code>ACL</code> 权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> setfacl -x u:test_user tmp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> setfacl -x g:test_group tmp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有权限</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> serfacl -b tmp</span></span><br></pre></td></tr></table></figure>

<h3 id="Capabilities（能力）"><a href="#Capabilities（能力）" class="headerlink" title="Capabilities（能力）"></a>Capabilities（能力）</h3><p><strong>特权机制</strong>：一些操作无法纳入允许位控制，如重启系统或者设置系统时间；另外一类是超越允许位控制。</p>
<blockquote>
<p>如果没有设计特权机制，为了解决设置系统时间这类任务，必须要引入新的客体类型，或者引入一种新的文件类型（如 SELinux）。 —— 《剖析》</p>
</blockquote>
<p>Linux 参考 <code>IEEE 1003.1e</code> 和 <code>IEEE 1003.2c</code> 实现了自己的能力机制。</p>
<h4 id="能力分类"><a href="#能力分类" class="headerlink" title="能力分类"></a>能力分类</h4><ul>
<li>文件：如 <code>chown</code>、<code>dac_override</code>、<code>fowner</code> 等。</li>
<li>进程：如 <code>kill</code>、<code>setuid</code> 和 <code>setgid</code>及 <code>setpcap</code> 、<code>sys_chroot</code> 、<code>sys_nice</code> 等。</li>
<li>网络：如 <code>net_bind_service</code>（绑定系统特权端口）、<code>net_admin</code> 和 <code>net_raw</code> 等。</li>
<li>ipc: 如 <code>ipc_lock</code>(不受 rlimit 锁定内存限制)</li>
<li>系统：如 <code>block_suspend</code>、<code>sys_admin</code>、<code>sys_boot</code>、<code>sys_module</code>、<code>sys_time</code>、<code>sys_resource</code> 和 <code>wake_alarm</code> 等。</li>
<li>设备：如 <code>mknod</code></li>
<li>审计：如 <code>audit_write</code> 和 <code>audit_control</code></li>
<li>强制访问控制（MAC）</li>
</ul>
<h4 id="能力集合"><a href="#能力集合" class="headerlink" title="能力集合"></a>能力集合</h4><p><code>struct cred</code> 结构体中可以看到多个能力集：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Ambient</code> 和 <code>Inheritable</code> 集合的意义就在于可以帮助我们在进程树或 <code>namespace</code> 的范围内创建一个允许任意进程使用某些 <code>capabilities</code> 的环境。</p>
<h4 id="能力机制"><a href="#能力机制" class="headerlink" title="能力机制"></a>能力机制</h4><blockquote>
<p>Linux 内核在做特权判断时，判断的是进程凭证中的有效能力集中是否具备所要求的能力。—— 《剖析》</p>
</blockquote>
<blockquote>
<p>进程在execve 后的允许能力集有两个来源，一个是进程的可继承能力集和文件的可继承能力集的交集，另一个是文件的允许能力集和进程的限制能力集的交集。—— 《剖析》</p>
</blockquote>
<p><code>capget</code> 和 <code>capset</code> 系统调用。</p>
<h4 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h4><blockquote>
<p>Linux 内核判断进程是否进行特权操作的唯一标准就是相关的能力是否在进程的有效能力集中。Linux 内核中没有任何依据用户 id 进行授权的逻辑。</p>
</blockquote>
<blockquote>
<p>为了做到向后兼容，内核在涉及用户id 变化的系统调用中（setuid、seteuid、setreuid、setresuid、setfsuid）增加了调整进程的能力集的逻辑。</p>
</blockquote>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>通过查看 <code>/proc/self/status</code> 中的 <code>CapEff</code> 项获取当前进程的有效能力集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/self/status| grep Cap</span></span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 0000000000000000</span><br><span class="line">CapEff: 0000000000000000</span><br><span class="line">CapBnd: 000001ffffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br></pre></td></tr></table></figure>

<p>使用 <code>capsh</code> 解析16进制数中每个 1 bit所对应的能力：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> capsh --decode=000001ffffffffff</span></span><br><span class="line">0x000001ffffffffff=cap_chown,cap_dac_override,cap_dac_read_search ...</span><br></pre></td></tr></table></figure>

<p><code>ping</code> 命令没有使用<code>能力</code>，而是使用了 <code>setuid</code> 允许位来做特权提升。可以自行编译 ping 来使用<code>能力</code>：</p>
<p>新编译的 <code>ping</code> 并没有设置 <code>suid</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l builddir/ping/ping</span></span><br><span class="line">-rwxr-xr-x 1 mimose mimose 311960  3月 4日 12:30 builddir/ping/ping</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">setcap</span> <span class="string">&#x27;cap_net_raw+p&#x27;</span> builddir/ping/ping</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">getcap</span> builddir/ping/ping</span></span><br><span class="line">builddir/ping/ping cap_net_raw=p</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考 <a href="https://blog.csdn.net/demon7552003/article/details/117161829">Linux Capabilities 入门教程</a></p>
</blockquote>
<h2 id="强制访问控制"><a href="#强制访问控制" class="headerlink" title="强制访问控制"></a>强制访问控制</h2><h3 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h3><p><code>SELinux</code> 的安全机制包括：<code>基于角色的访问控制（RBAC）</code>、<code>类型增强（TE）</code> 和<code>多级安全（MLS）</code>。</p>
<p><code>类型增强</code>机制下，进程和文件都有一个类型。</p>
<p><code>MLS</code> 机制来源于 <code>BLP</code> 模型，<code>BLP</code> 模型下，进程和文件都有安全标签，标签有两项：敏感度和组别。</p>
<ul>
<li>低敏感的进程不能读高敏感度文件，高敏感度进程不能写低敏感度文件。</li>
<li>当进程的组别包含或者等于文件的组别时，进程可以操作文件。</li>
</ul>
<h3 id="SMACK"><a href="#SMACK" class="headerlink" title="SMACK"></a>SMACK</h3><h3 id="Tomovo"><a href="#Tomovo" class="headerlink" title="Tomovo"></a>Tomovo</h3><h3 id="AppArmor"><a href="#AppArmor" class="headerlink" title="AppArmor"></a>AppArmor</h3><blockquote>
<p>参考 <a href="https://blog.axiaoxin.com/post/apparmor/">AppArmor使用指南：Linux应用安全防护利器</a></p>
</blockquote>
<p><code>AppArmor</code> 的机制也是 <code>类型增强</code>，类型也可以被称为 <code>域</code>。<code>AppArmor</code> 的目标是限制应用程序的权限，从而保护操作系统和应用程序免受内部和外部威胁，包括<code>零日攻击</code>。它通过定义每个应用程序的安全配置文件来实现此目的，这些配置文件指定了应用程序可以访问的资源和允许的操作。</p>
<p>即使应用程序存在漏洞，<code>AppArmor</code> 也能通过限制其行为，来阻止漏洞被利用。**<code>AppArmor</code> 的核心思想是将访问控制属性绑定到程序而不是用户。** 它也被称为 “应用装甲”。</p>
<p><code>AppArmor</code> 基于文件路径进行访问控制。</p>
<p>查看安装状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> aa-status</span></span><br><span class="line">63 profiles are loaded.</span><br><span class="line">57 profiles are in enforce mode.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 <code>raspi OS</code>上需要修改 <code>cmdline.txt</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.... lsm=apparmor</span><br></pre></td></tr></table></figure>

<p><code>AppArmor</code> 的配置文件：</p>
<ul>
<li><strong>强制模式（enforce）</strong>：在此模式下，<code>AppArmor</code> 将强制执行配置文件中定义的策略，并阻止任何违反规则的操作，并将违规尝试记录到日志中。</li>
<li><strong>抱怨模式（complain）</strong>：在此模式下，AppArmor 不会阻止违反规则的操作，但会将违规尝试记录到日志中。此模式对于测试和开发新的配置文件很有用。</li>
</ul>
<p>使用 <code>aa-complain</code> 命令将配置文件设置为抱怨模式，使用 <code>aa-enforce</code> 命令将其设置为强制模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> aa-complain /path/to/bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> aa-enforce /path/to/bin</span></span><br></pre></td></tr></table></figure>

<p>为应用程序创建一个新的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> aa-genprof /usr/bin/myapp</span></span><br></pre></td></tr></table></figure>

<h3 id="Yama"><a href="#Yama" class="headerlink" title="Yama"></a>Yama</h3><h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><h2 id="审计和日志"><a href="#审计和日志" class="headerlink" title="审计和日志"></a>审计和日志</h2><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h2 id="其他机制"><a href="#其他机制" class="headerlink" title="其他机制"></a>其他机制</h2><h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间(namespace)"></a>命名空间(namespace)</h3><p>针对 <code>chroot</code> 的安全漏洞。</p>
<p><strong>a. 挂载命名空间（mount)</strong></p>
<p>Linux 通过挂载命名空间可以提供比 <code>chroot</code> 机制更完备的隔离方案。通过挂载命令空间，进程和一棵挂载树相联系，改变了进程的挂载命名空间，进程就和另一颗挂载树相对应。</p>
<p>虽然 <code>mount ns</code> 限制了进程对文件的访问，但攻击者仍然可以利用<strong>进程间通信</strong>将本不能被进程访问的文件内容暴露给进程。所以，需要引入进程间通信命名空间。</p>
<p><strong>b. 进程间通信命名空间</strong><br>进程间通信的标识存储在进程间通信命名空间中，进程中通信命名空间不同，进程寻找到的进程间通信实例就不同。</p>
<p><strong>c. Unix 分时命名空间(UTS)</strong></p>
<p><strong>d. 进程号命名空间</strong><br>使得容器中的进程不能够看到容器外的进程（比如通过 <code>kill</code> 命令向容器外的进程发送信号）。</p>
<p><strong>e. 网络命名空间</strong></p>
<p><strong>f. 用户命名空间</strong></p>
<p>在 <code>/proc/[pid]/ns</code> 下可以看到一些进程的命名空间信息。</p>
<blockquote>
<p>实际上，命名空间的开发和设计只能是量力而行和适可而止，因为在宏内核上理想的和绝对的隔离是不可能做到的。</p>
</blockquote>
<h3 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h3><blockquote>
<p>参考 <a href="https://loverhythm1990.github.io/2024/10/01/cgroup-v2/">使用 cgroupv2 限制进程资源使用</a><br>参考 <a href="http://arthurchiao.art/blog/cgroupv2-zh/">Control Group v2 - Kerneldoc</a></p>
</blockquote>
<p>一种安全攻击（Fork_bomb: 耗尽系统进程号资源）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bomb() &#123;</span><br><span class="line">   bomb | bomb &amp;</span><br><span class="line">&#125;</span><br><span class="line">bomb</span><br></pre></td></tr></table></figure>

<p>Unix 为应对上述安全挑战，提供了<code>配额（quota）</code> 和 <code>资源限制（rlimit）</code>机制。但存在<code>分散式管理</code>和 <code>缺乏统一资源管理机制</code>的问题。</p>
<p><code>CGroups</code> 控制组来源于 Google 开发的 <code>Process Containers</code> 的模块。其设计理念是将框架和具体的资源管理分离。Linux 内核子系统 <code>cgroup</code> 提供的用户态和内核的接口是名为<code>cgroup</code>的伪文件系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建 CGroup2 类型的控制组</span></span><br><span class="line">mkdir -p /sys/fs/cgroup/cgrp1/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 CPU 配额为 50%</span></span><br><span class="line">echo &quot;50000 100000&quot; &gt; /sys/fs/cgroup/cgrp1/cpu.max</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目标进程加入到该控制组，假设目标进程的 pid 为 1604</span></span><br><span class="line">echo 1604 &gt; /sys/fs/cgroup/cgrp1/cgroup.procs</span><br></pre></td></tr></table></figure>

<p>设计原则总结如下：</p>
<ul>
<li>以进程为控制单位</li>
<li>集中式管理</li>
<li>功能模块化</li>
<li>动态调配</li>
<li>层级结构</li>
<li>多对多结构：一个进程可以加入多个控制组，一个控制组可以包含度多个进程。</li>
</ul>
<p><code>cgroup v2</code> 是现代容器化技术（如 <code>Docker</code>、<code>Kubernertes</code>）的核心组件之一。它用于限制容器的资源使用，确保容器之间的资源隔离和公平分配。例如：</p>
<ul>
<li><code>Docker</code> 使用 <code>cgroup v2</code> 限制容器的 <code>CPU</code>、<code>内存</code> 和 <code>I/O</code>。</li>
<li><code>Kubernetes</code> 使用 <code>cgroup v2</code> 实现 <code>Pod</code> 的资源限制和 <code>QoS（服务质量）</code>策略。</li>
</ul>
<h3 id="seccomp"><a href="#seccomp" class="headerlink" title="seccomp"></a>seccomp</h3><blockquote>
<p>参考 <a href="https://blog.csdn.net/qq_44846324/article/details/121731640">Sandbox的安全机制 —— 使用 seccomp</a></p>
</blockquote>
<p><code>seccomp</code> 是内核的一个安全特性。它的原理是限制用户进程可以使用的系统调用。因此，<code>seccomp</code> 可以与其他安全技术一起用于构建<code>沙箱</code>。</p>
<p>三种模式：</p>
<ul>
<li><strong>DISABLED</strong>: 不使用 <code>seccomp</code>，进程的系统调用可以不受限制。</li>
<li><strong>STRICT</strong>：只能使用 4 个系统调用：<code>read</code>、<code>write</code>、<code>exit</code> 和 <code>sigreturn</code>。</li>
<li><strong>FILTER</strong>：对系统调用的限制被存入 <code>seccomp</code>结构体的第二个成员 <code>filter</code> 中，由 <code>filter</code> 决定系统调用是否可以使用。</li>
</ul>
<p><code>BPF 虚拟机</code>运行 <code>filter</code> 链中定义的<code>BPF 指令</code>。</p>
<p>在 <code>/proc/self/status</code> 文件中会显示当前进程的 <code>seccomp</code> 状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/self/status</span></span><br><span class="line">...</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	0000000000000000</span><br><span class="line">CapEff:	0000000000000000</span><br><span class="line">CapBnd:	000001ffffffffff</span><br><span class="line">CapAmb:	0000000000000000</span><br><span class="line">NoNewPrivs:	0</span><br><span class="line">Seccomp:	0</span><br><span class="line">Seccomp_filters:	0</span><br><span class="line">Speculation_Store_Bypass:	thread vulnerable</span><br><span class="line">SpeculationIndirectBranch:	unknown</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>例如，使用 <code>seccomp</code> 限制 <code>execve</code> 系统调用的使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *filename = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    syscall(SYS_execve, filename, argv, envp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p><code>ASLR</code> 可以对<code>栈（stack）</code>、<code>堆（heap）</code>、<code>内存映射（mmap）</code>、<code>vdso</code> 的地址做随机化处理。所谓随机化，就是内存区域的起点在一定范围内浮动，而浮动的依据是内核随机数设备产生的随机数。</p>
<p>随机化最好的是位置无关的可执行文件，除了 <code>vsyscall</code> 区，其余区域都做了地址随机化。<code>vsyscall</code>不能做随机化是因为它本身是 <code>Linux 内核 ABI</code> 的一部分。如果不考虑兼容老旧应用，可以在编译内核时把对 <code>vsyscall</code> 的支持去掉。</p>
<h2 id="漏洞利用与防御"><a href="#漏洞利用与防御" class="headerlink" title="漏洞利用与防御"></a>漏洞利用与防御</h2><h3 id="Linux-CVE"><a href="#Linux-CVE" class="headerlink" title="Linux CVE"></a>Linux CVE</h3><p><a href="https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html">Linux CVE 列表</a></p>
]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>信息安全</category>
        <category>Linux Kernel</category>
      </categories>
  </entry>
  <entry>
    <title>MPI Tutorial</title>
    <url>/2023/03/06/MPI-Tutorial/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp; 在并行 MIMD（多指令多数据）的世界中的大多数计算机都可以分为<code>分布式内存型</code>和<code>共享内存型</code>两种类型的系统。我们在<a href="http://1.117.83.246/index.php/archives/265/">OpenMP Tutorial</a> 中介绍了后一种，从编程人员的角度看，共享内存型的系统由多个核及可以全局访问的内存组成，在那里任何核可以访问任何内存地址。我们这篇文章介绍前一种系统的并行编程，通过使用一种消息传递（Message-Passing）接口 API。</p>
<blockquote>
<p>参考 《Introduction to ParallelProgramming》 by Peter Pacheco.</p>
</blockquote>
<span id="more"></span>

<p>&emsp;&emsp; <em>熟悉 Linux&#x2F;Unix 系统编程的开发人员会自觉地将 MPI 接口与部分进程间通信机制进行类比。常用的非共享内存的进程间通信机制包括管道、信号、消息队列等，但这些机制并不适合跨系统的分布式系统编程。</em></p>
<h2 id="下载安装-MPI-实现"><a href="#下载安装-MPI-实现" class="headerlink" title="下载安装 MPI 实现"></a>下载安装 MPI 实现</h2><p>&emsp;&emsp;MPI 作为一种<strong>标准</strong>，可以有多种<strong>实现</strong>。</p>
<p>&emsp;&emsp;<a href="https://www.mpich.org/">MPICH</a> 是一种高性能和可移植的 MPI 的实现，它的目标如下：</p>
<ul>
<li>有效支持不同类型的计算和通信平台，包括商用集群（commodity clusters）、高速网络和高端计算机系统（例如Blue Gene 和 Cray）。</li>
<li>通过一种已扩展的模块化的框架来支持使用 MPI 的尖端研究。</li>
</ul>
<p>&emsp;&emsp;在 Ubuntu 系统上下载：<code>sudo apt-get install mpich</code></p>
<p>&emsp;&emsp;我们可以看到该包依赖另外两个包<code>libmpich-dev</code> 和 <code>libmpich12</code>，它分别代表头文件和动态链接库（支持c&#x2F;c++&#x2F;fortran语言）。</p>
<p>&emsp;&emsp; <a href="https://www.open-mpi.org/">OpenMPI</a> 是 MPI 标准的另外一种实现。<br>&emsp;&emsp;在 ubuntu 上下载安装： <code>sudo apt-get instal libopenmpi-dev libopenmpi3 openmpi-bin opemmpi-common</code>。这些包包含了头文件、动态链接库和相关工具等。</p>
<p>&emsp;&emsp;我们下面的示例将使用 <strong>openmpi</strong> 实现。</p>
<h2 id="一个-HelloWord-程序"><a href="#一个-HelloWord-程序" class="headerlink" title="一个 HelloWord 程序"></a>一个 HelloWord 程序</h2><p>&emsp;&emsp; 我们把消息传递的主体称作进程（基本上与实际的进程等价），进程间的通信通过两个函数完成：<code>send</code> 函数和<code>receive</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openmpi/mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_STRING = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> greeting[MAX_STRING];</span><br><span class="line">    <span class="type">int</span> comm_sz;</span><br><span class="line">    <span class="type">int</span> my_rank;</span><br><span class="line">    </span><br><span class="line">    MPI_Init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(my_rank != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(greeting, <span class="string">&quot;Greeting from process %d of %d!&quot;</span>, my_rank, comm_sz);</span><br><span class="line">        MPI_Send(greeting, <span class="built_in">strlen</span>(greeting)+<span class="number">1</span>, MPI_CHAR, <span class="number">0</span>,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Greetings from process %d of %d!\n&quot;</span>, my_rank, comm_sz);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> q = <span class="number">1</span>; q &lt; comm_sz; q++)&#123;</span><br><span class="line">            MPI_Recv(greeting, MAX_STRING, MPI_CHAR, q, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, greeting);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，进程0接收来自其他非0进程的消息（通过一个<code>for</code>循环），非0进程则向进程0发送消息，编译该程序：</p>
<p><code>$ mpicc -g -Wall -o hello_mpi hello_mpi.c</code></p>
<p><code>mpicc</code> 是对 C 编译器的包装器，它简化了编译命令，使得用户不需要考虑指定头文件路径或链接动态库等编译选项。当然，我们也可以支持使用 C 编译器：</p>
<p><code>$ gcc -g -Wall -o hello_mpi hello_mpi.c -lmpi</code></p>
<p>我们可以直接运行 <code>./hello_mpi</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello_mpi</span></span><br><span class="line">Greetings from process 0 of 1!</span><br></pre></td></tr></table></figure>
<p>可以看到只有一个进程 0 被生成，并没有进程间通信。我们使用 <code>mpiexec</code> 来生成多个实例进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mpiexec -n 2 ./hello_mpi</span></span><br><span class="line">Greetings from process 0 of 2!</span><br><span class="line">Greeting from process 1 of 2!</span><br></pre></td></tr></table></figure>
<p><code>mpiexec -n &lt;number&gt; ./hello_mpi</code> 命令首先会让系统生成 <em>number</em> 个 <code>./hello_mpi</code> 程序实例（进程），然后可能会让系统调度不同的实例到不同的 Core 上运行，一旦所有进程运行后，MPI 实现会负责确保进程间可以相互通信。在我的系统上只有两个 Core，所以 <em>number</em> 最大为 2 。</p>
<p>也可以使用 <strong>硬件线程</strong> 来完成并发执行：</p>
<p><code>$ mpiexec -n 3 --use-hwthread-cpus ./hello_mpi</code></p>
<h2 id="主要-API"><a href="#主要-API" class="headerlink" title="主要 API"></a>主要 API</h2><h3 id="MPI-Init-和-MPI-Finalize"><a href="#MPI-Init-和-MPI-Finalize" class="headerlink" title="MPI_Init 和 MPI_Finalize"></a>MPI_Init 和 MPI_Finalize</h3><p><code>MPI_Init</code> 接口的原型如下:</p>
<p><code>int MPI_Init (int* argc_p, char*** argv_p);</code></p>
<p><code>argc_p</code> 和 <code>argv_p</code> 分别指向 <code>main</code>函数的 <code>argc</code>和 <code>argv</code>，MPI_Init 可以接管对命令行参数的处理，如果不需要，则将 argc_p 和 argv_p 置为 <code>NULL</code>。MPI_Init 接口负责 MPI 系统的初始化，例如为消息Buffer分配存储空间，为进程实例分配 Rank 等。也就是说，MPI_Init 必须在所有其他 MPI_XXXX 接口前调用。</p>
<p><code>MPI_Finalize</code> 接口的原型如下：</p>
<p><code>int MPI_FInalize(void);</code></p>
<p><code>MPI_Finalize</code> 会通知 MPI 系统我们已经完成了 MPI， 它会释放内部的动态内存空间。</p>
<p>###3.2 MPI_Comm_size 和 MPI_Comm_rank</p>
<p>MPI 系统定义了 <code>通讯者（Communicators）</code>的概念，它代表所有彼此可以通信的进程。在具体接口定义中，称为 <code>MPI_COMM_WORLD</code>。</p>
<p><code>MPI_Comm_size</code> 接口的原型如下：</p>
<p><code>int MPI_Comm_size(MPI_Comm comm, int* comm_sz_p);</code></p>
<p>该接口返回 <code>Communicators</code>（即形参 <code>comm</code>） 中所有进程的个数。</p>
<p><code>MPI_Comm_rank</code>接口的原型如下：</p>
<p><code>int MPI_Comm_rank(MPI_Comm comm, int* my_rank_p);</code></p>
<p>该接口返回<code>Communicators</code>（即形参 <code>comm</code>） 中当前进程（即当前调用 <code>MPI_Comm_rank</code>的进程）的排名（Rank）。</p>
<h3 id="SPMD-程序"><a href="#SPMD-程序" class="headerlink" title="SPMD 程序"></a>SPMD 程序</h3><p>&emsp;&emsp;在我们上面的 HelloWorld 例子中，所有的进程都共用同一个程序，但在程序内部使用<code>if-else</code>分支语句区分非0进程和0号进程的行为，进程的排名（Rank）通过调用 <code>MPI_Comm_rank</code>接口获得。这种并行编程的方法可以称为 <code>SPMD（单程序，多数据）</code>。SPMD 程序可以被任意多个进程运行。</p>
<h3 id="MPI-Send"><a href="#MPI-Send" class="headerlink" title="MPI_Send"></a>MPI_Send</h3><p><code>MPI_Send</code> 接口的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Send</span><span class="params">(<span class="type">void</span>* msg_buf_p, <span class="type">int</span> msg_size, MPI_Datatype msg_type, </span></span><br><span class="line"><span class="params">             <span class="type">int</span> dest, <span class="type">int</span> tag, MPI_Comm communicator)</span>;</span><br></pre></td></tr></table></figure>

<p><code>msg_buf_p</code> 指向消息的内容，<code>msg_size</code> 和 <code>msg_type</code> 共同决定了消息的大小。<code>MPI_Datatype</code> 代表数据单元的类型，类型列表如下：</p>
<ul>
<li>MPI_CHAR，MPI_UNSIGNED_CHAR</li>
<li>MPI_SHORT，MPI_UNSIGNED_SHORT</li>
<li>MPI_INT，MPI_UNSIGNED</li>
<li>MPI_LONG，MPI_UNSIGNED_LONG</li>
<li>MPI_LONGLONG</li>
<li>MPI_FLOAT</li>
<li>MPI_DOUBLE，MPI_LONG_DOUBLE</li>
<li>MPI_BYTE</li>
<li>MPI_PACKED</li>
</ul>
<p><code>dest</code> 代表目标进程的Rank，<code>tag</code>是非负整数，用来区分不同的消息（这是一种语义上的不同），<code>communicator</code> 代表<code>通讯者</code>，所有通讯类 MPI 接口都必须包含该参数。<code>Communicators</code> 定义了一种”通信宇宙”，不同<code>Communicators</code>中的进程不能相互通信。<br>例如，在某些场景中，我们需要使用两个库，它们都使用了MPI，但它们是独立建模的。我们需要防止两个库中的进程相互通信，一种简单的做法就是为两个库使用不同的<code>Communicators</code>。</p>
<p>需要特别注意的是，<code>MPI_Send</code> 接口的调用可能会使当前进程<strong>阻塞</strong>，也可能立即返回。MPI 为不同的语义提供了不同的接口。在<code>MPI_Send</code>的语义层面，对于消息的发送而言，不同实现有不同的细节。通常来说，我们使用 “信封” 模型，信息是 “信”，但我们需要增加一些额外的信息放在“信封”上面，这些信息包括：目标进程Rank、当前进程Rank、消息Tag、<code>Communicators</code>和消息的长度等。</p>
<h3 id="MPI-Recv"><a href="#MPI-Recv" class="headerlink" title="MPI_Recv"></a>MPI_Recv</h3><p><code>MPI_Recv</code> 接口的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Recv</span><span class="params">(<span class="type">void</span>* msg_buf_p, <span class="type">int</span> msg_size, MPI_Datatype msg_type, </span></span><br><span class="line"><span class="params">             <span class="type">int</span> source, <span class="type">int</span> tag, MPI_Comm communicator, </span></span><br><span class="line"><span class="params">             MPI_Status* status_p)</span>;</span><br></pre></td></tr></table></figure>

<p>大部分参数与 <code>MPI_Send</code> 接口相同，其中 <code>source</code> 代表消息来源进程的Rank；<code>tag</code>则需要和发送者 <code>MPI_Send</code> 中的 <code>tag</code> 保持匹配，<code>communicator</code> 也需要和发送者进程所在的<code>Communicators</code>保持匹配；<code>status_p</code> 大部分情况不会被用到，我们传递 <code>MPI_STATUS_IGNORE</code> 实参给它。</p>
<p>特别注意的是，<code>MPI_Recv</code>总是会<strong>阻塞</strong>，直到一个匹配的消息被完全接收。MPI 也提供了非阻塞的通信接口。</p>
<p>MPI 要求消息是 <code>非重叠的（nonovertaking）</code>，即如果一个进程 q 发送了两个消息给进程 r，那么在接收第二个消息之前，第一个消息对于r来说必须是可用的。但对于不同进程发送的消息，就没有这样的限制。换句话说，进程 m 相对进程 n 更早地向进程 r 发送消息，但并不代表进程 r 会更早地接收它。MPI 可能会运行在地理布局非常大的分布式系统中，这种系统中节点之间的网络通信速率可能相差很大。</p>
<h3 id="消息匹配"><a href="#消息匹配" class="headerlink" title="消息匹配"></a>消息匹配</h3><p>发送信息的进程 q 如果要确保信息被目标进程 r 接收，需满足以下条件：</p>
<ul>
<li>tag 要一致</li>
<li>communicator 要一致</li>
<li>dest &#x3D; r 并且 source &#x3D; q</li>
<li>msg_type 要一致，而且 r 的 msg_size 要大于等于 q 的 msg_size。</li>
</ul>
<p>这里有一个特殊情况，如果进程 r 从多个进程接收消息，这些进程完成任务的时间是不可预测的；如果 r 简单的以进程的排名顺序来接收消息，可能会导致部分“快进程”需要等待“慢进程”完成。为避免这个问题，MPI 提供了 <code>MPI_ANY_SOURCE</code> 常量，它可以作为进程 r <code>MPI_Recv</code> 接口中 <code>source</code> 的实参。这样进程 r 就可以按照发送者进程的完成顺序来接收消息。</p>
<p>类似的做法适用于 <code>tag</code> 形参。MPI 提供了 <code>MPI_ANY_TAG</code> 常量，它可以作为 <code>MPI_Recv</code> 中 <code>tag</code> 的实参，这使得 r 进程不用再指定不同tag消息的接收顺序。</p>
<p><code>MPI_ANY_TAG</code> 和 <code>MPI_ANY_SOURCE</code> 统称为 “通配符(Wildcard)” 参数，它的使用需要注意：</p>
<ul>
<li>只能有<strong>一个</strong>接收进程使用 “通配符” 参数。</li>
<li>对于 <code>Communicator</code> 参数没有”通配符” 实参。</li>
</ul>
<p>在实际编程中，消息匹配是非常重要的，如果使用 <code>MPI_Recv</code> 的进程没有接收到匹配的消息，它会一直阻塞。对于使用 <code>MPI_Send</code> 的进程，如果发送的信息没有任何接收进程匹配，那么它也会阻塞（如果使用非阻塞接口，发送的信息会丢失）。</p>
<h3 id="status-p-参数"><a href="#status-p-参数" class="headerlink" title="status_p 参数"></a><code>status_p</code> 参数</h3><p>在 3.6 节中我们说明了”通配符” 参数的使用，那么接收进程如何获取消息的发送者、消息的tag和消息的实际大小呢？</p>
<p>使用 <code>MPI_Recv</code> 接口的  <code>status_p</code> 参数可以用来获取这些信息，它是一个至少包含下面三个成员的结构体：</p>
<ul>
<li><strong>MPI_SOURCE</strong> ： 指定消息的发送者</li>
<li><strong>MPI_TAG</strong>: 指定消息的tag</li>
<li><strong>MPI_ERROR</strong></li>
</ul>
<p>消息的大小可以使用 <code>MPI_Get_count</code> 接口获取，其原型为：</p>
<p><code>int MPI_Get_Count(MPI_Status* status_p, MPI_Datatype type, int* count_p);</code></p>
<p>其中 <code>status_P</code> 和 <code>type</code> 要使用与<code>MPI_Recv</code>接口中相同的实参。</p>
<h2 id="一个复杂例子"><a href="#一个复杂例子" class="headerlink" title="一个复杂例子"></a>一个复杂例子</h2><h3 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h3><p>&emsp;&emsp; 与<a href="http://1.117.83.246/index.php/archives/265/">OpenMP Tutorial</a> 中相同，我们仍然以“使用梯形法则进行数值积分“作为例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openmpi/mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">Trap</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">int</span> n, <span class="type">double</span> h)</span> &#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans  =  (f(a) + f(b))/<span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        ans += f(a+i*h);</span><br><span class="line">    &#125;</span><br><span class="line">    ans *= h;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> my_rank, comm_sz, n = <span class="number">1024</span>, local_n;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.0</span>, b = <span class="number">3.0</span>, h, local_a, local_b;</span><br><span class="line">    <span class="type">double</span> local_int, total_int;</span><br><span class="line">    <span class="type">int</span> source;</span><br><span class="line"></span><br><span class="line">    MPI_Init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line"></span><br><span class="line">    h = (b-a)/n;</span><br><span class="line">    local_n = n / comm_sz;</span><br><span class="line">    local_a = a + my_rank * local_n * h;</span><br><span class="line">    local_b = local_a + local_n * h;</span><br><span class="line">    local_int = Trap(local_a, local_b, local_n, h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(my_rank != <span class="number">0</span>) &#123;</span><br><span class="line">        MPI_Send(&amp;local_int, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        total_int = local_int;</span><br><span class="line">        <span class="keyword">for</span>(source = <span class="number">1</span>; source &lt; comm_sz; source++)&#123;</span><br><span class="line">            MPI_Recv(&amp;local_int, <span class="number">1</span>, MPI_DOUBLE, source, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">            total_int += local_int;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;With n = %d trapezoids, our estimate\n&quot;</span>, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;of the integral from %f to %f = %.15e\n&quot;</span>, a, b</span><br><span class="line">                        , total_int);</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出，被积分函数为<code>f(x) = x*x</code> ，进程 0 除了完成自己的计算任务外，还负责接收其他进程的计算结果，并累加到最后的积分结果中。</p>
<p>编译后运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mpiexec -n 2 ./tap</span></span><br><span class="line">With n = 1024 trapezoids, our estimate</span><br><span class="line">of the integral from 0.000000 to 3.000000 = 9.006596088409424e+00</span><br></pre></td></tr></table></figure>

<h3 id="关于I-O"><a href="#关于I-O" class="headerlink" title="关于I&#x2F;O"></a>关于I&#x2F;O</h3><p>&emsp;&emsp; 对于同一 <code>Communicator</code>中的进程，输出端口<code>stdout</code>是共享的。如果多个进程同时使用它，就会产生竞争行为，输出结果的顺序也是无法预测的。 对于 <code>stdin</code> 输入端口，大多数 MPI 的实现只允许进程 0 访问 <code>stdin</code>，然后再由进程 0 将输入数据发送给其他进程。</p>
<h2 id="聚合通信"><a href="#聚合通信" class="headerlink" title="聚合通信"></a>聚合通信</h2><p>&emsp;&emsp;4.1 节中的例子存在什么问题呢？我们可以看到进程0有点“委屈地”完成所有的求和处理，而其他进程仅仅告诉进程0 ”将我的结果加到最终结果上“ 后就退出了。为了进一步提高通信效率，我们将尝试使用一些其他的通信布局。</p>
<h3 id="树形通信"><a href="#树形通信" class="headerlink" title="树形通信"></a>树形通信</h3><p>&emsp;&emsp;我们可以用下图来描述树形通信的一种类型，在这里求和工作可以在多个进程中并行执行，而不是像4.1中那样只有进程0来完成。</p>
<p><img src="/2023/03/06/MPI-Tutorial/mpi_tree.png"></p>
<p>树形通信虽然有很大的优势，但编程更加复杂。而且在不同的场景下，使用哪一种树形结构并不是预先知道的。</p>
<p>幸运的是，MPI实现 提供了方便的接口来帮助用户获得优化的 “全局求和函数（global-sum function）” 。与<code>MPI_Send</code>和<code>MPI_Recv</code>只代表两个进程的通信不同，“全局求和函数”包括了所有进程，我们也称这种通信为 <code>聚合通信（collective communications）</code>。为了区分，<code>MPI_Send</code>和<code>MPI_Recv</code> 经常被称为<code>点对点通信</code>。</p>
<h3 id="MPI-Reduce"><a href="#MPI-Reduce" class="headerlink" title="MPI_Reduce"></a>MPI_Reduce</h3><p>&emsp;&emsp;实际上，全局求和只是整个聚合通信大类中的特例。例如，全局求积、全局求最大值&#x2F;最小值等也是聚合通信的例子。</p>
<p>MPI 泛化了全局求和函数，使得它可以使用一个函数来实现多种类型的聚合通信，这个函数就是<br><code>MPI_Reduce</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Reduce</span> <span class="params">(<span class="type">void</span>* input_data_p, <span class="type">void</span>* output_data_p, <span class="type">int</span> count</span></span><br><span class="line"><span class="params">                MPI_Datatype datatype, MPI_Op operator, </span></span><br><span class="line"><span class="params">                <span class="type">int</span> dest_process, MPI_Comm comm)</span>;</span><br></pre></td></tr></table></figure>

<p><code>MPI_Reduce</code>函数的通用性体现在 <code>MPI_Op</code> 参数中，它代表操作符（就4.1节中的例子而言，该参数的实参应该是<code>MPI_SUM</code>），MPI 提供了多种类型的操作符。（对于熟悉函数式编程的用户来说，MPI_Reduce类似于高阶函数，它定义了聚合的概念，但并不依赖具体聚合类型。）</p>
<p>4.1 节中的全局求和代码<code>if(my_rank==0)&#123;...&#125;else&#123;...&#125;</code> 可以替换为下面一条语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MPI_Reduce(&amp;local_int, &amp;total_int, <span class="number">1</span>, </span><br><span class="line">            MPI_DOUBLE, MPI_SUM, <span class="number">0</span>, MPI_COMM_WORLD);</span><br></pre></td></tr></table></figure>
<p>值的注意的是，<code>count</code>参数可以使得 <code>MPI_Reduce</code> 可以操作数组而不仅仅操作标量数据。</p>
<p>MPI 预定义的 <code>Reduction 操作符</code>如下：</p>
<ul>
<li>MPI_MAX， MPI_MIN</li>
<li>MPI_SUM， MPI_PROD</li>
<li>MPI_LAND，MPI_BAND</li>
<li>MPI_LOR， MPI_BOR</li>
<li>MPI_LXOR，MPI_BXOR</li>
<li>MPI_MAXLOC，MPI_MINLOC</li>
</ul>
<p>用户也可以定义自己的操作符。</p>
<p>对于聚合通信和点对点通信的区别，还需要特别注意以下几点：</p>
<ul>
<li>在 <code>Communicator</code> 中的所有进程必须调用相同的聚合函数。</li>
<li>每个进程调用 MPI 聚合函数的实参必须 “兼容”。</li>
<li><code>output_data_p</code>参数只会在 <code>dest_process</code> 进程中用到。但其他进程仍然需要传递对应的实参，即使它的值为 NULL。</li>
<li><code>点对点通信</code>的匹配基于<code>Communicator</code>和 tag，但<code>聚合通信</code>的匹配不基于 tag ，它基于<code>Communicator</code>和聚合函数被调用的<strong>顺序</strong>。</li>
</ul>
<h3 id="MPI-Allreduce"><a href="#MPI-Allreduce" class="headerlink" title="MPI_Allreduce"></a>MPI_Allreduce</h3><p>&emsp;&emsp; 在前面的例子中，只有进程0可以获得最终求和结果并打印出来，但有时候其他进程也需要获得全局求和结果来完成一些更大的计算。为了做到这点，我们可以在进程0获得结果后再分发给其他进程，以下面的<strong>反转树</strong>为例：</p>
<p><img src="/2023/03/06/MPI-Tutorial/mpi_all_reduce.png"></p>
<p>另外，我们也可以使用一种称为 <strong>Butterfly</strong> 的通信模型：</p>
<p><img src="/2023/03/06/MPI-Tutorial/mpi_butterfly.png"></p>
<p>类似的，MPI 为用户提供了接口 <code>MPI_Allreduce</code>，该接口负责具体使用哪种分发模型获得最好的通信效率。<code>MPI_Allreduce</code>接口的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Allreduce</span> <span class="params">(<span class="type">void</span>* input_data_p, <span class="type">void</span>* output_data_p, <span class="type">int</span> count</span></span><br><span class="line"><span class="params">                MPI_Datatype datatype, MPI_Op operator,MPI_Comm comm)</span>;</span><br></pre></td></tr></table></figure>
<p>和<code>MPI_Reduce</code>不同的是，这里没有 <code>dest_precoss</code> 参数，因为所有的进程都应该获得最终结果。</p>
<h3 id="广播-MPI-Bcast"><a href="#广播-MPI-Bcast" class="headerlink" title="广播 MPI_Bcast"></a>广播 MPI_Bcast</h3><p>&emsp;&emsp;在4.2中，我们描述了 MPI 对输入输出的处理，在那里我们说进程0会将输入数据发送到其他进程。 一种简单的方法仍然是使用<code>MPI_Send</code>和<code>MPI_Recv</code>，进程0会在以一个<code>for</code>循环中向每个进程 <code>MPI_Send</code> 输入数据。我们可以想到使用树形结构进行优化（就像聚合函数一样），在聚合通信中，一个进程向<strong>所有</strong>其他进程发送数据称为一次<code>广播(Broadcast)</code>。MPI 提供了 <strong>广播函数</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Bcast</span><span class="params">(<span class="type">void</span>* data_p, <span class="type">int</span> count, MPI_Datatype datatype, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> source_proc, MPI_Comm comm)</span>;`</span><br></pre></td></tr></table></figure>

<p>进程<code>source_proc</code>将由<code>data_p</code>指向的数据内容发送给所有<code>comm</code> 中的进程（包括它自己吗？）。</p>
<p>例如4.1节中的 <code>a</code>, <code>b</code>, <code>n</code> 可以在进程0中通过<code>stdin</code>输入，然后再广播给其他进程，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Get_input</span><span class="params">(<span class="type">int</span> my_rank, <span class="type">int</span> comm_sz, <span class="type">double</span> *a_p,</span></span><br><span class="line"><span class="params">                <span class="type">double</span> *b_p, <span class="type">int</span>* n_p)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter a, b, and n\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %d&quot;</span>, a_p, b_p, n_p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MPI_Bcast(a_p, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    MPI_Bcast(b_p, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    MPI_Bcast(n_p, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MPI-Scatter"><a href="#MPI-Scatter" class="headerlink" title="MPI_Scatter"></a>MPI_Scatter</h3><p>&emsp;&emsp; 在上节中我们说单个进程可以使用 <code>MPI_Bcast</code> 向其他所有进程广播数据，最后所有的进程得到的数据是相同的。但有时候我们不愿意这样做，例如在“求向量A和向量B的和”的程序中，A与B在进程0中输入，但进程0不需要将所有A和B的所有项广播出去，它只需要传播其他进程所需要的项即可。<code>MPI_Scatter</code>可以满足这样的需求，其原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Scatter</span><span class="params">(<span class="type">void</span>* send_buf_p, <span class="type">int</span> send_count, </span></span><br><span class="line"><span class="params">                MPI_Datatype send_type, </span></span><br><span class="line"><span class="params">                <span class="type">void</span>* recv_buf_p, <span class="type">int</span> recv_count,</span></span><br><span class="line"><span class="params">                MPI_Datatype recv_type,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> src_proc, MPI_Comm comm)</span>;</span><br></pre></td></tr></table></figure>
<p><code>send_buf_p</code> 所指向的数据（假设共有 n 项）将会被 MPI 分成 <code>comm_sz</code> 份，例如如果使用<code>块划分</code>（与<code>OpenMP</code>中的<code>块划分</code>类似），那么进程0将获得前<code>n/comm_sz</code>项，进程1获得接下来的 <code>n/comm_sz</code>项，依次类推。每个进程需要传递本地向量指针作为<code>recv_buf_p</code>的实参，<code>recv_cnt</code>必须等于<code>n/comm_sz</code>。<code>send_type</code>与<code>recv_type</code>必须匹配，<code>src_proc</code>需等于 0 。注意<code>send_count</code>也要等于<code>n/comm_sz</code>。</p>
<h3 id="MPI-Gather"><a href="#MPI-Gather" class="headerlink" title="MPI_Gather"></a>MPI_Gather</h3><p><code>MPI_Gatter</code> 接口负责将所有的分组数据收集起来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Gather</span><span class="params">(<span class="type">void</span>* send_buf_p, <span class="type">int</span> send_count, </span></span><br><span class="line"><span class="params">                MPI_Datatype send_type, </span></span><br><span class="line"><span class="params">                <span class="type">void</span>* recv_buf_p, <span class="type">int</span> recv_count,</span></span><br><span class="line"><span class="params">                MPI_Datatype recv_type,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> dest_proc, MPI_Comm comm)</span>;</span><br></pre></td></tr></table></figure>
<p>它与<code>MPI_Scatter</code>几乎相同，<code>dest_proc</code>需等于 0 。</p>
<h3 id="MPI-Allgather"><a href="#MPI-Allgather" class="headerlink" title="MPI_Allgather"></a>MPI_Allgather</h3><p>&emsp;&emsp;我们以矩阵-向量乘法程序为例，<code>y</code> &#x3D; <strong>A</strong><code>x</code>，其中 x 为 n 维向量，<strong>A</strong>为 m 行 n 列的矩阵，那么 y 为 m 维向量。一个串行的程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Mat_vect_mult</span><span class="params">(<span class="type">double</span> A[], <span class="type">double</span> x[], <span class="type">double</span> y[], <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m ; i++)&#123;</span><br><span class="line">        y[i] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            y[i] += A[i*n+j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用一维数据模拟矩阵 <strong>A</strong> 。我们如何并行化这个程序呢?<br>我们以 <strong>A</strong> 的<strong>行</strong>来划分任务，即前<code>m/comm_sz</code>行分配给进程0，接下来的<code>m/comm_sz</code>行分配给进程1，依次类推。等价于，向量 y 的前<code>m/comm_sz</code>项的求取分配给进程0，接下来的<code>m/comm_sz</code>项的求取分配给进程1，依次类推。</p>
<p>向量 x 与 向量 y 如果在聚合通信中使用相同的数据分发机制（如<code>MPI_Scatter</code>），那么我们就需要对 x 作额外的处理。因为在每个进程中我们需要知道 x 的所有项，我们想到可以使用 <code>MPI_Bcast + MPI_Gather</code>来满足该需求，但可以使用性能更好的 <code>MPI_Allgather</code>接口（它使用 <strong>Butterfly</strong>广播模型）。</p>
<p>该接口的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_AllGather</span><span class="params">(<span class="type">void</span>* send_buf_p, <span class="type">int</span> send_count, </span></span><br><span class="line"><span class="params">                MPI_Datatype send_type, </span></span><br><span class="line"><span class="params">                <span class="type">void</span>* recv_buf_p, <span class="type">int</span> recv_count,</span></span><br><span class="line"><span class="params">                MPI_Datatype recv_type,</span></span><br><span class="line"><span class="params">                MPI_Comm comm)</span>;</span><br></pre></td></tr></table></figure>
<p>与<code>MPI_Gather</code>相比，我们不再需要<code>dest_proc</code>参数，因为我们收集的数据来自于所有进程而不是进程0（这也是<strong>Butterfly</strong>广播模型拥有更高通信效率的原因）；而且所有的进程都获得了收集后的数据，而不仅仅是<code>MPI_Gather</code>中的<code>dest_proc</code>进程。</p>
<p>现在我们可以编写并行版本的矩阵-向量乘法程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Mat_vect_mult</span><span class="params">(<span class="type">double</span> local_A[], <span class="type">double</span> local_x[],</span></span><br><span class="line"><span class="params">                   <span class="type">double</span> local_y[], <span class="type">int</span> local_m,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> n, <span class="type">int</span> local_n,</span></span><br><span class="line"><span class="params">                   MPI_Comm comm)</span> &#123;</span><br><span class="line">    <span class="type">double</span> *x = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> local_i, j;</span><br><span class="line">    <span class="type">int</span> local_ok = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    x = <span class="built_in">malloc</span>(n∗<span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    MPI_Allgather(local_x, local_n, MPI_DOUBLE,</span><br><span class="line">                    x, local_n, MPI_DOUBLE, comm);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (local_i = <span class="number">0</span>; local_i &lt; local_m; local_i++) &#123;</span><br><span class="line">        local_y[local_i] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            local_y[local_i] += local_A[local_i∗n+j]∗x[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MPI-派生数据类型"><a href="#MPI-派生数据类型" class="headerlink" title="MPI 派生数据类型"></a>MPI 派生数据类型</h2><p>&emsp;&emsp; 在分布式环境中，通信的代价往往比本地计算要昂贵，因此每次通信应该发送&#x2F;接收尽量多的数据（还一种说法就是，我们应该减少发送 Message 的个数）。MPI 提供了三种方法来<code>合并(consolidating)</code>数据：</p>
<ul>
<li>通信函数中的<code>count</code>参数</li>
<li>派生数据类型(derived datatype)</li>
<li><code>MPI_Pack/MPI_Unpack</code>接口</li>
</ul>
<p>MPI 派生数据类型类似于 C 语言的结构体，例如我们5.4节中<code>Get_Input()</code>中的三个广播函数可以优化为一个，只要我们定义一个派生数据类型<code>&#123;(MPI_DOUBLE,0), (MPI_DOUBLE, 16),(MPI_INT,24)&#125;</code>。（类型+偏移量）</p>
<p><code>MPI_Type_create_struct</code>接口用来定义派生数据结构，其原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Type_create_struct</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> array_of_blocklengths[],</span></span><br><span class="line"><span class="params">                           MPI_Aint array_of_displacements[],</span></span><br><span class="line"><span class="params">                           MPI_Datatype array_of_types[],</span></span><br><span class="line"><span class="params">                           MPI_Datatype* new_type_p)</span>; </span><br></pre></td></tr></table></figure>
<p>对于我们的例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> array_of_blocklengths[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">MPI_Aint array_of_displacements[] = &#123;<span class="number">0</span>, <span class="number">16</span>, <span class="number">24</span>&#125;;</span><br><span class="line">MPI_Datatype array_of_types[] = &#123;MPI_DOUBLE, MPI_DOUBLE, MPI_INT&#125;;</span><br><span class="line">MPI_Datatype input_mpi;</span><br><span class="line"></span><br><span class="line">MPI_Type_create_struct(count, array_of_blocklengths,</span><br><span class="line">                       array_of_displacements,</span><br><span class="line">                       array_of_types, &amp;input_mpi);</span><br><span class="line">MPI_Type_commit(&amp;input_mpi);</span><br><span class="line">MPI_Bcast(&amp;a, <span class="number">1</span>, input_mpi, <span class="number">0</span>, MPI_COMM_WORLD);</span><br></pre></td></tr></table></figure>
<p>为了获得 <code>array_of_displacements</code> 中数据成员的偏移量，可以使用 <code>MPI_Get_address</code>接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPI_Get_address</span><span class="params">(<span class="type">void</span> *location_p, MPI_Aint* address_p)</span>;</span><br><span class="line">MPI_Aint a_addr, b_addr, n_addr;</span><br><span class="line">MPI_Get_address(&amp;a, &amp;a_addr);</span><br><span class="line">array_of_displacements[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">MPI_Get_address(&amp;b, &amp;b_addr);</span><br><span class="line">array_of_displacements[<span class="number">1</span>] = b_addr - a_addr;</span><br><span class="line">MPI_Get_address(&amp;n, &amp;n_addr);</span><br><span class="line">array_of_displacements[<span class="number">2</span>] = n_addr - a_addr;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他可参考文章"><a href="#其他可参考文章" class="headerlink" title="其他可参考文章"></a>其他可参考文章</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/158584571">《MPI，OpenMPI 与深度学习》</a></li>
<li><a href="https://mpitutorial.com/tutorials/mpi-introduction/">《MPI Tutorial Introduction》</a> By Wes Kendall.</li>
</ol>
]]></content>
      <categories>
        <category>高性能计算</category>
      </categories>
  </entry>
  <entry>
    <title>SICP 笔记</title>
    <url>/2022/04/08/SICP-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第一章-构造过程抽象"><a href="#第一章-构造过程抽象" class="headerlink" title="第一章 构造过程抽象"></a>第一章 构造过程抽象</h3><ul>
<li><strong>程序设计基本元素：基本表达形式、组合的方法、抽象的方法。</strong></li>
</ul>
<span id="more"></span>

<p>（在计算模型中，全局环境的概念非常重要，它代表着计算机可以维护某种存储能力。在图灵机模型和早期大型机中都将内部存储能力作为通用型计算机的核心特点。）</p>
<ul>
<li><p><strong>一般而言，我们应将递归看作一种处理层次型结构（像树这样的结构）极强有力的技术。</strong>事实上，“值向上穿行”形式的求值形式是一类更一般计算过程的一个例子。这种计算过程称为<strong>树形积累</strong>。</p>
</li>
<li><p>环境所扮演的角色就是用于确定表达式中符号的意义。<br>（在形式代数中，任何符号都没有绝对的意义，它也不代表真理，它只是逻辑的信徒。在Lisp中，任何符号在环境中都有值对应，只是有些符号的值是它本身，有些是内部提供的基本过程，而有些则是用户自定义的。）</p>
</li>
<li><p><strong>语法糖衣</strong>：Lisp的语法非常简单，也就是说，对各种表达式的求值规则都可以描述为一个简单的通用规则和一组针对不同的特殊形式（例如define）的专门规则。<strong>语法的糖衣会导致分号的癌症。</strong><br>（Lisp简单的语法使得它获得了强大的表达复杂语义的能力。）</p>
</li>
<li><p><strong>过程定义是一种强大的抽象技术。</strong>数学函数和计算机过程的重要差异是，计算机过程必须是有效可行的（即可以转换为递归模型）。通俗地讲，它要给出行动性的‘怎么做’的知识。<br>（在几乎所有的现代编程语言中，都包含过程定义的能力，或者称为函数定义。可以定义子过程使得计算机编程的抽象能力大大提高。但最早期的一些大型机，例如ENIAC，都不能调用子过程，只能顺序执行设定好的程序。而图灵在ACE的方案设计中就已经引入了子过程特性。）</p>
</li>
<li><p><strong>代换模型：正则序和应用序</strong><br>（<strong>归约</strong> 是一种通用的方法论，它体现了人类的认知规律。将复杂问题规约为简单问题的组合是计算机编程的核心思维模型。）</p>
</li>
<li><p><strong>条件表达式和谓词</strong><br>（条件分支的特性是计算机模拟人类智能必不可少的能力。人类的智能很大程序上体现在判断决策、自主控制、修改现有观念状态等思维方式上，条件分支可以使得计算机拥有判断决策和修改自身的能力。）</p>
</li>
<li><p><strong>过程作为黑箱抽象</strong>，使用者不需要关心过程内部的实现细节。过程所使用的形式参数是局部变量或者称为约束变量。一个过程的定义约束了它的所有形式参数。（形式参数的作用域是这个过程的体。作用域的概念在几乎所有现代编程语言中都是基础核心的概念。）</p>
</li>
<li><p><strong>内部定义和块结构</strong>。(块结构是构造大型复杂程序的基础)</p>
</li>
<li><p><strong>线性递归和线性迭代</strong>。（两者的区别可以看作是计算状态的保存位置不同；另外在硬件实现方式上，递归需要一种称为栈的辅助数据结构。）<strong>尾递归</strong>：对于一个使用递归过程描述的迭代计算过程，尾递归总能在常量空间中来完成它；相比而言，没有实现尾递归的编译器就只能在线性空间中完成它。有了尾递归的实现，我们可以利用常规的过程调用机制表述迭代，这会使得各种复杂的专用迭代结构（如while、for、until和do等）变成不过是一些语法糖衣了。<strong>树形递归</strong>：<br>（在自然界中，到处都可以看出类似递归的结构，如贝壳的纹路，树枝的形态，种子等。）</p>
</li>
<li><p><strong>高阶函数 Lambda表达式</strong>:高阶过程的重要性就在于使我们能显式地用程序设计语言的要素去描述这些抽象,使我们能像操作其他计算元素一样去操作它们。</p>
</li>
<li><p><strong>第一级状态</strong>：</p>
<ul>
<li>可以用变量命名；</li>
<li>可以提供给过程作为参数；</li>
<li>可以由过程作为参数返回；</li>
<li>可以包含在数据结构中。<br>Lisp给予过程完全的第一级状态。<br>(Lambda表达式和闭包的概念有着紧密的联系。将过程作为参数或者过程的返回值，可以获得更强大的抽象能力。)</li>
</ul>
</li>
</ul>
<h3 id="第二章-构建数据抽象"><a href="#第二章-构建数据抽象" class="headerlink" title="第二章 构建数据抽象"></a>第二章 构建数据抽象</h3><ul>
<li>复合数据的使用可以进一步提高程序的模块性。这种将程序中处理数据对象表示的部分与处理数据对象的使用部分相互隔离的技术非常具有一般性，形成了一种称为<strong>数据抽象</strong>的强有力的方法学。</li>
<li>把对于具体表示方式的依赖性限制到少数几个界面（interface）过程，不但对修改程序有帮助，同时也有助于程序的设计。因为这种做法使我们能保留考虑不同实现方式的灵活性。……数据抽象方式使我们能够推迟决策（比如系统性能方面的优化）的时间，而不会阻碍系统其他部分的工作进程。</li>
<li><strong>闭包</strong>：用于组合数据对象的黏合剂不但能用于组合基本的数据对象,同样也可以用于复合的数据对象。另一关键思想是，复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面（interface）。（Lisp中cons的闭包性质使得它可以用优雅简单的方式构造层次型数据。另外在自然界中都可以看到类似的结构。）<br>（对于编译器或者解释器来说，程序语言的任何语句都可以认为是符号表达式。）</li>
<li><strong>序对</strong>的实现模糊了数据与过程的界限，也就是，这种基础数据结构的内部可以完全是过程的形式。（Lisp的过程具有第一级状态，过程体本身其实也是一种存储信息的结构，广泛地讲，任何一种过程都包含信息，而数据是信息的可存储并可访问的一种形式）。与Lisp及其序对不同，C&#x2F;Pascal&#x2F;Fortran&#x2F;Basic这些语言都没有内部的通用型粘接剂，因此无法以统一的方式去操作复合数据。（或许C&#x2F;Pascal的程序员会说，Lisp程序员是从来不考虑效率的理想主义者。）</li>
<li>（丘奇计数中去除了整数一般所认为的现实意义，即单纯表示数据，而是将其抽象为一种计数的过程。）</li>
<li><strong>序列（List）</strong></li>
<li>对表的映射: map是一种很重要的结构，不仅因为它代表了一种公共模式，而且因为它建立了一种处理表的高层抽象。从作用上看，map帮我们建起了一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组织结果的细节隔离开。</li>
<li><strong>树</strong>：递归是处理树结构的一种很自然的工具。</li>
<li><strong>List作为一种约定的接口</strong>：（流处理、枚举器、过滤器、累加器等）<strong>将程序表示为一些针对序列的操作，这样做的价值就在于能帮助我们得到模块化的程序设计，也就是说，得到由一些比较独立的片段的组合构成的设计。通过提供一个标准部件的库，并使这些部件都有着一些能以各种灵活方式相互连接的界面（接口），将进一步推动人们去做模块化的设计。在工程设计中，模块化结构是控制复杂性的一种威力强大的策略。</strong></li>
<li>八皇后谜题（eight-queen-puzzle）</li>
<li><strong>分层设计</strong>:一个复杂的系统应该通过一系列的层次构造出来,为了描述这些层次,需要使用一系列的语言。构造各个层次的方式，就是设法组合起作为这一层次中部件的各种基本元素，而这样构造出来的部件又可以作为另一个层次里的基本元素。在分层设计中，每个层次上所用的语言都提供了一些基本元素、组合手段，还有对该层次中的适当细节作抽象的手段。</li>
<li><strong>数据抽象屏障是控制复杂性的强有力工具。</strong></li>
<li>数据导向和消息传递：消息传递设计的特点是将数据对象设想为一个实体（与面向对象的程序设计中的类class相似）</li>
<li><strong>在大型系统中,处理好一大批相互有关的类型而同时又能保持模块性,这是非常困难的问题。</strong>（面向对象语言中的类与其相关的继承概念被用来描述不同类型的对象之间的关系，被用来建立抽象、代码重用和模块化设计。但正是这种对类型之间通用性的处理带来了面向对象语言的大部分复杂性，错综复杂的各种类之间的关系成为程序员的噩梦。或许，这种问题是无法仅仅通过计算机语言设计的方式合理处理的。）</li>
</ul>
<h3 id="第三章-模块化、对象和状态"><a href="#第三章-模块化、对象和状态" class="headerlink" title="第三章 模块化、对象和状态"></a>第三章 模块化、对象和状态</h3><ul>
<li>(除了抽象的手段外，我们还需要帮助我们构造起模块化的大型系统的策略。)</li>
<li><strong>对象与流</strong>：当我们对现实世界的系统进行模拟时，我们可以采取两种策略：第一种是以对象为中心，将大型系统看作一系列对象，特别重要的时，它们的状态会随着时间而变化；另一种则是将注意力集中在流过系统的信息流上。对象策略的实现需要与时间搏斗，它需要我们抛弃老旧的代换模型，而代之更机械式、理论上更难把握的<strong>环境模型</strong>；而流方式则能够用于<strong>松懈</strong>我们的模型中对时间的模拟与计算机求值过程中的各种事件发生的顺序。</li>
<li><strong>局部状态变量和赋值运算符</strong>：由对象组成的系统中，各对象既独立又相互作用，对象的状态是模拟现实世界中&lt;本体&gt;存在的重要概念。（<strong>状态必须是有限的</strong>，且从某种角度来看，对象的同一性问题就和不同年龄的人是否是同一个人的问题一样难以解答。）set!赋值运算的环境模型解释</li>
<li>赋值的利益：从rand过程（实现蒙特卡洛模拟）来看，从一个复杂计算过程中一部分的观点来看，其他部分都在随着时间变化，它们隐藏起自己的随时间变化的内部状态。通过局部状态变量模拟系统的状态，对变量的赋值模拟状态的变化。总结来看，与所有状态都必须显式地操作和传递额外参数的方式相比，通过引进赋值和将状态隐藏在局部变量中的技术，我们能够以一种更模块化的方式构造系统。（蒙特卡洛模拟的收敛效率很低）</li>
<li>赋值的代价：不用任何赋值的程序设计称为<strong>函数式程序设计</strong>。变量所代表的不再是一个简单的名字，而是索引着一个位置，而这个位置所保存的值是可以改变的。<strong>同一和变化</strong>：赋值打破了<strong>引用透明性</strong>，使得同一的问题非常复杂。<strong>命令式程序设计</strong>带来的更困难的问题是它强迫人们去考虑赋值的相对顺序，特别在并发程序中，这个问题会更加得困难。</li>
<li>环境模型：看作一系列frame连接组成的序对表。每个frame看作一系列约束的表格。</li>
<li>用变动数据作模拟：可以大大增加序对的表达能力，使得我们可以构造出序列和树之外的其他数据结构（如队列、二维表和堆）。<strong>共享和相等</strong>：set-car!和set-cdr!可以修改序对所指向的数据对象，这些数据对象可以与其他序对共享，但赋值操作利用共享所带来的危险则是隐晦和难以跟踪。</li>
<li>队列和表格</li>
<li>数字电路模拟器、约束系统</li>
<li>并发性、时间和通信：这里的基本现象是不同进程之间的同步，建立起共享状态，或迫使进程之间通信所产生的事件按照某种特定的顺序进行。从本质上看，在并发控制中，任何时间概念都必然与通信有内在的密切联系。</li>
<li><strong>流</strong>：使用时间函数来描述对象的状态随时间的变化，而函数本身是没有变化的。时间函数可以用一个（可能无穷的）序列去模拟。流，可以被看作一个序列，但不能简单用表来实现，我们需要引进延时求值的技术。流是一种非常巧妙的想法，使我们可能利用各种序列操作，但又不会带来序列作为表去操作而引起的代价。因为流的构造和使用能够交替进行，而这种交错又是完全透明的。作为一种数据抽象，流和表完全一样，它们的不同点就在于元素的求值时间。对于常规的表，其car和cdr都是在构造时求值；而对于流，其cdr则是在选取的时候才去求值。（延时求值的技术也被现代编程语言所采用，如python）。流的实现需要cons的特殊形式，这种特殊形式与常规过程不同，它不会立即求出所有参数的值。</li>
<li>无穷流，隐式地定义流：流计算模式可以方便地解决数列、级数等问题。同时可以系统地将迭代操作过程表示为流过程。（累加型迭代就是根据初始猜测值不断迭代获得下一个猜测值，直到猜测值足够好，这个过程完全可以通过流才实现，而不使用赋值或者局部变量。）（相同的问题如果不采用流过程则难以解决，例如对无穷数列和无穷级数的操作。另外，在使用表作为通用接口时，表的传输和构造需要大量的空间，特别是当表非常大时，程序的计算效率也会大大降低，而使用流则可以根据需要生成数据，而不是一次性得到所有数据。）</li>
<li>我们可以用一个<strong>序列加速器</strong>对流做一个变换，这种加速器可以将一个逼近序列变换为另一个新序列，该新序列也收敛到与原序列同样的值，只是收敛速度更快。<strong>如果不使用流，我们也可以实现这些加速技术，但流的描述方式特别优美和方便，因为整个状态序列就像一个数据结构一样，可以通过一集统一的操作直接地随意使用。</strong></li>
<li>将流作为信号，可以方便地开发信号处理系统。</li>
<li>函数式程序的模块化和对象的模块化：流模型可以提供等价的模块化，同时也不必使用赋值。流实现了一个具有良好定义的数学函数，其行为根本不会变化，但用户看到的却是在这里与一个改变着的状态交互。<strong>正是由于用户方的时态的存在，为这个系统赋予了状态特性。</strong>（<strong>但是，函数式程序在处理非确定性时有着本质的困难，而非确定性在处理并发方面是本质的。</strong>）</li>
<li>我们将这一世界模拟为一集相互分离的、受时间约束的、具有状态的相互交流的对象，或者可以将它模拟为单一的、无时间也无状态的统一体。每种观点都有强有力的优势，但就其自身而言，又没有一种方式能够完全令人满意。我们还在等待一个大统一的出现。</li>
<li>对象模型对世界的近似在于将其分割为独立的片段，函数式模型则不是沿着对象间的边界去做模块化。当“对象”间不共享的状态远远大于它们所共享的状态时，对象模型就特别好用。</li>
</ul>
<h3 id="第四章-元语言抽象"><a href="#第四章-元语言抽象" class="headerlink" title="第四章 元语言抽象"></a>第四章 元语言抽象</h3><ul>
<li><strong>建立新语言是在工程设计中控制复杂性的一种威力强大的策略</strong>，我们常常能通过采用一种新语言而提升处理复杂问题的能力，因为新语言可能使我们以一种完全不同的方式，利用不同的原语，不同的组合方式和抽象方式去描述所面对的问题，而这些都是为了手头的问题而专门打造的。</li>
<li><strong>求值器的作用：</strong>求值器的工作并不是去描述语言的基本过程，而是提供一套连接方式，提供一些组合手段和抽象手段，借助于它们将基本过程联系起来，形成一个语言：<ul>
<li>帮助我们处理嵌套表达式</li>
<li>使我们可以使用变量</li>
<li>使我们可以定义复合过程、</li>
<li>提供一些特殊形式，它们的求值方式与普通过程调用不同</li>
</ul>
</li>
<li>我们把求值器看作是一部非常特殊的机器，它要求以一部机器的描述作为输入。给定了一个输入后，求值器就能够规划自己的行为，模拟被描述机器的执行过程。<strong>按照这一观点，我们的求值器可看作一种通用机器。</strong>（<strong>这其中反映了可计算性的概念，即任一个求值器都可以模拟其他的求值器，或者说只要一个求值器是图灵机等价的，它就可以作为通用机。</strong>）求值器本身可以很简单，但却可以模拟比自身还要复杂的各种程序。<strong>用户程序被看作是求值器的数据。</strong></li>
<li><strong>图灵停机定理</strong>：给定一任意的图灵机程序P和一组任意的输入数据I，不存在单个的图灵机程序，它在有限多步后停机，并告诉我们P是否结束输入数据I的处理。</li>
<li><strong>惰性求值</strong>: 如果在某个参数还没有完成求值之前就进入一个过程的体,我们就说这一过程相对于该参数是<strong>非严格</strong>的；如果在进入某个人过程体之前某个参数已经完成求值，我们就说该过程相对于这个参数是<strong>严格</strong>的。</li>
<li>将流作为惰性表：利用惰性求值，表和流就完全一样了，所以也就需要任何特殊形式了，也不需要区分表操作或者流操作。将cons实现为非严格的过程即可。</li>
<li><strong>非确定计算</strong>：非确定求值器支持一种假象：时间是有分支的，而我们的程序里保存着所有可能的不同执行历史。在遇到一个死胡同时，我们总可以回到以前的某个选择点，并沿着另一个分支继续下去。实现非确定程序设计的amb思想是John McCarthy在1961年第一次提出的。（这是一种将自动搜索策略结合进程序设计的方式。）</li>
<li>逻辑谜题、自然语言分析</li>
<li><strong>逻辑程序设计</strong>：将逻辑直接作为程序设计语言并将计算作为受控推理的一种程序设计技术。对于传统的程序设计来说，算法的逻辑意义往往被程序复杂的控制成分所掩盖，使程序的正确性难以得到证明。科瓦尔斯基对传统的算法或对用通常高级语言编写的程序提出了一个著名的分析公式，即算法&#x3D;逻辑+控制。其基本思想是要从根本上改变程序设计的方法：用户只需要编写程序的逻辑部分（逻辑程序设计之名由此而来），而系统中的解释程序则实施控制部分的职能。（参看Prolog语言）</li>
</ul>
<h3 id="第五章-寄存器机器里的计算"><a href="#第五章-寄存器机器里的计算" class="headerlink" title="第五章 寄存器机器里的计算"></a>第五章 寄存器机器里的计算</h3>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu Core and Snap Architecture Analysis</title>
    <url>/2024/12/22/Ubuntu-Core-and-Snap-Architecture-Analysis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://cn.ubuntu.com/internet-of-things/core">Ubuntu Core</a> 是一个以应用为中心的嵌入式操作系统，所有组件均以 <code>snap</code>容器化封装，空间占用小、安全加固并可以组合的系统镜像，另外所有 App 支持原子化的 OTA 更新（即如果更新失败可以自动回滚）。</p>
<span id="more"></span>

<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>整体架构如下图所示：</p>
<p><img src="/2024/12/22/Ubuntu-Core-and-Snap-Architecture-Analysis/ubuntu_core.png"></p>
<blockquote>
<p>图片来源：<a href="https://assets.ubuntu.com/v1/b2c770ea-Ubuntu+Core20+Datasheet.pdf">Ubuntu Core 手册</a></p>
</blockquote>
<p>图片中的组件可以重用组合成定制的 Ubuntu Core 镜像。</p>
<ul>
<li>Kernel snap: 内核及其关联的模块、固件和设备树文件。</li>
<li>Core snap: 标准的或者定制的 Ubuntu 根文件系统。</li>
<li>Gadget snap: 已经容器化的硬件相关的启动资产和配置文件。</li>
<li>System snaps：</li>
<li>Application snaps:</li>
<li>Snapd: 系统监护服务，该服务公开了便于进行设备管理的 REST API。</li>
</ul>
<h2 id="Snap"><a href="#Snap" class="headerlink" title="Snap"></a>Snap</h2><p><a href="https://snapcraft.io/docs">Snap</a> 是 Linux 系统软件包格式（其他格式有 debian、rpm等），可以被用于桌面、云和 IoT 多种场景。Snap 是自包含的（比如依赖的共享库等）、易安装、安全、跨平台和免依赖的。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在使用 <code>snap</code> 命令之前需要安装并启动<code>snapd</code>，Ubuntu 系统默认已经安装。</p>
<p><code>snap</code> 命令可以用来做一些通用的软件包管理操作，具体用法参考 <code>man snap</code>。其中每个 Snap 都有若干个和发布相关的<strong>频道（Channels）</strong>，用户可以选择从不同的频道安装（不同版本或者相同版本）snap，比如<code>latest/beta</code>，用于测试或者漏洞分析等。</p>
<h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><p>接口（<em>interface</em>）用于对 Snap 进行隔离限制，包括 Snap 应该做什么，不应该做什么，更重要的是对外部资源（如网络、文件系统、声卡等）进行访问控制。Snap 可以请求某个接口，也可以提供某个接口，因此接口实际上也描述了系统中 Snap 之间的依赖关系和数据交互方式。<br>从另一方面说，Snap <strong>只能</strong>通过系统或者其他 Snap 提供的<em>接口</em>来访问相应的资源。</p>
<p>每个接口定义了插口(plug)和插槽(Slot) 的连接关系，每一个 Slot 可以多个 plug，Slot 可以看作资源的提供者，对应地，Plug 则可以被将看作资源的消费者。Plug 和 Slot 只有当它们有着相同的接口名时才能被连接。<br><img src="/2024/12/22/Ubuntu-Core-and-Snap-Architecture-Analysis/snap_interface.png"></p>
<p>使用命令 <code>snap connections &lt;snap-name&gt;</code> 可以查看该 Snap 正在使用的接口，以及哪些接口的 Plug 和 Slot 已经连接，哪些没有连接。</p>
<p>连接可以在安装 Snap 时自动建立，也可以使用命令 <code>snap connect &lt;snap&gt;:&lt;plug interface&gt; [&lt;snap&gt;:&lt;slot interface&gt;]</code> 手动建立，由 Snap 的具体功能决定。相应地，可以使用 <code>snap disconnect &lt;snap&gt;:&lt;plug interface&gt;</code> 来移除连接。</p>
<p>用户可以使用 <code>snap interface &lt;interface-name&gt;</code> 查看哪些 Snaps 在使用指定的接口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">snap interface home</span>  </span><br><span class="line">name:          home</span><br><span class="line">summary:       allows access to non-hidden files in the home directory</span><br><span class="line">documentation: https://snapcraft.io/docs/home-interface</span><br><span class="line">plugs:</span><br><span class="line">  - firefox</span><br><span class="line">  - vlc</span><br><span class="line">slots:</span><br><span class="line">  - snapd</span><br></pre></td></tr></table></figure>

<h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3><p>大多数 Snap 的受限模式都是严格的（<em>strict</em>）。这将 Snap 的执行环境和数据与系统隔离开来，一个需要用户访问文件的受限 Snap 很可能会使用 <em>Home Interface</em> 来弥合这种限制差距，允许 Snap 自动从主目录保存和加载文件。</p>
<p>每个 Snap 的数据可以以Snap 的形式保存，数据实际上可以被看作是 Snap 的状态。因此，我们可以通过Snap （snapshot）来备份、回滚 Snap 的状态。<br>每一个 Snap 被移除的时候可以自动生成Snap ，也可以使用 <code>snap save &lt;snap-name&gt;</code> 命令手动生成。回滚时使用 <code>snap restore &lt;#n&gt;</code>命令，最后一个参数为Snap 编号。</p>
<p>其中一种数据是 Snap 的配置数据，这些配置数据可以使用 <code>snap get &lt;snap-name&gt; [option]</code> 来读取；对应地，可以使用<code>snap set &lt;snap-name&gt; &lt;option&gt; &lt;value&gt;</code><br>特别的，对于 <code>system</code> snap 配置选项和系统相关，其中一部分会影响 <code>Snapd</code> 的行为。示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snap get system system</span></span><br><span class="line">Key              Value</span><br><span class="line">system.hostname  mimose-MDG-XX</span><br><span class="line">system.network   &#123;...&#125;</span><br><span class="line">system.timezone  UTC</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多信息参考 <a href="https://snapcraft.io/docs/data-locations">Data locations</a> </p>
</blockquote>
<h3 id="配额-quotas"><a href="#配额-quotas" class="headerlink" title="配额 (quotas)"></a>配额 (quotas)</h3><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Snap 被限制在一个安全沙箱中，无法访问 Snap 之外的系统资源。安全策略和存储策略协同工作，使开发人员能够快速更新他们的应用程序，并为最终用户提供安全保障。 </p>
<p>Snap 运行时，要完成下面的步骤（其中和内核安全机制，如 <code>seccomp</code>、<code>AppArmor</code> 紧密相关）：</p>
<ol>
<li><p>设置各种环境变量：</p>
<ul>
<li><code>HOME</code>：将所有命令设置为SNAP_USER_DATA</li>
<li><code>SNAP</code>：只读安装目录</li>
<li><code>SNAP_ARCH</code>：设备的架构（例如amd64、arm64、armhf、i386等）</li>
<li><code>SNAP_DATA</code>：Snap 特定版本的可写区域</li>
<li><code>SNAP_COMMON</code>：Snap 所有版本中通用的可写区域</li>
<li><code>SNAP_LIBRARY_PATH</code>：应添加到LD_LIBRARY_PATH的其他目录</li>
<li><code>SNAP_NAME</code>：Snap 名称</li>
<li><code>SNAP_INSTANCE_NAME</code>：Snap 实例名称，包括实例密钥（如果已设置）（Snap 2.36+）</li>
<li><code>SNAP_INSTANCE_KEY</code>：实例密钥（如果有）（Snap 2.36+）</li>
<li><code>SNAP_REVISION</code>：存储Snap 的修订</li>
<li><code>SNAP_USER_DATA</code>:特定Snap 版本的每个用户可写区域</li>
<li><code>SNAP_USER_COMMON</code>：所有Snap 版本中通用的每个用户可写区域</li>
<li><code>SNAP_VERSION</code>：Snap 版本（来自SNAP.yaml）</li>
</ul>
</li>
<li><p>当硬件分配给 Snap 时，将使用默认设备（例如<code>/dev/null</code>、<code>/dev/urandom</code>等）和分配给此 Snap 的任何设备设置 <code>cgroup</code> 设备组。硬件被分配了接口连接。</p>
</li>
<li><p>设置一个在 Snap 中的所有命令之间共享的私有挂载命名空间。</p>
</li>
<li><p>使用 <code>per-snap</code> 私有挂载命名空间设置私有 <code>/tmp</code> 目录，并在<code>/tmp</code>上装载 <code>per-snap</code> 目录。</p>
</li>
<li><p>为每个命令设置一个新的 devpts 实例。</p>
</li>
<li><p>为命令设置<code>seccomp</code>过滤器。</p>
</li>
<li><p>在命令特定的<code>AppArmor</code>配置文件下，以默认的<code>nice</code>值执行命令。</p>
</li>
</ol>
<p>安装 Snap 后，会检查其元数据，并将其与传统权限一起用于导出<code>AppArmor</code>配置文件、<code>Seccomp</code>过滤器和 <code>cgroup</code> 规则。这种组合提供了强大的应用程序限制和隔离。</p>
<h4 id="AppArmor、Seccomp-和设备权限"><a href="#AppArmor、Seccomp-和设备权限" class="headerlink" title="AppArmor、Seccomp 和设备权限"></a>AppArmor、Seccomp 和设备权限</h4><ul>
<li><p><strong>Apparmor</strong></p>
<p>  为每个命令生成<code>AppArmor</code>配置文件。这些具有适当的安全标签和特定于命令的<code>AppArmor</code>规则，用于协调文件访问、应用程序执行、Linux功能、挂载、ptrace、IPC、信号、粗粒度网络。</p>
<p>  如前所述，每个命令都在特定于应用程序的默认策略下运行，该策略可以通过声明的接口进行扩展，这些接口在元数据中表示为 Plug 和 Slot。Strict 模式 Snap 中违反<code>AppArmor</code>策略的行为将被拒绝访问，并且通常将<code>errno</code>设置为<code>EACCES</code>。违规行为通常会被记录下来。</p>
</li>
<li><p><strong>Seccomp</strong></p>
<p>  为 Snap 中要运行的每个命令生成一个<code>seccomp</code>过滤器，启用<code>allowlist</code>系统调用过滤，然后可以通过元数据中表示为 Plug 和 Slot 的声明接口进行扩展。</p>
<p>  违反<code>seccomp</code>策略的进程将被拒绝访问系统调用，<code>errno</code>设置为<code>EPERM</code>（2.32之前的 Snap 版本接收<code>SIGSYS</code>），并记录违规行为。</p>
</li>
<li><p><strong>设备 Cgroup</strong></p>
<p>  为每个标记设备的命令生成<code>udev</code>规则，以便可以将它们添加&#x2F;删除到命令的设备<code>cgroup</code>中。但是，默认情况下，不会标记任何设备，也不会使用设备<code>cgroup</code>，而是使用<code>AppArmor</code>来协调访问。</p>
<p>  根据<code>snapd</code>的决定，当声明依赖接口时，除了<code>AppArmor</code>外，还可以使用设备<code>cgroup</code>，如元数据中的 Plug 和 Slot 所示。</p>
<p>  访问不在 Snap 特定 <code>cgroup</code> 中的设备的进程将被拒绝访问，<code>errno</code>设置为<code>EPERM</code>。访问违规不会被记录。</p>
</li>
<li><p><strong>传统权限</strong></p>
<p>  传统的文件权限（所有者、组、文件ACL等）也通过 Snap 强制执行。 尝试访问传统文件权限不允许的资源的进程将被拒绝访问，<code>errno</code>通常设置为<code>EACCES</code>（有关详细信息，请参阅操作手册页）。访问违规不会被记录。</p>
</li>
</ul>
<p>因此，所有 Snap 都在默认安全策略下运行，<strong>该策略可以通过使用 <em>接口(interface)</em> 进行扩展</strong>，还句话说，当进行接口连接时，安全策略可以进行传递或者说扩展。</p>
<h3 id="限制-Confinement"><a href="#限制-Confinement" class="headerlink" title="限制 (Confinement)"></a>限制 (Confinement)</h3><p>Snap 限制决定了应用程序对系统资源（如文件、网络、外围设备和服务）的访问量。有几个级别的限制。</p>
<p>限制确保单个软件不会影响用户系统的健壮性，也不会导致其他应用程序出现问题。因此，当用户运行 Snap 时，它提供的软件在一定程度上与系统隔离，默认情况下限制了对严格最低功能的访问。</p>
<p>Snap 的限制级别控制其与用户系统的隔离程度。应用程序开发人员或打包人员可以调整限制级别，以广义地指定应用程序在正常使用或开发过程中需要多少对系统资源的访问权限。</p>
<p>已发布 Snap 有两个级别的 Snap 限制：</p>
<ul>
<li><strong>Strict</strong>：被大多数 Snap 使用。Strict 限制的 Snap 在完全隔离的情况下运行，最高可达被认为始终安全的最低访问级别。因此，Strict 限制的 Snap 无法访问文件、网络、进程或任何其他系统资源，除非通过接口请求特定的访问权限（见下文）。</li>
<li><strong>Classic</strong>：允许以与传统软件包几乎相同的方式访问系统资源。为了防止滥用，发布 Classic Snap 需要手动批准，安装需要<code>--Classic</code>命令行参数。</li>
</ul>
<p>在开发过程中，另一种模式很有用：</p>
<ul>
<li><strong>Devmode</strong>：为 Snap 创建者和开发人员提供的特殊模式。<code>devmode</code> Snap 作为严格受限的 Snap 运行，具有对系统资源的完全访问权限，并产生调试输出以识别未指定的接口。安装需要<code>--devmode</code>命令行参数。<code>Devmode</code> Snap 无法发布到 <code>stable</code> 频道，不会出现在搜索结果中，也不会自动更新。</li>
</ul>
<p>Strict 限制的 Snap 会使用Linux内核的安全功能，包括<code>AppArmor</code>、<code>seccomp</code>和命名空间，以防止应用程序和服务访问更广泛的系统。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Snap 的一部分问题源于中心化和不透明的 App Store，与开源精神不符而受到质疑和批评，（可以参考<a href="https://cloud.tencent.com/developer/article/2017496">为什么Ubuntu的Snap是不受欢迎的</a>）。另外其在性能上的问题也遭到批评，参考 Snap 官方对性能的描述：<a href="https://snapcraft.io/docs/snap-performance">Snap performance</a>。</p>
<h2 id="SquashFS-文件系统"><a href="#SquashFS-文件系统" class="headerlink" title="SquashFS 文件系统"></a>SquashFS 文件系统</h2><p><a href="https://www.kernel.org/doc/Documentation/filesystems/squashfs.txt">SquashFS</a> 是一个标准 Linux 文件系统，它将整个目录结构打包到单个压缩文件中。它经常被用于在 USB 设备上提供可引导的原生 Linux 环境，当然也可以用到打包 Snap。</p>
<p>Snap 是一个 SquashFS 文件，其中包含 Snap 的库和二进制环境，以及描述其访问和功能的元数据。SquashFS 文件要么在首次安装 Snap 时由 <code>systemd</code>挂载，要么在已经安装 Snap 的系统（如Ubuntu Core）启动的早期阶段挂载。</p>
<p>SquashFS 解压缩发生在 Snap 首次在系统上运行并且其性能受到密切监视时。特别是，解压缩性能可能因使用的压缩算法、SquashFS 存档的大小、它包含的文件数量、它是第一次被访问（冷缓存）还是再次被访问（热缓存）而有所不同。</p>
<h2 id="安全-1"><a href="#安全-1" class="headerlink" title="安全"></a>安全</h2><h3 id="安全特性"><a href="#安全特性" class="headerlink" title="安全特性"></a>安全特性</h3><p><strong>a. 容器化带来的安全性</strong></p>
<p>Snaps 是不可修改的，默认遵循“最小化特权”原则，这使得构建防篡改设备非常容易。Snaps 之间的通信和交互和传统的应用非常不同，抽象地说，Snaps 构建了一个基于事务的系统。</p>
<p><strong>b. 安全启动</strong><br><img src="/2024/12/22/Ubuntu-Core-and-Snap-Architecture-Analysis/secure_boot.png"></p>
<p><strong>c. 全盘加密</strong></p>
<p><strong>d. 基于内核安全机制的限制</strong></p>
<h3 id="第三方安全分析"><a href="#第三方安全分析" class="headerlink" title="第三方安全分析"></a>第三方安全分析</h3><h2 id="实践：Ubuntu-Core镜像制作"><a href="#实践：Ubuntu-Core镜像制作" class="headerlink" title="实践：Ubuntu Core镜像制作"></a>实践：Ubuntu Core镜像制作</h2><h3 id="注册-Ubuntu-One-账号"><a href="#注册-Ubuntu-One-账号" class="headerlink" title="注册 Ubuntu One 账号"></a>注册 Ubuntu One 账号</h3><p>注册 Ubuntu One 账号，最重要的是使用 Ubuntu 的平台（<a href="https://snapcraft.io/snaps">snapcraft.io</a>）进行 Snap 包的在线生命周期管理，包括包的发布、更新、回退和卸载等。<br>如下图所示，可以看到当前账号所管理的 snaps：<br><img src="/2024/12/22/Ubuntu-Core-and-Snap-Architecture-Analysis/snapcraft.png"></p>
<p>为了保证构建的 Ubuntu Core 镜像以及 snap包的合法性，还需要生成 snapcraft 证书，持有该证书的用户才能对 snap 包拥有限制的权限。创建证书时会要求输入 Ubuntu One 的账户和口令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snap install snapcraft --classic</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">snapcraft export-login credentials.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SNAPCRAFT_STORE_CREDENTIALS=$(<span class="built_in">cat</span> credentials.txt)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取相关信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">snapcraft <span class="built_in">whoami</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><p>制作定制 Ubuntu Core 镜像的核心是编写<em>模型断言（model assertion）</em>。一个 <em>assertion</em> 可以看作是一个被签名的 JSON 的文本，该文本描述了组成镜像的各个组件。模型包括的信息如下：</p>
<ul>
<li>身份 ID 信息。</li>
<li>组成设备系统的基础 snaps (<em>essential snap</em>)。</li>
<li>为了实现设备的功能强制要求或者可选的 snaps。</li>
</ul>
<p>为了快速创建模型，可以直接从 <a href="https://github.com/snapcore/models">snapcore</a> github 仓库下载对应设备的参考模型文件。以 <em>raspberry pi</em> 平台为例：<br><code>$ wget -O my-model.json https://raw.githubusercontent.com/snapcore/models/master/ubuntu-core-24-pi-arm64.json</code></p>
<p>编辑 my-model.json, 修改<code>authority-id</code> 和 <code>brand-id</code> 为自己的开发者 ID（<em>developer ID</em>），该 ID 可以在命令中<code>snapcraft whoami</code> 获取到。这样做在逻辑上将该镜像与自己的 Ubuntu One 账号绑定，也就是只有开发者自己可以 push 镜像。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;authority-id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XXXXXXXXXXXX&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;brand-id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XXXXXXXXXXXX&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p><code>snaps</code> 描述了构建系统需要的基础 snaps（<code>kernel</code>，<code>core</code>等） 和 应用 snaps（<code>console-conf</code>），参考架构图。</p>
<h3 id="对模型进行签名"><a href="#对模型进行签名" class="headerlink" title="对模型进行签名"></a>对模型进行签名</h3><p>首先确认是否已经有密钥对关联到开发者的账号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">snapcraft list-keys</span></span><br><span class="line">No keys have been registered. See &#x27;snapcraft register-key --help&#x27; to register a key.</span><br></pre></td></tr></table></figure>

<p>如果没有的话，新建一个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">snapcraft create-key my-model-key</span></span><br></pre></td></tr></table></figure>

<p>然后注册 key:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">snapcraft register-key my-model-key</span></span><br><span class="line">...</span><br><span class="line">Registering key ...</span><br><span class="line">Done. The key &quot;my-model-key&quot; (&lt;key fingerprint&gt;) may be used to sign your assertions.</span><br></pre></td></tr></table></figure>

<p>重新查看 key 状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">snapcraft list-keys</span></span><br><span class="line">The following keys are available on this system:</span><br><span class="line">    Name          SHA3-384 fingerprint</span><br><span class="line">*   my-model-key  gX8JXpNUvUsAfS4IwNoxQVLeHzHqoI_ktGKdX-WRw9VlCEcTI6HNfgWdbdjvRFKm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后对 JSON 文件进行签名生成 <em>模型断言</em>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">snap sign -k my-model-key my-model.json &gt; my-model.model</span></span><br></pre></td></tr></table></figure>

<h3 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h3><p>安装 <code>ubuntu-image</code> 工具:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">snap install ubuntu-image --classic</span></span><br></pre></td></tr></table></figure>

<p>然后使用 <code>ubuntu-image</code> 构建镜像，并使用上一节生成的<em>模型断言</em>作为参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ubuntu-image snap my-model.model</span></span><br><span class="line">......</span><br><span class="line">[1] load_gadget_yaml</span><br><span class="line">[2] set_artifact_names</span><br><span class="line">[3] populate_rootfs_contents</span><br><span class="line">[4] generate_disk_info</span><br><span class="line">[5] calculate_rootfs_size</span><br><span class="line">[6] populate_bootfs_contents</span><br><span class="line">[7] populate_prepare_partitions</span><br><span class="line">[8] make_disk</span><br><span class="line">[9] generate_snap_manifest</span><br><span class="line">Build successful</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="引导镜像"><a href="#引导镜像" class="headerlink" title="引导镜像"></a>引导镜像</h3><blockquote>
<p>参考 <a href="https://ubuntu.com/core/docs/testing-with-qemu">Test Ubuntu Core with QEMU</a></p>
</blockquote>
<p>通过<code>qemu</code> 创建 Ubuntu Core 虚拟机，并进入系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-x86_64 \</span></span><br><span class="line"><span class="language-bash"> -enable-kvm \</span></span><br><span class="line"><span class="language-bash"> -smp 1 \</span></span><br><span class="line"><span class="language-bash"> -m 2048 \</span></span><br><span class="line"><span class="language-bash"> -machine q35 \</span></span><br><span class="line"><span class="language-bash"> -cpu host \</span></span><br><span class="line"><span class="language-bash"> -global ICH9-LPC.disable_s3=1 \</span></span><br><span class="line"><span class="language-bash"> -net nic,model=virtio \</span></span><br><span class="line"><span class="language-bash"> -net user,hostfwd=tcp::8022-:22 \</span></span><br><span class="line"><span class="language-bash"> -drive file=OVMF_CODE_4M.secboot.fd,<span class="keyword">if</span>=pflash,format=raw,unit=0,<span class="built_in">readonly</span>=on \</span></span><br><span class="line"><span class="language-bash"> -drive file=OVMF_VARS_4M.ms.fd,<span class="keyword">if</span>=pflash,format=raw,unit=1 \</span></span><br><span class="line"><span class="language-bash"> -drive <span class="string">&quot;file=pc.img&quot;</span>,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=disk1 \</span></span><br><span class="line"><span class="language-bash"> -device virtio-blk-pci,drive=disk1,bootindex=1 \</span></span><br><span class="line"><span class="language-bash"> -serial mon:stdio</span></span><br></pre></td></tr></table></figure>

<p>引导过程中会弹出窗口，用户可以在窗口内进行相关配置。</p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>使用 SSH 登陆 Ubuntu Core，但 OpenSSH Server 服务器端不要求一个口令(Password)，而是被配置成需要使用 SSH 公钥进行认证，该 SSH 公钥和 Ubuntu One 账户是绑定关系。</p>
<p>配置 SSH key 可以参考<a href="https://ubuntu.com/core/docs/testing-with-qemu">Test Ubuntu Core with QEMU</a>。</p>
<p>使用下面的命令登陆：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -i &lt;path-to-private-key&gt; &lt;sso-username&gt;@localhost -p 8022</span></span><br></pre></td></tr></table></figure>

<p>其中 <em>sso-username</em> 和 Ubutnu One 账户关联。</p>
]]></content>
      <categories>
        <category>嵌入式系统和IOT</category>
      </categories>
  </entry>
  <entry>
    <title>Unix编程艺术笔记</title>
    <url>/2022/04/12/Unix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第1章-Unix-哲学"><a href="#第1章-Unix-哲学" class="headerlink" title="第1章 Unix 哲学"></a>第1章 Unix 哲学</h3><h4 id="emsp-emsp-K-I-S-S-Keep-It-Simple-Stupid"><a href="#emsp-emsp-K-I-S-S-Keep-It-Simple-Stupid" class="headerlink" title="&emsp;&emsp; K.I.S.S Keep It Simple, Stupid!"></a>&emsp;&emsp; <code>K.I.S.S</code> <code>Keep It Simple, Stupid!</code></h4><p>&emsp;&emsp;一个程序只做好一件事，并做好。程序要能够协作，要能够处理文本流，因为这是最通用的接口。<br>&emsp;&emsp; <em><code>不懂Unix的人最终还要发明一个蹩脚的Unix。</code></em></p>
<span id="more"></span>

<p>&emsp;&emsp; <strong>Robe Pike的表述:</strong></p>
<ul>
<li>a. 你无法断定程序会在什么地方耗费运行时间。（不要过早优化！）</li>
<li>b. 估量。在对代码没有进行估量前，不要优化速度。</li>
<li>c. 花哨的算法在n很小时通常很慢，而n通常很小。花哨算法的的常数复杂度通常很大。除非你确定n总是很大，否则不要用花哨的算法（即使n很大，也优先考虑原则b）。</li>
<li>d. 花哨的算法比简单算法更容易出bug、更难实现。尽量使用<strong>简单的数据算法配合简单的数据结构</strong>。（这个原则突出表现了Unix哲学传统追求实用、实效的特点，这也决定了它不可能诞生于那些‘过于理论的’‘学者’之手。）*<code>（Ken Thomson: 拿不准就穷举。）</code>*</li>
<li>e.数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得仅仅有条，正确的算法也就不言自明。<strong>编程的核心是数据结构，而不是算法。</strong>（SICP：一种数据结构和操作它的一百种方法要比10种数据结构，每种都有10种操作方法更简单。复杂的数据数据弥漫在各种流行的编程语言中。）</li>
</ul>
<p>&emsp;&emsp; <strong>总结：</strong></p>
<ul>
<li><strong>a.模块原则</strong>：使用简单的接口拼合简单的部件。(Fred Brooks: 没有万能药。)</li>
<li><strong>b.清晰原则</strong>：清晰胜于机巧。（很多人重机巧来‘炫耀’自己；一些公司管理拙劣，研发的系统过分追求机巧，可维护性极差，还没有自知之明。）……为了取得程序一丁点的性能提升就大幅度增加技术的复杂度和晦涩性。</li>
<li><strong>c.组合原则</strong>：设计时考虑拼接组合。（既联结又独立）要想让程序具有组合性，就要使程序彼此独立。</li>
<li><strong>d.分离原则</strong>：策略同机制分离，接口同引擎分离。</li>
<li><strong>e.简洁原则</strong>：设计要简洁，复杂度能低就低。技术上的虚荣心理：程序员都很聪明，常常以能玩转复杂东西和卖弄抽象概念的能力为傲，这一点也无可厚非。（但程序员和一些科学家都‘嫉妒’数学家，因为没有什么人可以比数学家更能‘摆弄’抽象概念。）更为常见的是商业环境下的要求使得软件的复杂度上升。要避免这些陷阱，唯一的方法就是鼓励另一种软件文化，以简洁为美。</li>
<li><strong>f.吝啬原则</strong>：除非别无它法，不要编写庞大的程序。（Windows平台的软件都以‘庞大’自居自傲！）</li>
<li><strong>g.透明性原则</strong>：设计要可见，以便审查和调试。软件系统的透明性是指你一眼就能看出软件是做什么的以及怎么做的。显见性是指程序带有监视和显示内部状态的功能，这样程序不仅能够运行良好，而且能够看得出它以何种方式运行。</li>
<li><strong>h.健壮性原则</strong>：健壮源于透明和简洁。在有异常输入的情况下，保证软件健壮的一个相当重要的策略就是避免在代码中出现特例。bug通常隐藏在处理特例的代码以及处理不同特殊情况的交互操作部分的代码中。</li>
<li><strong>i.表示原则</strong>：把知识叠入数据以求逻辑质朴而健壮。数据要比编程逻辑更容易驾驭。在设计中，你应该主动将代码的复杂度转移到数据之中去。</li>
<li><strong>j.通俗原则</strong>：接口设计避免标新立异。（最少惊奇原则）最易用的程序就是用户需要学习新东西最小的东西——或者，换句话说，最易用的程序就是最切合用户已有知识的程序。（程序和求知的关系，程序如果能够使得用户获得新的知识或者对已有知识产生更深刻的理解，那么程序和人的交互就会产生质的变化，程序不在仅仅作为一种解决问题的工具，而是一种认知的方式和媒介。）</li>
<li><strong>k.缄默原则</strong>：如果一个程序没什么好说的，就保持沉默。</li>
<li><strong>l.补救原则</strong>：出现异常时，马上退出并给出足够错误信息。</li>
<li><strong>m.经济原则</strong>：宁花机器一分，不花程序员一秒。</li>
<li><strong>n.生成原则</strong>：避免手工hack, 尽量编写程序去生成程序。</li>
<li><strong>o.优化原则</strong>：雕琢前先得有原型， 跑之前先学会走。”90%的功能现在能够实现，比100%的功能永远实现不了强。”做好原型设计可以帮助你避免为蝇头小利而投入过多的时间。（Donald Knuth: 过早优化是万恶之源。）<strong>先制作原型，再精雕细琢。优化之前先确保能用。</strong>先给你的设计做个未优化的、运行缓慢、很耗内存但是正确的实现，然后进行系统地调整，寻找那些可以铜鼓牺牲最小的局部简洁性而获得较大性能提升的地方。<strong>Ken Thompson: “我最有成效的一天就是扔掉了1000行代码。”</strong></li>
<li><strong>p.多样性原则</strong>：绝不相信“不二法门”的断言。设计一种僵化、封闭、不愿意与外界沟通的软件，简直就是一种病态的傲慢。（这一点还表现在人的性格上！！！）</li>
<li><strong>q.扩展原则</strong>：设计着眼未来，未来总比预想快。绝不要认为自己找到了最终答案。</li>
</ul>
<h3 id="第4章-模块性：保持清晰，保持简单"><a href="#第4章-模块性：保持清晰，保持简单" class="headerlink" title="第4章 模块性：保持清晰，保持简单"></a>第4章 模块性：保持清晰，保持简单</h3><p><strong>1. 紧凑性和正交性：</strong></p>
<ul>
<li>紧凑性：这是一个设计能否装入人脑的特性。有经验的用户需要手册吗？许多软件是相对紧凑或者半紧凑的，即它们有一个紧凑的功能子集，能够满足专家用户80%以上的一般需求。</li>
<li>正交性：任何操作都没有副作用，每一个动作只改变一件事，不会影响其他。无论你控制什么系统，改变每个属性的方法有且只有一个。<strong>重构</strong>：改变代码的组织和结构，而不改变其外在行为。重构的原则性目标就是提高正交性。</li>
<li>STOP原则：不要重复自身。任何一个知识点在系统内都应当有一个唯一、明确和权威的表述。<strong>无论何时，重复代码都是危险信号。</strong></li>
<li>强单一中心：Unix的许多有效工具都是围绕强单一算法直接转换的瘦包装器。<br>&emsp;&emsp;<strong>不要想着多做什么事情，要尽量去想最少能做的事情。</strong></li>
</ul>
<p><strong>2. 层次化：</strong></p>
<ul>
<li>自底向上和自顶向下的结合。</li>
<li>胶合层的作用：顶层的应用逻辑和底层的域原语必须用胶合逻辑层来进行阻抗匹配。<strong>胶合层要尽可能薄。</strong> <strong>完美之道，不在无可增加，而在无可删减。</strong></li>
</ul>
<p><strong>3. 程序库：</strong><br>&emsp;&emsp;Unix编程风格强调模块性和定义良好的API，它所产生的影响之一就是：强烈倾向于将程序分解为由胶合层连接的库集合，特别是共享库。</p>
<p><strong>4.OO面向对象：</strong><br>&emsp;&emsp;OO往往产生过厚的胶合层，OO在GUI、仿真和图形领域取得成功，在于在这些领域很难弄错类型的本体问题。（或者说这些领域中模拟的对象以及对象间的关系与现实世界有着清晰的对应关系。）</p>
<p><strong>5.模块化编码</strong></p>
<p>&emsp;&emsp;Unix 風格程序设计所面临的主要挑战就是如何将分离法的优点（将问题从原始的场景中简化、归纳）同代码和设计的薄胶合、浅平透层次结构的优点相结合。</p>
<p>&emsp;&emsp; (LLVM的设计就是程序库、模块化和及模块、组合原则的应用体现。)</p>
<h3 id="第5章-文本化：好协议产生好实践"><a href="#第5章-文本化：好协议产生好实践" class="headerlink" title="第5章 文本化：好协议产生好实践"></a>第5章 文本化：好协议产生好实践</h3><p>&emsp;&emsp;为了便于数据的传输和存储，像链表这样的数据结构，其可遍历的准空间部署需要平整化或者序列化为字节流表达，以便日后能够从这个表达中恢复数据结构。（我以前没有深入思考过这点，数据结构如何在不同的机器间的移植问题，现代的网络协议是如何做到这点的？）<br>&emsp;&emsp;互用性，透明性，可扩展性和存储&#x2F;事务处理的经济性——这些都是设计文件格式和应用协议时需要考虑的重要方向。<br><strong>数据文件元格式：</strong>（范例：SMTP、POP、IMAP）</p>
<ul>
<li>DSV风格： 使用分隔符分隔值（例如passwd文件使用冒号作为值分隔符）</li>
<li>RFC822风格：如HTTP1.1</li>
<li>Cookie-Jar风格：%%或%作为文本分隔符</li>
<li>Record-Jar风格：</li>
<li>XML</li>
<li>Windows INI</li>
</ul>
<p>** Unix文本文件格式的约定：**</p>
<ul>
<li>1.如果可能，以新行符结束的每一行只存一个记录</li>
<li>2.如果可能，每行不超过80个字符</li>
<li>3.使用#引入注释</li>
<li>4.支持反斜杠约定</li>
<li>5.在每行一条记录的格式中，使用冒号或任何连续的空白作为字段分割符</li>
<li>6.不要过分区分tab和whitespace</li>
<li>7.优先使用十六进制而不是八进制</li>
<li>8.对于复杂的记录，使用节（stanza）格式，一个记录若有多行，就使用%%\n或%\n作为记录分割符</li>
<li>9.在节格式中，要么每行一个记录字段，要么让记录格式和RFC822电子邮件头类似，用冒号终止的字段名关键字作为引导字段</li>
<li>10.在节格式中，支持连续行</li>
<li>11.要么包含一个版本号，要么将格式设计成相互独立的自描述字节块</li>
<li>12.注意浮点取整问题</li>
<li>13.不要仅对文件的一部分压缩或二进制编码</li>
</ul>
<p>&emsp;&emsp;（LLVM IR 的设计体现了该原则的应用。）</p>
<h3 id="第6章-透明性：来点光"><a href="#第6章-透明性：来点光" class="headerlink" title="第6章 透明性：来点光"></a>第6章 透明性：来点光</h3><p>&emsp;&emsp;美在计算机科学中的地位，要比在其他任何技术中的地位都重要。因为软件太复杂了，而美是抵御复杂的终极武器。——《机器美学:优雅和技术本质》</p>
<p>&emsp;&emsp;如果软件所包含的功能是为了帮助用户建立对软件”做什么，怎么做”的心理模型而设计的，这个软件系统就是可显的。…可显性是一种主动品质。</p>
<p>&emsp;&emsp;优雅是力量和简洁的结合。优雅的代码事半功倍;优雅的代码不仅正确，而且显然正确;优雅的代码不仅将算法传递给计算机，同时还将见解和信心传递给阅读代码的人。通过追求优雅的代码，我们可以编写更好的代码。</p>
<p><strong>&emsp;&emsp;为透明性和可显性设计：</strong></p>
<ul>
<li>不要在具体操作的代码上叠放太多的抽象层。</li>
</ul>
<p><strong>&emsp;&emsp;为可维护性而设计</strong></p>
<h3 id="第7章-多道程序设计：分离进程为独立的功能"><a href="#第7章-多道程序设计：分离进程为独立的功能" class="headerlink" title="第7章 多道程序设计：分离进程为独立的功能"></a>第7章 多道程序设计：分离进程为独立的功能</h3><p>&emsp;&emsp; <strong><code>做单件事并做好</code></strong></p>
<ol>
<li><strong>从性能调整中分离复杂度控制</strong><br>&emsp;&emsp;尽量使用协作进程，而不是线程。</li>
<li>IPC分类：</li>
</ol>
<ul>
<li>将任务传给专门程序（shellout）：两者不需要交流</li>
<li>管道、重定向和过滤器</li>
<li>wrapper（包装器）</li>
<li>从进程：需要内部状态机处理两者的通信协议（如scp和ssh）</li>
<li>对等进程间通信：临时文件、信号、套接字、共享内存。<br>&emsp;&emsp; <strong>慎用RPC和线程</strong></li>
</ul>
<h3 id="第8章-微型语言：寻找歌唱的音符"><a href="#第8章-微型语言：寻找歌唱的音符" class="headerlink" title="第8章 微型语言：寻找歌唱的音符"></a>第8章 微型语言：寻找歌唱的音符</h3><p>&emsp;&emsp; <strong><code>专门领域的小语言是非常强大的设计理念。</code><strong>使用微型语言比起采用低级硬编码的设计而言，降低了全局复杂度。首先，微型语言提高了编程问题规格的层次，这种表示法与通用语言所支持的表示法相比，</strong>更加紧凑，更具有表现力</strong>。（和SICP中的<strong>元语言抽象</strong>概念相似）。<br>&emsp;&emsp;分类：</p>
<ul>
<li>数据格式：SNG，passwd，vimrc等</li>
<li>微型语言：m4、yacc、lex、make、xslt、pic、tbl、eqn、awk、troff、script、（dc|bc）等。趋势是从声明性发展到命令性。</li>
<li>解释器：（dc|bc）、Lisp、JS、tcl、shell、Perl、Python、Java</li>
</ul>
<h3 id="第9章-生成：提高规格说明的层次"><a href="#第9章-生成：提高规格说明的层次" class="headerlink" title="第9章 生成：提高规格说明的层次"></a>第9章 生成：提高规格说明的层次</h3><p>&emsp;&emsp;数据比程序更容易理解，不管这些数据是普通表格、<em>说明性标记语言</em>、模板系统还是一组可以扩展为逻辑控制的宏。<strong>尽可能把设计的复杂度由程序代码转移到数据中去。</strong>（说明式标记语言区别于过程性或者命令式语言，它只提供说明式的’做什么‘的知识，而不包含’怎么做‘的知识。）</p>
<ul>
<li><strong>数据驱动编程</strong> ：（注意与SICP中数据导向风格编程的对比，在那里，数据与过程的界限已经很模糊。）与OO相比，这里的数据不仅仅指对象的状态还表示程序的控制流。这里重要的思想其实是将程序逻辑从硬编定的控制结构转移到数据中。*<code>尽量避免手工编码。</code>*</li>
<li><strong>专用代码的生成：</strong>尽量少干活、让数据塑造代码、依靠工具、将机制从策略中分离。<strong>建设性的懒惰是大师级程序员的美德。</strong></li>
</ul>
<h3 id="第10章-配置：迈出正确的第一步"><a href="#第10章-配置：迈出正确的第一步" class="headerlink" title="第10章 配置：迈出正确的第一步"></a>第10章 配置：迈出正确的第一步</h3><p>Unix：<strong>一切都是可配置的。</strong> <strong>但什么是不应该可配置的？</strong></p>
<ul>
<li>a. 能够可靠的进行自动检测的东西，就不要提供配置开关（自动检测可能会稍微增加运行时的延迟，但延迟不超过一定界限就是可以接受的）；</li>
<li>b. 能够用脚本包装器或简单管道实现的任务就不要用配置开关实现。能够简单使用其他程序实现的任务，就不要增加本程序的复杂度。（*<code>不要过度配置</code>*）</li>
</ul>
<p><strong>配置的位置</strong>：对调用时可能发生变化的选项，使用命令和开关；对改动很少但确实应该由各个用户控制的选项，使用用户主目录的运行控制文件；对需要由系统管理员设置而不是由用户改变的整个系统级选项数据，使用整个系统里运行控制文件。</p>
<ul>
<li>特殊情况是坏消息。（特殊情况会破坏程序的简单性和透明性，增加复杂度。）</li>
</ul>
<p><strong>运行控制文件配置的一般通用规则：</strong></p>
<ul>
<li>支持说明性注释</li>
<li>不要区别隐匿的空白符</li>
<li>把多个空行和注释行视为单个空行</li>
<li>词法上把文件视为简单的用空白分隔的标记序列，或多行标记</li>
<li>支持反斜杠语法以在字符串中嵌入不可打印字符或者特殊字符</li>
</ul>
<p><strong>环境变量：</strong>系统环境变量、用户环境变量。在有些情况下，使用用户环境变量是有用的，特别当这些变量由大量不同程序共享，独立于应用程序的优先选项。**</p>
<p><strong>使用环境变量的情况：</strong></p>
<ul>
<li>变量值根据共享点文件或者父进程需要向多个子进程传递信息的上下文环境的不同而变化。</li>
<li>变量值随点文件不同而频繁改变，但每次启动都不变化。</li>
<li>进程唯一的覆盖必须以不要求改变命令行调用的方式来表述。例如LD_LIBRARY_PATH环境变量。</li>
</ul>
<p><strong>命令行选项：</strong></p>
<h3 id="第11章-接口"><a href="#第11章-接口" class="headerlink" title="第11章 接口"></a>第11章 接口</h3><p>&emsp;&emsp;<strong>最小立异原则</strong>：如有可能，尽量允许用户将接口功能委派给熟悉的程序来完成。提倡以共生或委派策略来提高代码的复用并降低软件复杂度。**<code>不能委派就仿效。</code>**<br>&emsp;&emsp; 评估标准：简洁、表现力、易用、透明和脚本化能力。<br>&emsp;&emsp;<strong>Unix接口设计模式:</strong></p>
<ul>
<li>过滤器模式</li>
<li>Cantrip模式：没有输入、没有输出、只被调用一次，产生退出状态数值</li>
<li>源模式：不需要输入、输出在启动条件中控制。如ls、who、ps等。</li>
<li>接收器模式：只接纳标准输入而不发送任何东西到标准输出。</li>
<li>编译器模式：无标准输入、无标准输出，只将错误信息发送到标准错误端。</li>
<li>ed模式：交互设计模式</li>
<li>Roguelike模式：支持全屏幕、可视界面风格、但使用字符界面显示，没有鼠标和图形界面。</li>
<li>引擎与接口分离模式：将程序的引擎部分与接口部分分离。（参考MVC模式，模型-视图-控制器）。这种模式的一种形式是将策略接口（通常是结合了视图和控制器功能的GUI）和包含了一个专用定义域微型语言解释器的引擎相连。（如mysql数据库程序）<ul>
<li>配置者&#x2F;执行者组合</li>
<li>假脱机&#x2F;守护进程组合： Spooler将任务和数据放入spool目录，daemon不断轮询spool目录，如果有任务就执行任务，完成后将其从spool目录中删除。 （如Unix打印程序 lpr&#x2F;lprd）</li>
<li>驱动&#x2F;引擎组合：a)交互性 b)引擎以自身接口单独运行的能力。</li>
<li>CS组合：两者之间的协议可以由开放标准定义（如HTTP、FTP、DNS等）</li>
<li>CLI服务器</li>
</ul>
</li>
<li>基于语言的接口模式</li>
<li>多价程序模式：程序的应用定义域逻辑封存在一个文档化的API库中，该库可以被其他程序链接。程序同外部的接口逻辑是一个基于库的薄胶合层。或者有几个不同风格的UI层，每一个层都可以链接该库。</li>
</ul>
<h3 id="第12章-优化"><a href="#第12章-优化" class="headerlink" title="第12章 优化"></a>第12章 优化</h3><p>&emsp;&emsp; <em><code>过早优化是万恶之源</code></em><br>&emsp;&emsp;程序员工具箱中最强大的优化技术就是不去优化。<br>&emsp;&emsp; <em><code>小就是美</code></em></p>
<h3 id="第13章-复杂度：尽可能简单，但不要简单过了头"><a href="#第13章-复杂度：尽可能简单，但不要简单过了头" class="headerlink" title="第13章 复杂度：尽可能简单，但不要简单过了头"></a>第13章 复杂度：尽可能简单，但不要简单过了头</h3><p>&emsp;&emsp; <strong>代码量、实现复杂度和接口复杂度</strong><br>&emsp;&emsp; <strong>本质的、偶然的和选择复杂度</strong><br>&emsp;&emsp;不要为了简洁而简洁。同其他美学形式一样，我们需要注意何时设计上的简约已经不再是有价值的自律形式，而开始成为一件伪装的苦行者外衣——一种实际上把美德作为接口来敷衍工作的纵容方式。<br>&emsp;&emsp; <strong>框架的重要性：</strong>对共享上下文环境的统一管理，是Emacs的选择复杂度换来的。小巧锐利工具的教义，降低接口复杂度和代码库规模的压力，可能正好导向<strong>手工陷阱</strong>——用户不得不自己维护所有共享的上下文环境。（vi的<strong>专用陷阱</strong>问题）</p>
<h3 id="第14章-C还是非C"><a href="#第14章-C还是非C" class="headerlink" title="第14章 C还是非C"></a>第14章 C还是非C</h3><p>&emsp;&emsp;要有效应用Unix哲学，在工具包中就不能只有Ｃ语言，必须学会使用Ｕnix的其他语言（特别是脚本语言），并且学会如何在大型程序系统中把担任各个专门角色的多个语言轻松地融合在一起。</p>
<h3 id="第15章-工具，开发的战术"><a href="#第15章-工具，开发的战术" class="headerlink" title="第15章 工具，开发的战术"></a>第15章 工具，开发的战术</h3><ul>
<li><strong>操作系统</strong>：IDE对于缺乏工具的单一语言编程非常有意义。然而在Unix下，语言和工具的选择广泛多样。所以同时使用多个代码生成器、定制配置器以及许多其他标准定制工具就是司空见惯的事。Unix提倡一种更灵活的风格，一种以编辑&#x2F;编译&#x2F;调试循环为中心、排它性更少的风格。</li>
<li><strong>编辑器</strong>： <code>vi</code>和<code>Emacs</code></li>
<li><strong>专用代码生成器</strong>：<code>lex</code>和<code>yacc</code></li>
<li><strong>自动化编译</strong>: <code>make</code>工具，尽量不要嵌套使用make，这样会使问题复杂化。</li>
<li><strong>版本控制系统</strong>：</li>
<li><strong>运行期调试</strong>：牢记Unix哲学。将时间花费在设计质量上，而不是低层次的细节上，尽可能自动化一切——包括运行期调试的细节工作。</li>
<li><strong>性能分析</strong>：</li>
<li>使用Emacs整合工具</li>
</ul>
<h3 id="第16章-重用：不要重复发明轮子"><a href="#第16章-重用：不要重复发明轮子" class="headerlink" title="第16章 重用：不要重复发明轮子"></a>第16章 重用：不要重复发明轮子</h3><p>&emsp;&emsp; <code>重用代码</code>是程序员良好的美德。</p>
<p>&emsp;&emsp; <code>透明性</code>是重用的关键。</p>
<p>&emsp;&emsp; <code>开源</code>:设计最好的实践需要情感的投入，而不是冷漠无聊的过程。软件开发者，同任何其他类型的工匠和技师一样：它们想要成为艺术家，这并不是什么私密。<strong>他们不仅仅希望重用代码，也希望自己的代码得到重用。</strong></p>
<h3 id="第17章-可移植性"><a href="#第17章-可移植性" class="headerlink" title="第17章 可移植性"></a>第17章 可移植性</h3><h3 id="第18章-文档-向网络世界阐释代码"><a href="#第18章-文档-向网络世界阐释代码" class="headerlink" title="第18章 文档:向网络世界阐释代码"></a>第18章 文档:向网络世界阐释代码</h3><p>&emsp;&emsp; <code>troff</code>和<code>TEX</code>排版工具; <code>Textinfo</code>、<code>HTML</code>、<code>DocBook</code></p>
<h3 id="第19章-开放源码：在Unix社区中编程"><a href="#第19章-开放源码：在Unix社区中编程" class="headerlink" title="第19章 开放源码：在Unix社区中编程"></a>第19章 开放源码：在Unix社区中编程</h3>]]></content>
      <categories>
        <category>GNU/Linux操作系统</category>
        <category>计算机科学</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《玛雅》读书笔记</title>
    <url>/2021/01/18/%E3%80%8A%E7%8E%9B%E9%9B%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><em>&emsp;&emsp;前段时间重读该书，简短做了一些笔记，但这里只摘抄52则箴言，傅佩荣译本。书中说：（这些）箴言，是两人必须共享的事物。</em><br><em>&emsp;&emsp;玛雅，这个题目代表着全文线索的核心、也是主题的核心。它包含着丰富的多层多方面的含义，每次阅读都可以产生不同的理解，这种美妙的体验只能亲自阅读、亲自思考想象才能获得。</em></p>
<span id="more"></span>

<p><strong>梅花A</strong></p>
<p>&emsp;&emsp;有一个世界存在。以概然性来说，这几乎是不可能的。如果碰巧什么都不存在，那倒更是可想象的。如此以来，至少不会有人总是要问，为何什么都不存在？</p>
<p><strong>梅花2</strong></p>
<p>&emsp;&emsp;由不带偏见的角度看来，这个世界不但不像是个一眼看得透的简单现象，而且还不断地为理性制造压力。如果理性存在的话，意思是，如果有个中立的理性。由内而发的声音在这么说。小丑的声音在这么说。</p>
<p><strong>梅花3</strong></p>
<p>&emsp;&emsp;此时此地，是由两栖类的后裔认真发出这声音。在浓密森林里，陆栖蜥蜴的子侄辈透漏了这声音。那毛皮脊椎动物的后代所提的问题是：这一切，除了源于这颗无所顾忌的卵巢朝着各个方向不停生长之外，还有什么理由可说？</p>
<p><strong>梅花4</strong></p>
<p>&emsp;&emsp;要问的是，存在之物由虚无中产生，这样的机会有多大？或者，当然可以从另一面来问：存在之物自永远即已存在，这样的几率有多少？不管怎么问，都可以接着再问：宇宙万物历经世世代代的睡眠，某日清晨突然揉揉眼睛，醒来觉察自己竟然有了意识，这样的几率可能算得出吗？</p>
<p><strong>梅花5</strong></p>
<p>&emsp;&emsp;如果上帝存在，那么它不但是一位魔术师，留下许多线索让人探寻。最主要的，它还是一位善于隐藏真相的大师。这个世界不是一眼可以看穿的。天体中仍然保存了不少秘密。群星在窃窃私语。不过，没有人忘得了大爆炸。自此以后，寂静负责主宰，那儿的一切也向外扩散开去。你依然可以邂逅一颗卫星，或是一颗彗星。只是不必期待友善的问候。天体中是不印名片的。</p>
<p><strong>梅花6</strong></p>
<p>&emsp;&emsp;在起初，发生了大爆炸，那是很久以前的事。这张牌只是个提醒，要你注意这个傍晚的额外演出。你还来得及抓住一张入场券。简单来说，喝彩之声环绕着这表演本身的观众所展示出来的创作品。不论情况如何，如果没有观众鼓掌，这个事件就没有理由被描述为一场表演。有些座位还空着。</p>
<p><strong>梅花7</strong></p>
<p>&emsp;&emsp;在天体的一排排座位中，到处都是冰块和火焰时，谁又能观赏这出宇宙烟火施放表演？谁又能猜测当第一只大胆的两栖类向着岸边所爬的一小步竟然也是长途旅行中重大的一跃，最后才使得灵长类能够看到他们光荣演化从一开始所取路程的全盘景观。大爆炸发生了一百五十亿年以后，给它的掌声才终于响了起来。</p>
<p><strong>梅花8</strong></p>
<p>&emsp;&emsp;无可否认，创造整个世界，是个值得大加赞赏的成就。不过，更值得尊重的，或许是一个由能力创造自己的整体世界。由此反观可知：这个世界就其只是被创造的经验而言，实在乏善可陈；相形之下，能够从虚幻状态中引发自己的存在，并且完全在自己双脚上站立起来，那才是惊天动地壮举。</p>
<p><strong>梅花9</strong></p>
<p>&emsp;&emsp;小丑感觉自己在成长，他在双手双脚的变化中感觉到了，他觉得他不只是自己想象中的样子了。他感觉他那外表像人的动物的口中，冒出了珐琅质与牙齿。他感觉自己戏袍里的灵长类的肋骨变得轻盈了，他感觉稳定的脉搏不停地跳动，正在把温暖的液体注入他的身体中。</p>
<p><strong>梅花10</strong></p>
<p>&emsp;&emsp;我们不难想象这样的状况，就是：造物主以泥土塑造男人，将生命吹进他的鼻孔，使他成为有生命之物，然后自己看着这个杰作也不免倒退了一两步。这一事件令人讶异的部分反而是：亚当自己一点都不惊奇。</p>
<p><strong>梅花J</strong></p>
<p>&emsp;&emsp;小丑取得灵长类的形貌，在小精灵之间走动。他俯视两只陌生的手，用手触碰自己还不熟悉的脸颊，爪抓眉毛，这才知道脑子里面藏着挥之不去的困扰谜题，到底这个自我、灵魂的原生质、能认知的胶质是怎么回事。他永远无法更接近事物的本质部分。他模糊地觉知自己一定是个移植过来的脑。那么他也不再是他自己了。</p>
<p><strong>梅花Q</strong></p>
<p>&emsp;&emsp;这个世界上，处处都看得到欲求。一物越强大越有力，它就越鲜明地感觉自己缺乏救援。谁会听到沙粒的苦难？谁会侧耳倾听蝼蚁的欲求？如果一切都不存在，就不会有任何涉及渴望的情事了。</p>
<p><strong>梅花K</strong></p>
<p>&emsp;&emsp;我们生出并且生自一个我们不认识的灵魂。当这个谜在双腿上撑起自己而尚未得到解答时，就该轮到我们上场了。当梦中的画面掐住自己双臂而未能醒觉时，那就是我们。因为我们正是没人猜测的谜。我们是困陷于自身形象中的童话。我们是那一直在前进而未曾抵达理解的东西。</p>
<p><strong>方块A</strong></p>
<p>&emsp;&emsp;某物竖起耳，张开眼；它经历了遍地火焰，史前的厚重浓雾，通过了寄居洞穴阶段，继续往上走，终于来到了一望无际的大草原。</p>
<p><strong>方块2</strong></p>
<p>&emsp;&emsp;这条秘密的通道蜿蜒曲折，它并非向内走，而是向外走，并非走入迷宫，而是走出迷宫。秘密经由含氢的蒸汽，循环相生的轮生体，不断爆炸的超大新星，而传递下去。最后一步是一个自己形成的巨大分子网。</p>
<p><strong>方块3</strong></p>
<p>&emsp;&emsp;家族秘密的蛛网伸展开来，从史前浓雾里的微小谜团，走到了视力清爽的肉鳍鱼，以及更为进步的两栖类。就这么小心翼翼地，接力棒再由温血的爬虫类，擅长跳跃翻腾的原猴，以及看来愁眉不展的类人猿传下去，在爬虫类的脑海深处，潜藏着自我觉知的初步能力吗？没有一只不平凡的类人猿曾经对这实际进行中的庞大设计，产生一点模糊的念头吗？</p>
<p><strong>方块4</strong></p>
<p>&emsp;&emsp;这全盘景观就像充满魔法的迷雾，冉冉升起。它穿过了迷雾，也超越了迷雾。尼安德塔人旁系的兄弟皱着眉头，知道在他这灵长类的额头里面，游动着柔软的脑浆，那是演化过程里的自动驾驶员，是蛋白质盛宴里介于心智与物质之间的气囊。</p>
<p><strong>方块5</strong></p>
<p>&emsp;&emsp;突破点在四肢动物的大脑圆环出现了。这是物种宣布最新成就的地方。在温血脊椎动物的神经细胞中，第一瓶香槟的木塞飞了起来。比近代灵长类更进一步的品种，终于看到了伟大的全盘景观。他们并不害怕：这是宇宙正在以广角镜头观看自己。</p>
<p><strong>方块6</strong></p>
<p>&emsp;&emsp;灵长类蓦然回首，在以光年计算的夜里回溯反思，看到了远亲谜样的尾巴。直至此刻，神秘通道才算抵达终点，那终点就是意识到长途旅行原来是走向那终点本身。此时他能做的就是以双手鼓掌，而双手正是他为物种后代所储存的最后利器。</p>
<p><strong>方块7</strong></p>
<p>&emsp;&emsp;对于自己的祖先在演化时突然转入一个没有尽头的死巷，大象自然会觉得尴尬。原猴可以获得较多表扬。它的外表也许看来有些可笑，但是至少演化的方向感没有问题。不是每一条路都通向小丑。</p>
<p><strong>方块8</strong></p>
<p>&emsp;&emsp;从鱼类、爬虫类与甜美可爱的小地鼠身上，潇洒的灵长类继承了一双适用的眼睛，可以分辨空间的纵深。肉鳍鱼的遥远后裔，观看着银河群星在太空中的飞行，知道那是花了数十亿年才能使他们的视觉变得越来越完美。水晶体由大分子琢磨修饰。目光的聚焦作用则由高蛋白与氨基酸来完成。</p>
<p><strong>方块9</strong></p>
<p>&emsp;&emsp;在眼球中，创造与反思发生撞击。可双向注视的眼球是神奇的旋转门，在那儿，创造的灵在被造的灵身上遇到自己。眺望宇宙的眼，正是宇宙自己的眼。</p>
<p><strong>方块10</strong></p>
<p>&emsp;&emsp;小精灵不是虚构的，而是脊椎动物。他们是鱼子、蛙卵，突变的爬虫类子孙。小精灵是五指的脊椎动物，原始地鼠的合法后裔，没有尾巴的灵长类——他们听到那原始鼓声沉闷的回音，就从树上爬了下来。</p>
<p><strong>方块J</strong></p>
<p>&emsp;&emsp;小精灵不是由外而来，却是由内而生的。他们是活跃的DNA蜘蛛所结成的精微奥妙的网。小精灵不是洞穴墙壁上的幻影角色。他们是极具特殊性的细胞殖民地。小精灵不是幻想。但他们是童话，纯粹的童话。</p>
<p><strong>方块Q</strong></p>
<p>&emsp;&emsp;这个充满生命的星球，目前是由数十亿个极具个人性的首席哺乳类动物在统治。他们全部源于同一个海湾，来自同一条肉鳍鱼的肚子。他们之中，不曾有两个完全一样。也不曾有两个小精灵降临在同一个星球上。</p>
<p><strong>方块K</strong></p>
<p>&emsp;&emsp;小丑站在秘密通道的终点。他知道自己背负着古老的行李，这行李不是装在背包或布袋中，而是深藏在他身上的每一颗细胞中。他看到地球在做成内部的精致奥妙的转型之后，继续扩张其精巧的DNA塑像。谁是今年的大象？今年的鸵鸟在哪里？此刻，谁是世上最有名的灵长类？</p>
<p><strong>红心A</strong></p>
<p>&emsp;&emsp;小精灵现在是在童话中，但他们对此并无所见。童话若能看到自己，那还是真正的童话吗？日常生活若是一直不停地解说自己，那还是个奇迹吗？</p>
<p><strong>红心2</strong></p>
<p>&emsp;&emsp;小精灵总是充满生机而未必全然清醒，奇妙可喜而未必全然可靠，而且神秘的程度也超过他们小小的悟性所能理解的范围。仿佛令人昏昏欲睡的八月午后，晕眩的大黄蜂在花间追逐喧闹，这个季节的小精灵也固守着他们在天体中的高尚居所。只有小丑设法让自己获得自由。</p>
<p><strong>红心3</strong></p>
<p>&emsp;&emsp;小精灵把无线电望远镜转向那由内观看的童话外围的遥远迷雾。但是这个奇妙景观无法从内部来理解，而小精灵正好住在内部。小精灵住在自己的世界中，他们被这个谜团的存在学重力场牢牢困住了。他们是存在之物，既然如此，就没有理解可言，有的只是延伸与延续。</p>
<p><strong>红心4</strong></p>
<p>&emsp;&emsp;鱼类的五等表亲稳稳坐好，在四万尺的高空中向下俯视，看到每一间Hansel与Grete的屋子所透出的灯光。即使是停电，昏暗的地面仍有许多活物来来去去。即使灯泡全亮，照样会有一股气流从地面升起，模糊了视野。</p>
<p><strong>红心5</strong></p>
<p>&emsp;&emsp;此刻是小精灵国的清晨，在打开电灯泡之前，虽然有十万个内在光源透出微光，天色依然昏暗。小精灵已经开始从怠惰的梦境中摇醒自己，但他们的脑细胞还在交互放着影片，影片内容是：坐在戏院观看自己在银幕上。</p>
<p><strong>红心6</strong></p>
<p>&emsp;&emsp;小精灵试着思考一些想法，那些想法是很难思考的，以至他们无法思考。但他们就是无法思考。银幕里的影像不会跳出来，走进戏院攻击放映机。只有小丑找到通往座位的路。</p>
<p><strong>红心7</strong></p>
<p>&emsp;&emsp;小精灵在神奇的文明戏院中，扮演他们任意随行的演出部分。他们完全沉醉于自己的角色中，以至忘了从来就没有任何观众。没有外来者，没有冷静的观点。只有小丑向后退了一步。</p>
<p><strong>红心8</strong></p>
<p>&emsp;&emsp;小精灵妈妈站在镜前，检视着自己披在匀称肩膀上的金色长发。她认为自己是世间最可爱的雌性灵长类。小小精灵在地板上爬来爬去，他们手中抓满了颜色鲜丽的积木。小精灵爸爸躺在沙发上，头埋在一份粉红色的报纸下。他认为日常生活是踏实的。</p>
<p><strong>红心9</strong></p>
<p>&emsp;&emsp;在太阳已经变成一颗红色巨星之后的无数世代中，太空星雾里还可以截听到片段的无线电讯号。你穿好衬衫了吗?安东尼奥？立刻来妈妈这里！现在离圣诞节只有四周了。</p>
<p><strong>红心10</strong></p>
<p>&emsp;&emsp;在隆起的腹部的黑暗世界中，总是游动着数百万个卵巢，卵巢里包藏的是全新的世界意识。在无助的小精灵变得成熟并且准备要呼吸时，就一个个被挤压出来了。此时，他们除了吸吮母体那对乳头流出来的甜美乳汁之外，还不能吃别的事物。</p>
<p><strong>红心J</strong></p>
<p>&emsp;&emsp;蜜糖般的小娃儿穿着蓝色小背心，让人真想咬他一口。一颗大梨树的横枝下，系着两条结实的绳子，下端附着一块木板；小精灵妈妈看着他坐在木板上荡过来又荡过去。她正在悉心照料这朵午后的火花，它的来源是那庞大而神奇无比的烟火，她环顾这座小花园中的一切，却没有看到那联结起所有花园的闪耀亮光。</p>
<p><strong>红心Q</strong></p>
<p>&emsp;&emsp;红心皇后是她自己的花朵。当她想装饰客厅或会见情人时，就会把自己摘下来，那真是一项了不起的杰作，她知道自己来自稀有品种。郁金香争先恐后地亦步亦趋。雏菊抬头望她，羡慕不已。百合恭敬地点头示意。</p>
<p><strong>红心K</strong></p>
<p>&emsp;&emsp;当我们死时，亦即影片中的画面停格而场景被拆卸烧毁时，我们将时后代子孙记忆中的魅影。接着，我们变成鬼魂，亲爱的，然后变成了神话。但是，我们依然在一起，我们依然一起构成了过去，我们是一个遥远的过去。在神秘的过去所形成的屋宇圆顶下，我依然听见你的声音。</p>
<p><strong>黑桃A</strong></p>
<p>&emsp;&emsp;小丑像是童话里的间谍，不知疲倦地游走于小精灵之间。他获得了他的结论，但是找不到人可以诉说。只有小丑是他所看到的。只有小丑看到他所是的。</p>
<p><strong>黑桃2</strong></p>
<p>&emsp;&emsp;当小精灵从睡眠的秘密世界中释放出来，准备充分要进入崭新的一天时，他们会想些什么？统计数字会说什么？这是小丑在发问。每当这种小奇迹出现时，他都会显示同样的惊讶神情。他全神贯注地看着这个奇迹，有如他在耍弄自己的一项小把戏时一样。他就以这样的方式庆祝创造之黎明。他就以这样的方式礼赞今日黎明之创造。</p>
<p><strong>黑桃3</strong></p>
<p>&emsp;&emsp;小丑从无拘无束的梦境醒来，看到自己只是个皮包骨的瘦子。他赶紧采下夜里长大的莓果，以免白天将它们摧得过熟。现在就做，不然永远没机会做。现在就做，不然机会不会再来。小丑明白，他不可能两次走下同一张床。</p>
<p><strong>黑桃4</strong></p>
<p>&emsp;&emsp;小丑是一个机械玩偶，每天晚上都会还原为一片片零件。当他醒来时，立刻收集手脚，组合起来，玩偶这才像是昨天的模样。那儿有几只手臂？又有几条腿？接着，头在这里，加上双眼与双耳，然后他才能起床。</p>
<p><strong>黑桃5</strong></p>
<p>&emsp;&emsp;小丑最先醒来的，是枕头上一个有机影碟里面的部分。他觉得自己正在从半清醒的幻象热流中，努力爬向新的一天的岸边。是什么样的核能，使小精灵的脑袋燃起火花？是什么让意识的爆竹嘶嘶作响？是什么样的原子能把灵魂的脑细胞联结在一起？</p>
<p><strong>黑桃6</strong></p>
<p>&emsp;&emsp;他觉得自己漂浮在空荡荡的地方。不能一直这样下去。不是到了应该再往前走一步的时候吗？小丑对着卧室的镜子，做出一些反抗的手势，努力想从自己灵魂的生魂之内，闪现明智的一瞥。但是一切如常。他咬紧牙关，让自己屈从于这个奇迹中。</p>
<p><strong>黑桃7</strong></p>
<p>&emsp;&emsp;忽然之间，他竟坐在马鞍上，奔驰于那注定的由始到终的旅程中。他不记得自己上了马，但是现在只觉得野生种马在胯下疾奔，接着他被神秘的力量举起，然后顿然停止。</p>
<p><strong>黑桃8</strong></p>
<p>&emsp;&emsp;小丑心中充满各种假设情况，以至恍惚之间竟觉得自己十分坚实，他能算出，自第一次细胞分裂以来，至今已经过了多少代？他能算出，从第一只哺乳动物诞生以来，又经过了多少次繁殖？现在该计算这个大数字了。当第一条肺鱼跳出水面时，他不就是一直走在旅程中，准备迎接今晨的反思？然后，一刹那之间，这个小弄臣感觉到有死之物的晕眩。他有丰富的背景，但是他没有未来。他在过去是十分充实的，但是今后，他什么都不是了。</p>
<p><strong>黑桃9</strong></p>
<p>&emsp;&emsp;小丑是抑郁不欢的天使。致命的误会使他得到血肉之躯。他原本只想分享灵长类的命运一时片刻，但扯断了身后的天梯。如果此时无人接他回去，则生理时钟将会加速运作，而他也将回不了天堂了。</p>
<p><strong>黑桃10</strong></p>
<p>&emsp;&emsp;走出童话的大门敞开着。当然，应该有人去报告这个情况，但是却找不到负责报告的人。小丑被无情地拖向寒冷的风口，外面是一片荒寒。他忍不住流下眼泪，不，他现在真的哭了。然后，这个机灵的弄臣伤心地告别了。他知道自己没法讨价还价。他知道这个世界不会再回来了。</p>
<p><strong>黑桃J</strong></p>
<p>&emsp;&emsp;在小精灵的世界中，小丑只是半个生命。他知道自己会离开，因此付出一定的代价。他知道自己正在离开，因此已经走了一半。他从一切都存在的地方走出来，现在是走向虚无之地。一旦他抵达了，就连做梦要回去也不再可能。他走向一块土地，在那儿甚至连睡眠都不存在。</p>
<p><strong>黑桃Q</strong></p>
<p>&emsp;&emsp;小丑越接近永恒的幻灭，就越清除地看见自己在新的一天醒来时在镜中所遇到的动物。在一个悲戚的灵长类绝望的眼神中，他找不到任何妥协的余地。他看到的是一尾着魔的鱼，一只变形的青蛙，一条残疾的蜥蜴。这是世界的末日，他这么想。这是演化的长途旅行画下句点之处。</p>
<p><strong>黑桃K</strong></p>
<p>&emsp;&emsp;创造一个人得花上几十亿年，魂飞魄散却只在转瞬之间。<em>（该则中文来自其他翻译，傅译本稍欠韵律。）</em></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Chris Lattner：编译器的黄金时代</title>
    <url>/2023/02/01/Chris-Lattner%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3/</url>
    <content><![CDATA[<blockquote>
<p>链接: <a href="https://new.qq.com/rain/a/20220421A04VCX00.html">https://new.qq.com/rain/a/20220421A04VCX00.html</a></p>
</blockquote>
<p>摩尔定律失效论的讨论与日俱增，2018年，图灵奖获得者 John Hennessey 和 David Patterson 在一次演讲上更是直言，几十年来的 RISC（精简指令集）和 CISC（复杂指令集）孰优孰劣之争可以终结了，新一轮计算机架构的黄金时代已经到来，为此，他们在2019年的 ACM 期刊上发表了一篇文章里作专门论述。</p>
<span id="more"></span>

<p>为了打破当前架构发展的桎梏，他们给出的答案是，需要软硬件协同设计和创新，构建领域专用架构、领域专用语言，从而构建更专业化的硬件，并提升运行速度。</p>
<p>作为驱动计算机架构革新的重要组成部分，编译器也在迎来它的黄金时代。就在去年4月19日的ASPLOS会议上，编译器大牛Chris Lattner在主题演讲中分享了关于编译器的发展现状和未来、编程语言、加速器和摩尔定律失效论，并且讨论业内人士如何去协同创新，推动行业发展，实现处理器运行速度的大幅提升。OneFlow社区对其演讲内容做了不改变原意的编译，希望能对AI&#x2F;编译器社区有所启发。</p>
<p>Chris Lattner 毕业于波特兰大学的计算机科学系，具有创建和领导多个知名大型项目的经验，其中包括 LLVM、Clang、MLIR和CIRCT等编译器基础设施项目，他还带头创建了Swift编程语言。</p>
<p>从2005年7月到2017年1月间，他曾领导苹果的开发者工具部门，随后，曾短暂领导过特斯拉的自动驾驶团队。2017年8月，Chris Lattner 在Google Brain团队领导了TensorFlow基础设施工作，包括一系列硬件支持（CPU、GPU、TPU），底层运行时和编程语言工作。</p>
<p>2020 年 1 月到 2022 年 1 月，Chris Lattner 在 SiFive 公司领导工程和产品团队（包括硬件、软件和平台工程），SiFive 基于开源指令集 RISC-V，向芯片设计公司提供 IP。去年 6 月，SiFive 收到了英特尔的收购意向，后者提出以超过 20 亿美元的价格收购这家公司。2022 年 1 月，Chris Lattner 和 Tim Davis 共同成立了 Modular AI，他本人担任CEO，目标是重建全球 ML 基础设施。</p>
<p>以下是Chris Lattner的演讲内容。</p>
<p>为什么需要下一代编译器和编程语言</p>
<p>尽管硬件正在蓬勃发展，新加速器和新技术不断涌现，但软件业却很难真正利用它们。</p>
<p>为什么会这样？在加速器的世界里，比如AI和结构化计算技术发展领域，出现了标量加速和向量加速等多种层面的加速，就像CPU领域也分为标量处理器和向量处理器一样，当然现在还有多核CPU。这样一来就会出现多种硬件组合，不同的硬件安装在同一个数据中心，那这些硬件就必须相互通信。</p>
<p>但是，很多时候却没有一致性的内存，导致写一个C语言程序来运行所有东西是不可行的，这样的组合运行有点像超级计算机使用多个CPU一样。</p>
<p>同时，世界正在越来越异质化，出现了各种各样的应用。机器学习快速发展，但机器学习涉及很多技术，如果你不止研究训练和推理，还想研究强化学习，那就要了解不同的加速器。如果你想研究强化学习，就要整合主机计算和加速器计算，让它们协同工作。现在制造的很多新设备里的IP和硬件块都是可配置的，即便是随存储器层次深度改变缓存大小这么简单的事，都会影响这些设备运行所依赖的内核。</p>
<p>所以，尽管现在硬件越来越多样，硬件生态迅速壮大，但软件还是很难充分利用它们来提高性能。而且如果软硬件协同不到位，性能就会受到巨大影响，那不止是10%左右的浮动，比如，如果弄错了内存层次结构，性能很可能会发生断崖式下跌，变成正常水平的十分之一。</p>
<p>当今，加速器领域发生爆炸式增长，几乎每天都会有新公司制造新的加速器。但问题是，怎么用这个加速器？更关键的是，有人想做新应用，但他们想在软件代码库上下工夫，于是不停地推进和完善软件代码库。</p>
<p>你无法直接在这个新设备上使用旧的软件堆栈，它们的某个部件可能换了供应商，做了流程精简，导致所需的技术堆栈不一样。因此，你不得不给每个新的小型设备都写一个全新的软件堆栈。而这样做又导致了软件的碎片化，这种碎片化的发展带来了巨大成本，也会反噬硬件行业，因为硬件用不了了。</p>
<p>我的观点是，我们需要下一代编译器和编程语言来帮助解决这种碎片化。首先，计算机行业需要更好的硬件抽象，硬件抽象是允许软件创新的方式，不需要让每种不同设备变得过于专用化。</p>
<p>其次，我们需要支持异构计算，因为要在一个混合计算矩阵里做矩阵乘法、解码JPEG、非结构化计算等等。然后，还需要适用专门领域的语言，以及普通人也可以用的编程模型。</p>
<p>最后，我们也需要具备高质量、高可靠性和高延展性的架构。我很喜欢编译器，很多人根据编译器在做应用，我也很尊重这一点。可以说，他们在开发下一代神经网络，而不仅仅只想做编译器。大家可以合作，这样一来就意味着他们需要可用的环境和可用的工具。</p>
<p>令人兴奋的是，编译器或者编程语言工程师会迎来一个崭新的时代：过去和现在都有无数的技术诞生，这些技术正在改变世界，有幸参与这场变革浪潮非常令人激动。</p>
<p>接下来，我会谈谈编译器行业的早期发展，以及它带给我们的经验和对未来的启发。</p>
<p>传统编译器的设计和挑战</p>
<p>当我还是学生时，编译器是单独装盒的，安装在一个软盘上，每次使用都要把软盘插进电脑里。</p>
<p>当时的行业状况是，不同的供应商做出不同的处理器、操作系统，都想要通过创新脱颖而出，抓住编译器的价值。这些编译器都是专用的，互不兼容，不会共享代码。所以你会看到Borland C编译器和Microsoft C编译器互相竞争，最终造成碎片化生态。这就阻碍了行业发展，但人们还没有意识到这一点。</p>
<p>编译器由前端、优化器和后端组成，这种固定结构已经沿用很多年了。如果一家公司自主研发了一个编译器，通常的做法是只研发一套前端和后端，而不会投入太多资金研发多种前端和后端。其他公司也会这么做，这导致不同公司的优化器和前后端不能通用。</p>
<p>GCC编译器团队最早打破了这种模式。GCC通过自由软件和开放许可证，允许互相合作，这使得人们可以将前端、优化器、后端分开设计，实现“关注点分离”。也因为这个原因，GCC有了多种前端和后端。</p>
<p>这样的“关注点分离”不但有利于编译器的研究改进，还改变了编译器的行业格局。因为GCC有最好的C++前端，所以一大批编译器工程师都在这个前端的代码库基础上改进，推动了创新和C++的发展。同时，一大批CPU公司可以直接运用GCC的前端，只需加上自己的后端就能参与市场竞争。因此20世纪90年代到21世纪初这段时间，整个行业的碎片化程度降低。从那时起，GCC为C语言编译器的发展铺平了道路，涌现出更多新编译器。这是行业的巨大成功，因为它点燃了创新的火把。</p>
<p>继GCC的革新之后又出现了一些新技术，其中包括我自己特别喜欢的LLVM，我想讲的是它的模块性。它颠覆了编译器长久以来的“前端+优化器+后端”的三段结构，LLVM编译器是一系列库（library）的组合。查看LLVM代码库会发现，所有代码都在lib目录下。</p>
<p>这些库可以单独拎出来，与其他库组合、搭配使用，也可以重复使用。它可以和电影特效处理引擎、数据库查询引擎结合起来，LLVM既是一个优秀的C++编译器，也可以发挥更广泛、更有创新性的用途。</p>
<p>LLVM的模块性凸显了接口和组件的重要性。自LLVM诞生的20多年来，没有了前端、优化器、后端的划分，它用一种革新的方式推动了编译器行业的发展。比如可以把XA6编译器或者X86后端用到别的地方，还可以集中全世界顶尖专家来专门单独研究寄存器分配器，而不用管其他编译器组件，这样既提高了扩展性，也催生了新的合作形式。</p>
<p>LLVM的一大优点就是可以集合更多人的力量，实现更多创新。很多基于LLVM的新前端已经诞生，而且它促进了Julia语言、数字编程、Rust和Swift语言、系统程式设计、安全编程模型等大力发展，这让人倍感兴奋。LLVM的模块性、IR的独立性、低碎片化程度也催生了多种语言。</p>
<p>此外，LLVM还让JIT编译（即时编译）能有更多作为。虽然JIT编译器已经是一种著名的技术，但它一开始是用在其他地方。有了LLVM以后，芯片设计、HLS工具、图形处理、都更加便捷，还促进了CUDA和GPGPU的诞生，这些都是很了不起的成就。</p>
<p>但更重要的的是，LLVM整合了的碎片化。LLVM出现之前有很多种JIT编译器框架，但LLVM的存在，提升了JIT编译器的基线，让它迸发出更多可能，也让行业可以实现更高层次的创新。</p>
<p>话说回来，LLVM虽然有很多优点，但它同样存在很多问题。一开始LLVM的目标是成为一个“万能”的解决方案，但结果它好像什么也没做好。很多人不断给LLVM加一些“乱七八糟”的东西，你可以对CPU和GPU可以这么做，但对加速器来说不太行。这种胡乱做“加法”就导致不能很好地用LLVM做并行处理优化。但我喜欢LLVM的一点是，它是一个很好的CPU后端，尽管并不能很好满足其他需求。</p>
<p>现在我们来到了“摩尔定律失效期”，我们可以发扬LLVM作为CPU后端的优点，但如果要探索CPU以外的功能，应该把目光放到LLVM IR之外。</p>
<p>构建适用专用领域的架构</p>
<p>Patterson和Hennessey提出过一个结论：我们来到了计算机架构的文艺复兴时代，需要把计算机行业上下游人员垂直整合起来，大家既要懂硬件，也要懂软件。他们说，因为世界变化得很快，所以思考问题时要回归第一性原理，要用新的眼光去重新看待旧事物。</p>
<p>接下来我会讲讲加速器的构建过程，并结合经验谈谈加速器未来可能的演变。</p>
<p>如果观察硬件领域，会发现专用化架构已成为一种趋势，分化出一系列的专门品类。关于这个话题，我推荐观看Mike Urbach的演讲。如果把CPU看作通用型处理器，那么当你想控制所有的门（gate）时，就需要更深的专用化和更多硬编码能力。</p>
<p>所以一方面CPU是通用的，不像矩阵运算加速器那么专用化。然后出现了GPGPU，很灵活，功能也很强大，但要对GPU进行编程就没那么容易了。然后针对机器学习加速又出现了TPU，可以做大矩阵乘法运算和直接卷积等操作。这些是可编程的各种“xPU”，除此之外还有FPGA（现场可编程门阵列）等固定功能硬件，你可以重新配置block之间的线路；再进一步细分的话还有ASIC，也就是可以应特定需要专门设计集成电路。</p>
<p>总体就这两个大类，一类是通用的、可编程的，另一类是功能比较固定的。每当我思考领域专用架构时，我的脑海里就会浮现这两大类。</p>
<p>上图列举了一些正在做上述硬件的公司（不完全统计），可以看到有不少都是行业巨头。每个公司研究的时候都会思考：怎么给它编程？而每个公司也会给出不同的答案。比如Google在做XLA和TensorFlow，NVIDIA在做CUDA，Intel在做oneAPI，还有很多硬件公司在做自己的硬件设计工具包等等。</p>
<p>问题是，每个工具针对的都是不同问题，它们不协同，也不兼容。因为它们是每个公司的小型团队自主研发的，共享的代码不多，而每个公司也都孜孜不倦地给自己的工具增加新功能，各个工具都瞬息万变，造成比较混乱的整体局面。这些工具作为行业的基本组件，却有这么多不同特点，那从行业层面应该怎么做？</p>
<p>其实今天的加速器遇到的问题，90年代的C语言编译器也遇到过。就像人们常说的那样，历史是一个轮回。我们见证了硬件和软件的多样性爆发，但如果想要继续发展，这种多样性就会成为阻碍。</p>
<p>所以我们需要统一，需要一些类似GCC和LLVM这样的东西，不然都要忙着为每个特定的设备开发一个专属后端，就没时间进行前端、编程语言和模型的创新了。</p>
<p>业内有许多精英人才，但还不够多。假如我们能够减少碎片化，把行业整合起来，就可以促进创新，加快行业发展，持续建立技术堆栈，充分利用硬件，并以全新方式利用异构计算。</p>
<p>接下来谈谈我对加速器发展的看法，以及发展过程中可能遇到的挑战。</p>
<p>加速器的本质和演进</p>
<p>加速器是什么？可以把它高度简化成两个部分，第一个是并行计算单元。因为硅本身的结构也是并行的，加速器要用到许多晶体管，也就需要很多硅来达成这种并行处理能力。</p>
<p>第二个部分起控制作用。它的名字不太统一，有人叫它“控制处理器（Control Processor）”，有人叫它“序列器（Sequencer）”。有人希望它小一点，所以会做状态机然后嵌入寄存器。这个部分基本上起到编排并行计算单元的作用。如果并行计算单元是一个大型矩阵乘法单元，控制处理器就会命令它执行一些宏操作，例如从这个内存区加载、执行某一操作、执行另一操作、更新SRAM等。</p>
<p>还有一些加速器很不一样，所以控制逻辑和计算之间的比率也各有不同。正如Patterson和Hennessy所说那样，你可以选择不同的点，但每个点都需要一定程度的编排。</p>
<p>但人们常常忘记其他一些相关的工作，比如，你不止需要编排，还要解决启动问题，比如电源管理，还要不断调试排错。如果你想做得尽善尽美，可以对这些部件进行编程；如果你希望简单一点，可以把这些部件做得很小。</p>
<p>当控制处理器和并行计算单元都齐备之后，怎么给它们输入和输出信息？这时就需要一个内存接口。根据抽象等级的不同，这个内存接口可以是小型的block，也可以是支持物联网的芯片，这样加速器就可以和该芯片连接整个网络通信了。这里需要用到像AMBA或类似的技术。</p>
<p>你可以在更大的粒度（granularity）上构建整个 ASIC，所有的 ASIC 都在加速，在这种情况下，你可能正在与 PCI 通信，并且正在芯片外直接访问内存，但这种“我有一个控制处理器，有一个计算单元和有一个内存接口”的模型，是构建这些东西的一种非常标准的方法。</p>
<p>一旦这些结构问题解决了，架构师们就开始大展拳脚，但他们往往忘记还需要软件人员参与进来。</p>
<p>理想情况下，他们会从最基本的问题开始着手解决，但软件最终看起来像按照几个不同的层次来做。最高层次是考虑用户体验，用户如何使用？要如何围绕它构建一个应用程序？而最低层次则是考虑控制处理器的运行，所以至少需要一个汇编器来完成要处理的控制过程。</p>
<p>然后写一个运行在某种主机处理器上的驱动程序来控制这个东西，控制它打开和关闭，进行加载，把程序上传到控制处理器。之后有一些工作在这些控制处理器上运行，所以这些通常被称为内核。这个模型很通用，但最终的结果是硬件变得更复杂。所以第一代协同处理器（first generation co-processor）可能很简单，但后来有人想出了这个绝妙的主意：我们想实现更多。</p>
<p>在这种情况下，我们想减小面积来进行加速，想做更多的AI、物理、5G或比特币等领域的任何值得加速的东西。最终的结果需要更多的控制处理器，因为光速和线延迟等问题会导致不能只用一个控制处理器在一个巨大的芯片上协调所有的晶体管，所以你需要多个控制处理器并行处理。</p>
<p>幸运的是，这很容易放进你的模型里，因为只需要将这些设备内核并行化、多线程化或做一些展开（tiling），只需做一些简单的改动就可以了。然后，在这些淡褐色单元上运行的内核就可以一起协作解决问题，把任何问题在空间上进行分解，再并行处理。</p>
<p>现在开始，事情变得更加复杂。当建立一个像GPU一样专门的加速器，比如要把数十亿个晶体管组装成一个完整的十字形芯片。这种规模的芯片会产生多方面的问题。</p>
<p>首先，你最终想有多层次的平铺，所以不会只想拥有492个核，你可以在GPU上有阵列，或者有不同的SMS或类似的东西。或者将有异质性介入，所以在同一物理芯片上将有不同种类的加速器，因为我可能正在做AI，但需要能够解码一些JPEG。因此，如果我打算在相机上做推理，需要对相机的传感器数据进行原始解码，这将得到新的加速器block，它们是硬编码用于不同操作，而且这些都混在一起。</p>
<p>然后它们需要通过内存接口相互通信，这需要对其进行编程，并且变得更加复杂。现在突然需要这个中间层的技术，在加速器上处理多个数据流时，不只是在加速器上不同单元的tile上有并行性。因为现在有多个不同的操作在同时运行，所以要解决工作负载平衡的问题。</p>
<p>此外，还要解决通信优化问题，光速是一个痛点，因为把数据从芯片的一端传到另一端需要时间。但是这段时间你不想闲着，而是想在通信的同时进行另一个通信过程，或者在做通信的同时进行计算。</p>
<p>你希望能够运行像TensorFlow一样的东西，现在你可能有一个XA6后置处理器，所以希望从加速器回到主机处理器。因为你在做文件系统操作或其他非常奇怪的事情，就必须能够协调这一点，突然，这层软件开始变得非常大，而且相当复杂。</p>
<p>在很多情况下已经证实了这一点，很多加速器都经历过这种情况。一个问题是，他们一开始都是手工写的kernel，这些东西有多个不同的进化步骤，从这些硬件供应商的产品中可以看到：随着时间的推移，他们的硬件不断进化，变得越来越普遍，软件堆栈和支持的功能也在不断进化。</p>
<p>所以kernel的优点是，它是最简单好用的开始方式。一个硬件人员与一个固件人员配对，就可以清楚地知道硬件的作用。软件人员和硬件人员通过协同设计紧密合作，让你的矩阵乘法在AI工作负荷上运行得非常快。它的抽象程度很低，很容易搞定。</p>
<p>问题是，这并没有真正扩展能力。所以我们也看到，现在想在加速器上运行的工作负载不仅仅是矩阵乘法，他们想要在这些东西上运行成百上千种不同的核运算，涵盖从卷积和矩阵乘法到重塑（主要是内存操作）到元素间操作（element-wise operations），再到各种奇怪的操作，比如Top K和排序，再到非常普遍的新一代研究稀疏算法的东西和其他新兴的不同应用。</p>
<p>随之而来的问题是，一方面你有这些正在运行的kernel，另一方面，你有硬件的无限通用性。因此，在一个供应商的硬件中，也许你可以把它固定然后看看新一代的技术。</p>
<p>你只需要手写一百或一千单位的kernel就行了。也许这没问题，但当你推出了第二代设备，可能改变了内存层次结构，给控制处理器增加了一些新指令，增加了可选的功能，或者你决定做kernel融合，想对卷积进行元素间操作，这时你就有一个n次方的不同kernel的组合需要很好地融合。即使你有成千上万个软件工程师，你也不能手写所有的kernel，因为你希望你的硬件团队能够快速推进工作。</p>
<p>我见过这种情况好几次了，最终人们开始手写kernel，但后来他们写了一个Python程序来生成kernel，这些Python程序在某种意义上就像微型编译器。</p>
<p>如果继续这样做，这些复杂性就会叠加起来，最终形成了这个编译器层，它可以通过强大的编译器工程来形成。这在理论上是可能的，随着时间的推移，它可以通过自然演变逐渐形成，就像人类从爬行到行走一样，这是我在实践中所看到的真实情况。每个人都有机会成为这个过程的缔造者，这方面还有很大的进步空间。</p>
<p>当你在构建一个真实的东西时，实际上很困难。刚开始感觉容易，是因为可以构建一个小型控制处理器和小型加速器，让一些软件运行得很快，这种情况下很简单。但当你沿着“这条路”继续走，困难会慢慢出现，实际上，直到遇到扩展问题之前都不会觉到特别难，但你不想改变方向了。</p>
<p>此外，正如我们之前所说的，产品质量并不一直都很好。现在，人们创造出令人惊叹的产品，而我也一直对这个行业中不断发生的创新感到惊讶。但我们也见过一些编译器崩溃了，比如技术堆栈中出现的坏消息。</p>
<p>这是有道理的，人们就不会总在这方面投资。虽然我能理解这种做法，但这阻碍了行业发展，导致使用这些工具变得更加困难。因此，要减少社区中愿意容忍和使用这些工具的人。</p>
<p>我认为另一个真正的问题是，大部分复杂性真的与解决加速器问题无关。如果我想建立一个5G网络加速器，需要考虑5G、FTS、问题中固有的并行性以及如何利用它们。如果要考虑人工智能机器学习的工作量，我应该考虑的是算数运算以及计算和内存的正确比例等等。但相反，我们通常需要在和这些重要的问题无关的事情上投入很多时间，以复杂性而告终。</p>
<p>如果你把与加速器有关的重要东西抹掉，剩下的就是控制处理器的内核驱动和汇编程序以及像所有这些复杂的多流管理小组，该如何利用加速器上的所有tiles。</p>
<p>这不是我们想花费时间的地方，要花时间在编程模式、硬件等方面进行创新，但这种碎片化是真正阻碍行业发展的原因。</p>
<p>因此，我的主张是创新编程模型，发展新的应用程序，通过不断创新推动行业向前发展。我们应该对此过程所需的一切实行标准化，通过标准化能够快速完成工作，然后就可以把时间花在真正重要的事情上。</p>
<p>那么，如何做好这个工作？幸运的是，业界已经开始对我们需要的所有接口总线进行标准化。如果你与你知道的SoC结构连接，通常使用AMBA或CHAI或类似的东西。如果要和内存连接，那么你要用DDR或HBM这样的东西。如果你要在系统中建立一个插件卡，要使用像PCI Express这样的东西。有一些新的标准，如CXL定义了新的方式，可以将PCI普遍化，并允许在更大规模的系统中使用新型加速器，但我们需要更进一步。</p>
<p>那么，这个控制处理器呢？需要注意的是，当我们观察加速器，开发在加速器上面运行的软件最终比打造硬件的成本更高。况且在这一点上，硬件是更被人熟知的。不同硬件有不同配置，但构建软件是一个尚未解决的问题。</p>
<p>控制处理器也在堆栈的底部，所以当我谈到系统设计中存在这些微妙的陷阱时，事情看起来很容易，但更进一步会发现它们很困难。控制处理器是其中一种情况，刚开始，你考虑的是用小型状态机来控制它，所以我会在电子表格程序写一个编译器。</p>
<p>有时候要意识到需要做电源管理，还要考量安全性，需要构建和协调这些东西的困难部分，真正改变它们最终的工作方式。如果构建控制处理器的人没有同时构建编译器，那么他们就不会感受到构建软件的痛苦，而软件最终是更困难的部分。</p>
<p>Patterson和Hennessey在他们的演讲中谈到了这一点，他们从60年代开始观察到行业存在着巨大的碎片化。IBM最终解决这个问题的方法是标准化指令集，选择的是IBM 360指令集，至今仍在使用。这是一个惊人的壮举。</p>
<p>所以，我们要做出选择，比如我们是否要标准化这些控制过程。我们会使用IBM 360吗，还是我们要用一些新的东西？</p>
<p>我认为，我们应该使用一些新东西，有一种指令集技术叫做RISC-V，它是CPU的一个开放的行业标准。我喜欢RISC-V的原因是，它是一个模块化的指令集，就像LLVM一样是模块化的、基于库的。如果不想用浮点数，它允许把指令集的不同部分划分子集出来。</p>
<p>但是，如果你不想要整数乘法，也可以把它去掉。关于RISC-V的伟大之处在于，它不仅提供了一个指令集标准，还提供了在上面运行的整个软件世界。因此，你可以得到一个C语言编译器，得到Linux，得到所有围绕RISC-V的这些东西。</p>
<p>像SiFive这样的公司，它制造了很多不同的RISC-V处理器。你可以在设计领域中得到许多不同的视角，以不同的权衡点来实现该规范。因此，如果你正在建立一个非常简单的加速器，如矩阵乘法或卷积加速器，可以有一个非常小的RISC-V核来控制一个大的硬编码加速器block。</p>
<p>另一方面，如果你想要更多的可编程性，你可以改变花费在控制和并行处理上的硅的比例，并且有更多的控制逻辑，从而实现更多的可编程性和灵活性，可以调整比率。</p>
<p>也可以反过来，并行单元是处理器的一部分，使用这个处理器时，在处理器内置一个异构计算加速器。</p>
<p>或者相反，你可以把这个加速器中的每一个tile视为一个很大的CPU，这样做就会得到像Graviton这样的云加速器，例如，你有一堆不同平铺的CPU，通用性和加速的功能都可以在一个指令集内处理，这就允许提升软件的生态系统。</p>
<p>你可能会担心，如果想构建这样一个微小的控制处理器，RISC-V会如何解决这个问题？很明显，一般的解决方案太大了。有一些非常小的RISC-V的实现，你可以得到开源的标准化的RISC-V，大约有一万五千种gates的实现，这是硅行业的美妙之处。因为有很多gates，可以不必担心在控制处理器上花费太多gates，得到最符合需求的解决方案。</p>
<p>一旦这样做，它改变了构建加速器的方式。以前你从选择一个控制处理器开始，然后写一个汇编程序或RISC-V给出一个汇编程序。但RISC-V不仅给出一个汇编程序，还给了一个C语言编译器和一个可以编程的IR。</p>
<p>因此，可以针对控制处理器来生成内核。不仅可以得到C语言编译器，还可以得到模拟器和调试器。我从来没有见过其他可以为模拟器和芯片安装GDB、LLDB的加速器，这不是人们通常会投资的技术，因为它是一次性的。但是，通过建立和利用RISC-V的生态系统，你可以投资并再次构建下一个级别的技术，从而获益。</p>
<p>一旦做到这一点，就进入到下一层级的复杂性。做出了这个类似加速器内核编译器的东西后，就会遇到下列问题：如何进行分层并行计算？一个数据中心有很多机器，电路板上有多个芯片？每个芯片在一个ASIC中有几十个或上百个不同的加速器单元，又该如何编程？</p>
<p>有趣的是，虽然所有这些编译器都是不同的，但它们有很多共同的特点。比如，都有内存层次结构，都有多个不同粒度级别的tiling，都需要能够与其互动。所以，尽管这些编译器是不同的，例如一个5G基站的编译器应该与AI加速器不同，但像平铺和内存层次结构这种需要解决的技术问题都是一致的。</p>
<p>现在有一种相对较新的编译器技术MLIR可以帮上忙。你可以把MLIR看作是一个元编译器，它允许你非常快速地构建加速器&#x2F;编译器。MLIR的全称是“多级中间表示”，它支持构建分层编译器，并以适用专门领域的方式构建，同时保留领域的复杂性。然后，使用MLIR提供的大量库和例程来做一些事情，比如，用多面体编译器来做循环展开和循环融合等等。</p>
<p>所以MLIR是LLVM技术家族的一部分，它继承了LLVM的设计方法和使LLVM如此伟大的理念，所以有了模块化、可扩展性，有一个由友好的人们组成的伟大社区。我认为，LLVM社区的一件令人欣赏事是：LLVM是模块化的，有相当好的文档，很容易学习，适合用于研究。</p>
<p>我很高兴看到MLIR的出现。尽管它只有几年的历史，但它已经被广泛用于从CPU代码生成到GPU、机器学习、FPGAs以及硬件等领域，此外，也用于量子计算和编译器本身的MLIR优化模式应用。在MLIR这个领域有很多有趣的事情发生。</p>
<p>MLIR的另一个优点是，直接在LLVM的基础上分层。它使用LLVM的库，所以可以做即时编译，写内核然后编译成LLVM IR也很容易。当然，LLVM也有很好的RISC-V代码生成支持。你可以用一种非常简单、漂亮且可组合的方式构建基于RISC-V的加速器。</p>
<p>现在，我们开始看到的是，MLIR开始统一异构计算的世界，这也是我希望看到的。所有的大公司现在都在不同程度地使用MLIR，我认为，建立在RISC-V之上的MLIR很有必要，因为一旦开始从下往上整合行业，就可以开始把越来越多的层（layer）拉到一起，重复使用更多的技术。这使得我们可以专注在堆栈中更有趣的部分，而不是一遍又一遍地重新发明轮子。</p>
<p>我们能从中得到什么？如果我们能把稀缺的编译器和编程语言的能量整合到一起，让这些人一起工作，那么这个行业可以取得更多成就。如果我们一而再、再而三地重新发明轮子，我们就会互相拉扯。</p>
<p>作为一个产业，我们需要的是更多的创新，更多的编程模型，更多的技术和基础设施，真的要减少行业的碎片化，提高其他未解决事物的模块化，然后专注于真正重要的部分。</p>
<p>我刚刚一直在谈论加速器，谈到了从CPU到TPU和GPU等各种不同的“xPU”。</p>
<p>硬件本身呢？上图右边留出了一个很大的灰色区域，在这个领域工作的人都是“硬件人员”，在左边领域工作的人既是硬件也是软件人员，但右边确实是一个非常不同硬件世界。</p>
<p>这也是并行计算单元里的东西。这就是Patterson和Hennessey谈到的适用专门领域的架构，以及如何构建这些硬件块。我们需要算法创新，需要许多不同技术的创新，这些都需要基于特定领域。</p>
<p>编译器的创新机会</p>
<p>也许你不会感到惊讶，但我认为答案是编译器，这是真正要走的一条路。</p>
<p>作为编译器编程语言从业者，我认为硬件设计这个领域已经到了重新评估的地步。整个领域是建立在两种技术之上，但实际上主要是一种叫做Verilog的技术，你大概率可能不喜欢Verilog。</p>
<p>它有一个非常复杂的标准，当我看它时，不知道它是被设计成一个IR，也即一个不同工具之间的中间表示，还是被设计成让人们直接书写的东西。我认为，它在这两方面都很失败，它真的很难使用，对工具来说也很难生成。</p>
<p>此外，EDA工具、硬件设计工具已经非常成熟，它们非常标准化，有很多大公司正在推动和开发这些工具。但他们的创新速度并不快，设计时并不注重可用性。它们比加速器编译器要差得多，绝对不是以软件架构的最佳实践来构建的，而且成本也非常高。因此，这个领域有巨大的创新机会。</p>
<p>我不是第一个认识到这一点的人。在开源社区，已经构建了一堆工具推动行业向前发展。这些工具非常棒，比如Verilator被广泛使用，Yosys是另一个非常棒的工具，它有很好的定理证明器（Theorem Prover）。</p>
<p>我的担忧在于，这些工具的理想目标是试图像专有工具一样好，而我并不真的认为专有工具有那么好。另外，这些工具的设计者并没有合作。每个工具都在遵循单一僵化的方法，没有实现大程度的模块化或重复使用，可以从其中一些工具中得到网络列表，用它来解析一些Verilog之类的东西。但是，它不是由基于库的设计构建，与LLVM之类的东西不一样。</p>
<p>好消息是，我看到了这里正在发生的不同进展的全面爆发，这与我们一直在谈论的摩尔定律的失效非常相关。我们看到，研究小组正在推动新硬件设计模型的生产，有Bluespec和Chisel等东西。有许多新的不同研究小组在探索不同的硬件设计方法，而且他们最终往往会生成Verilog，这真的很好，因为现在你可以从软件和硬件世界引入新的类型系统方法、编程语言思想、编译器技术。实际上，软件和硬件有很多想法是互通的。</p>
<p>只是软、硬件领域用不同的方式说着不同的语言。因此，如果双方能有更多的交集，这对两个行业都有益，这种合作令人惊奇，但他们也遇到了困难，这又回到了这个问题上：Verilog实际上不是一个很好的IR。</p>
<p>要创建在语法上正确，并且能表达你想要的东西的Verilog非常困难。此外，因为许多与Verilog有关的工具都有点奇怪，而且很难高质量地预测。生成与工具兼容的Verilog是每个前端工具都必须重新发明的一门黑科技。因此，在堆栈中真的缺失了一种组件，这个组件允许人们在编程模型水平上进行创新，并允许人们找到方法让所有工具都接受它。</p>
<p>有一个叫CIRCT的新开源项目正试图解决这个问题。CIRCT的全称是”Circuit IR for Compilers and Tools（编译器和工具的Circuit IR）”，它构建在MLIR和LLVM之上。CIRCT社区的目的是提升整个硬件设计世界，促进编程模型的创新，并启用一套新的模块化硬件设计工具。它确实运用了很多我们到目前为止一直在讨论的基于库的技术。</p>
<p>此外，它提供了一个可组合的基于库的工具链，可以建立有趣的新的弹性接口连接，你可以建立Chisel社区正在探索的新编程模型，用它来加速Chisel流程。它带来了很多好处，可以让很多人一起工作，推动不同方式的创新。我们正在建立一个真正伟大的小世界，让关心硬件编译器的人在一起工作，这很有趣。这项工作仍处于早期，目标是更快地构建加速器，让加速器变得更快。</p>
<p>我们的大目标是，要把硬件设计和验证过程速度都提高10倍。因此，构建新硬件往往最终需要更多的成本来验证其正确性，这包括形式化方法，相当于单元测试，有很多不同方式可以证明你正在构建的东西在所有情况下都是正确的。</p>
<p>这种正确性验证在硬件领域比在软件领域里更复杂，因为硬件领域并没有真正的类型系统，也没有真正的多层次的IR，所以也就不允许将一个状态机表示为一个状态机，并针对它编写证明。现在，正在发生的事情是整个领域被“去掉了糖分（de-sugared）”，变成了基本上没有类型的bits，然后所有的分析和工具都在这个层面上工作，我认为，我们可以通过构建和引入编译器和语言社区中相当知名的技术来迅速提升改善整个领域。</p>
<p>因此，我希望我们将能够帮助覆盖整个软件和硬件领域，组合这些标准的开放工具，包括作为指令集的RISC-V，作为编译器堆栈的MLIR，以及作为关注硬件的应用的CIRCT。我们正在努力推动整个行业更快发展。</p>
<p>总结</p>
<p>最后，我想说现在的确是“编译器的黄金时代”。我认为，随着硬件和软件的协同设计变得更加重要，我们需要比以往更快地推动创新。</p>
<p>编译器、编程语言以及所有的技术，包括形式化方法和提升线性类型的类型系统，以及其他相当好理解的系统，将会使整个领域受益。我认为形式化、工程化以及这个领域的不同部分的合作，都将推动所有事情发展得更快、更进一步。我很高兴看到许多学术界相当知名的方法和技术正在落地。</p>
<p>人们正在试图弄清楚这一点，他们学习新东西，但也在一些愚蠢的问题上翻跟头。现在的情况是，我们看到发展速度加快了，看到了新的创新，对旧事物有新研究，因为人们正在回到第一性原则看问题。我非常高兴和兴奋地看到所发生的这一切。</p>
<p>视频链接：</p>
<p><a href="https://www.youtube.com/watch?v=4HgShra-KnY">https://www.youtube.com/watch?v=4HgShra-KnY</a></p>
]]></content>
      <categories>
        <category>编译器</category>
        <category>LLVM Project</category>
      </categories>
  </entry>
  <entry>
    <title>《提问的智慧》摘抄</title>
    <url>/2018/03/13/%E3%80%8A%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7%E3%80%8B%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<p>作者：Eric Steven Raymond：《How To Ask Questions The Smart Way》<br>版本：3.9<br>修改时间：2013年4月13日<br>翻译：王刚（yafrank at 126 dot com）<br>翻译时间：2010年9月28日<br>王刚翻译版本<br>修改注释：陈锦辉（cnfeat at Gmail dot com）<br>修改注释时间：2014年5月15日<br>注释版本：3.9</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>&emsp;&emsp;在黑客[3]的世界里，你所提技术问题的解答很大程度上取决于你提问的方式与此问题的难度，本文将教你如何提问才更有可能得到满意的答复。</p>
<span id="more"></span>


<p>&emsp;&emsp;开源程序的应用已经很广，你通常可以从其他更有经验的用户而不是黑客那里得到解答。这是好事，因为他们更能够容忍一般的新手错误。但我们还建议你使用我们推荐的方法，像对待黑客那样对待这些有经验的用户，这样，你能最有效地得到问题的回答。<br>&emsp;&emsp;第一件需要明白的事：黑客喜欢艰巨的任务和激发思考的好问题。否则，我们也不会写这篇文章了。如果你有值得我们反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励和馈赠，帮助我们发展认知，揭示没有注意的问题。对于黑客，提供「好问题」就是热情而真诚的赞扬。<br>&emsp;&emsp;虽然如此，黑客在外却有坏名声：遇到简单问题就表现出鄙视或傲慢的姿态。有时，我们看起来还会对新手和愚蠢的人有条件反射般的无礼，但事实并不如此。<br>&emsp;&emsp;我们只是毫无歉意地鄙视那些提问前不愿思考、不做功课的人。这种人就象时间黑洞一样，只知道索取，不愿意付出，他们在浪费我们时间，而这些时间我们本可用于其它更有趣的问题或更值得回答的人身上。我们将这种人叫做 「loser」[4] （由于历史原因，我们有时将「loser」拼写为「lusers」[5]）。<br>&emsp;&emsp;我们注意到很多人只是想使用我们写的软件，对学习技术细节没有任何兴趣。对他们而言，计算机只是种工具，是种达到目的的手段而已。他们有自己的生活，有更重要的事要做，我们承认这一点，也从不指望每个人都能对这些让我们着迷的技术问题感兴趣。所以，我们回答问题也有自己的选择，仅仅回应那些真正对问题有兴趣并愿意主动参与解决问题的人，这一点现在不变，以后不会变，也不该变，否则，我们就无法做好那些该做好的事情了。<br>&emsp;&emsp;我们（大多数）是自愿者，从自己繁忙的生活中抽时间来回答问题，有时也会力不从心。因此，（请原谅）我们会毫不留情地过滤问题，特别是那些像是losers提的问题，这样，我们就有更多的时间和精力去回答那些winner[6]的问题<br>&emsp;&emsp;如果你认为这种态度令人反感、以施惠者自居或傲慢自大，烦请检查你的假设，我们并未要求你崇拜我们，事实上，假如你做了力所能及的努力，我们大多将非常乐意平等地与你交流，并欢迎你接纳我们的文化。我们认为试图去帮助那些不愿自助的人是一件没有效率和效果的事情。所以，我们宁愿被称作傲慢，也不去做愚蠢的事[7]。<br>&emsp;&emsp;所以，你无须拥有很高超技术也可以吸引我们的注意，前提是你必须表现出解决此问题的积极态度：热切关注、深入分析、试图努力查找过解决此问题的方法，并且乐意主动参与到解决问题的组织，分享你的想法。如果你做不到使你与众不同，我们建议你付费寻求他人帮助，而不是要求黑客提供无偿的帮助。<br>&emsp;&emsp;如果你决定向我们求助，不想成为一名loser，或者不想被看成一个lose，我们有一个立竿见影的方法：（1）有技术含量地提问，（2）像是一个有智慧有自信和会思考的人那样去提问，（3）暗示这个提问只是碰巧在特别情况出现的。</p>
<p>【本章注释】</p>
<p>[3]本文不仅仅适用于黑客，而且适用于普通人。黑客的态度：解决问题，建设事物，崇尚自由和无私的双向帮助。出自Eric S. Raymond的另一篇著名文章《How To Become A Hacker》<br>[4]在此，用直接「loser」更加合适，语意浅点译做「失败者」，语意深点译做「废柴」、「贱人」和「窝囊废」。<br>[5]wikipedia的解释：「lusers」为「loser」和「user」的混合词，有贬义，指使人厌烦的，愚蠢的计算机操作员。<br>[6]指乐于分享，懂得专研和回报的人。<br>[7]人必自助而后人助之，而后天助之。出自《周易·系辞上》</p>
<h3 id="提问前需要做的事情"><a href="#提问前需要做的事情" class="headerlink" title="提问前需要做的事情"></a>提问前需要做的事情</h3><p>在通过邮件、讨论组、论坛或社区提问之前，请先尝试做以下事情寻找答案：<br>· 1. 使用论坛、知乎、百度知道、Quaro的搜索功能；<br>· 2. 善用google、百度或其他搜索引擎在网络搜寻；<br>· 3. 阅读说明书或者使用手册；<br>· 4. 阅读网站上「常见问题解答」（FAQ）；<br>· 5. 自己检查或做试验；<br>· 6. 请教熟悉此问题的朋友；<br>· 7. 如果你是程序员，尝试阅读源代码。<br>&emsp;&emsp;提问时，请先表明你已做了上述事情，这将有助于改变你是懒又肥的寄生虫形象，同时给别人一种你不会浪费别人时间的印象。提问时最好再总结一下你从中学到的东西 ，我们喜欢那些善于学习总结的人，也喜欢回答他们提出的问题。<br>&emsp;&emsp;运用搜索策略，比如利用Google搜索时你遇到的各种提示（记得也搜索一下Google groups），这样很可能直接就找到了解决问题的文档或讨论组的相关线索。即使没有结果，在论坛或讨论小组寻求帮助时提一句「我在Google中搜过下列句子，但没有找到什么有用的东西」也是件好事，至少它表明了搜索引擎暂时还不能提供哪些帮助。另外，将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。<br>&emsp;&emsp;耐心一点，不要指望Google搜索几秒钟就能解决一个复杂的问题。读一下与产品或项目相关的常见问题解答。在向专家提问之前，先稍微放松一下，再深入地思考一下问题。相信我们，他们能从你的提问之中看得出你做了多少阅读与思考的准备功课，如果你是有备而来，专家们很有可能会为你解答。如果你第一次搜索没有结果（或者结果太多），也不要抛出一堆问题，专家们更喜欢有针对性的提问。<br>&emsp;&emsp;认真地思考，准备好你的问题。草率的提问只能得到草率的回答，甚至得不到回答。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。<br>&emsp;&emsp;注意别提问错误的问题。如果提问基于错误的假设，某黑客多半会一边想「这真是一个愚蠢的问题」，一边按将错就错地敷衍你，并且希望这个结果能够给你一个教训：如果提问的方式不对，你就得不到正确的答案。<br>&emsp;&emsp;永远不要假设你有资格得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题，你将通过自己的努力「挣到」答案，因为这种提问能够向社区贡献经验，而不仅仅是消极无止境地索取。<br>&emsp;&emsp;另一方面，展现你的能力，并且表明你乐意参与解决问题，这是个很好的开始。「有没有人能指个方向？」，「我这还差点什么？」，「我应该查哪个网站？」，通常要比「请给出我可以用的解决方案」更容易得到回复，因为你的行为表明一种积极的态度：只要有人能为我指明方向，我就会很乐意自己走完剩下的路。</p>
<h3 id="提问时认真选择论坛"><a href="#提问时认真选择论坛" class="headerlink" title="提问时认真选择论坛"></a>提问时认真选择论坛</h3><p>谨慎地要选择提问的地方，如果你做了下述事情，多半会被忽视或被看成loser：</p>
<p>· 1. 张贴与论坛主题无关的问题；</p>
<p>· 2. 在面向高级技术问题的论坛上张贴初级的问题，反之亦然；</p>
<p>· 3. 在不同的论坛或讨论小组同时张贴同一个问题；</p>
<p>· 4. 向非熟人或没有义务解决你问题的人发送私人问题邮件。</p>
<p>&emsp;&emsp;为防止论坛被灌水，黑客们（论坛管理员）会删掉那些与论坛及主题无关的问题，你不想自己的问题被删掉吧。<br>&emsp;&emsp;因此，第一步是找到正确的提问论坛。谷歌和其它搜索引擎是你好帮手，当你遇到问题时，它们可以帮你搜索到与问题最相关的网站或者论坛。那里通常都会有「常见问题解答」（FAQ）、讨论组及文档的链接。如果你的努力（包括阅读 FAQ）都没有结果，这些讨论组就是你最后能取得帮助的地方。这些网站通常会有报告bug（错误）的地方或链接，你可以尝试通过这个方式按照指示反馈信息。<br>&emsp;&emsp;冒昧地向陌生人发送邮件或在不熟悉的论坛发表主题是一件比较「冒险」的事情。你不要天真地以为一个经验丰富的网站架构师会给你提供免费解答，也不要以为你的问题会在论坛中引起巨大反响，除非你很确定这一点，否则还是发送去其他地方去吧，或者最好就别发了。<br>&emsp;&emsp;在选择论坛和讨论组时，不要被他们的名字迷惑了，先看看FAQ或者版规以明确你的问题是否切合这个论坛的风格。发帖之前先翻翻已有的帖子，感受一下论坛的讨论氛围。事实上，善用论坛的搜索功能将会给带来极大的便利，或者这样你就更容易找到答案，即使没有，这也可以让你更好地表述出你的问题。<br>&emsp;&emsp;不要像机关枪似的一次性「扫射」所有的帮助通道，这样的行为像泼妇骂街一样令人抓狂，要有重点地一步一步来。<br>&emsp;&emsp;要搞清楚你提问的主题是什么！最典型的错误就是跑去苹果的论坛问关于Unix或Windows的问题，如果你不明白，最好在搞清楚概念，否则什么也别问。<br>&emsp;&emsp;一般来说，在公共论坛中提问比在封闭论坛中提问更容易得到有用的回答。选择依据：一是评估潜在的回复数较多，二是估算论坛的活跃度较高，相比之下，黑客更喜欢回答那些能启发多数人的问题。<br>&emsp;&emsp;同时，你可以理解，一些经验丰富的黑客和流行软件的作者正在承受过多的非议，因为涌入其私人邮箱的垃圾邮件变得越来越多，他们实在无法忍受，同时，你的加入有可能使情况更加恶劣，就像那根最后压垮骆驼背的稻草一样，所以，一些流行软件的作者正陆续停止对软件的更新和支持。</p>
<h3 id="通过新手论坛和在线客服可获得最快的回复"><a href="#通过新手论坛和在线客服可获得最快的回复" class="headerlink" title="通过新手论坛和在线客服可获得最快的回复"></a>通过新手论坛和在线客服可获得最快的回复</h3><p>&emsp;&emsp;本地发行商会为宣传新产品会专门为新手设置论坛或在线客服（IRC）[8]，这些地方是提问的好地方，特别是当你觉得遇到的是很普通的问题时。通过专门的在线客服或者公开新手提问专区，一般可以得到实时的回复。<br>&emsp;&emsp;事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛中提问，再到程序本身的项目论坛中提问，否则该项目的黑客可能仅仅回复「尝试用我们的代码」来搪塞你。<br>&emsp;&emsp;在任何论坛发帖之前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，这会给你带来帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是应该再搜索一下论坛，搜索引擎有可能还没建立此论坛的内容索引[9]。<br>&emsp;&emsp;目前，通过论坛或在线客服为用户提供帮助已经成为一种趋势，电子邮件交流方式则更多地为项目开发者保留。所以，新手一般建议在通过论坛或在线客服寻求与该项目相关的帮助。</p>
<p>【本章注释】<br>[8]「IRC」全程为Internet Relay Chat，即时聊天工具，在国内常见的是挂在网页内的QQ客服。<br>[9]也有部分论坛会屏蔽来自搜索引擎的爬虫，所以有时候还得在论坛中搜索。</p>
<h3 id="使用项目组的论坛"><a href="#使用项目组的论坛" class="headerlink" title="使用项目组的论坛"></a>使用项目组的论坛</h3><p>&emsp;&emsp;当某个项目组设立有开发者论坛[10]时，要向论坛而不是其中的个人成员提问，即使你确信他能为你提供最好的回答。查看一下项目的说明文件和主页，找到论坛地址并注册使用。采用这种办法有几个很好的理由：</p>
<p>· 1. 如果向个人开发者提的问题足够好，他的回答也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太白痴，这也不能成为骚扰个人开发者的理由。<br>· 2. 向论坛提问可以分散开发者们的负担，个人开发者（尤其是项目领导）也可能太忙，以至于没法回答你的问题。<br>· 3. 大多数论坛记录都会存档，那些存档将会被搜索引擎索引，如果你向论坛递交的提问得到解答，将来其他人可以通过网页搜索找到你的问题和答案，那么他们就不用再次提问了。<br>· 4. 如果某些问题经常被问到，开发者可以利用此信息改进说明文件或软件本身，以使其更清晰明白。如果只是私下提问，就没有人能知道最常见问题是什么，也无法建立一个常见问题解答手册。</p>
<p>&emsp;&emsp;如果一个项目论坛中既有「用户」 也有「开发者」（或 「黑客」，而你又不钻研那些高深代码，那就向「用户」组论坛提问。不要以为自己会在「开发者」论坛中会受到欢迎，那些人只会认为你是一个在装逼的傻逼。<br>&emsp;&emsp;然而，如果你确信你的问题十分特殊，在「用户」组论坛中提问了好几天都没有回复，可以尝试在「开发者」论坛提问。建议你在发帖前最好先潜水一阵以了解那的行事风格（事实上这是参与任何私有或半私有论坛的好主意）。<br>&emsp;&emsp;如果你找不到一个项目组的论坛，只能查到项目维护者的邮箱地址，可以向其发送邮件。但即便在这种情况下，也不要以为这个论坛是不存在的。在电子邮件中你可以陈述你试图寻找这个论坛的事实，告诉维护者也可以转发该邮件到相关的人员手中（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p>
<p>【本章注释】</p>
<p>[10]原文为邮件列表，邮件列表是论坛的初始形态，以前的论坛是以邮件名称作为联系ID交流，所以，在此篇文章中，邮件列表可视作论坛。</p>
<h3 id="使用含义丰富，描述准确的标题"><a href="#使用含义丰富，描述准确的标题" class="headerlink" title="使用含义丰富，描述准确的标题"></a>使用含义丰富，描述准确的标题</h3><p>&emsp;&emsp;请在论坛中用五十个或更少的字来描述你的主题，这是你吸引专家专家注意力的黄金法则，</p>
<p>&emsp;&emsp;精练的标题是你吸引专家注意的黄金机会，别喋喋不休地用诸如「帮帮我」的标题，这种主题只会被条件反射式地删掉，浪费掉一次提问的机会。不要试图用你深深的痛苦来打动我们，相反，要在讨论空间中使用简明扼要语句来描述问题。</p>
<p>&emsp;&emsp;撰写主题的规则是「对象──偏差」式的描述，许多技术支持组织就是这样做的。「对象」部分需要指明是哪一个或哪一组项目有问题，「偏差」部分则描述与期望的行为不一致的地方。</p>
<p>&emsp;&emsp;愚蠢的问题描述：救命啊！我的笔记本播放不了视频！</p>
<p>&emsp;&emsp;明智的问题描述：<a href="http://x.org/">http://X.org</a> 6.8.1 鼠标光标出现偏差，MV1005型号的某显卡芯片组</p>
<p>&emsp;&emsp;更明智的问题描述：使用 MV1005 型号的某显卡芯片组在 <a href="http://x.org/">http://X.org</a> 6.8.1 的鼠标光标出现偏差</p>
<p>&emsp;&emsp;撰写「对象──偏差」式的主题描述有助于引发你对问题的细致思考：是什么导致了这个问题？仅仅是鼠标光标出问题或者还有其它原因？只在<a href="http://X.org中出现抑或是在6.8.1的版本中？是针对某显卡芯片组还是或者只是其中的">http://X.org中出现抑或是在6.8.1的版本中？是针对某显卡芯片组还是或者只是其中的</a> MV1005 型号？一个黑客只需瞄一眼就能够立即知道你遇到的什么问题和解决方案。</p>
<p>&emsp;&emsp;为了方便索引查找，你需要正确地用标题来描述你的问题，以便下一个搜索类似主题的人能够迅速定位到你的答案中来，无须再发帖提问。</p>
<p>&emsp;&emsp;如果你想在回复中提问，请修改主题名称，以注明你是在问一个问题，例如「Re: 测试」或者「Re: 新bug反馈」这样的信息就不能引起足够的注意，同时，请注意删除与新主题无关的引用内容。</p>
<p>&emsp;&emsp;对于论坛消息，请不要直接点击回复（按钮）来开始一个全新的主题索引，这将限制主题的参与者。例如有些论坛允许隐藏消息，如果你这样做的话，别人就永远看不到你发的消息了。</p>
<p>&emsp;&emsp;有时候，仅仅改变标题还不够。其他的一些论坛还会检查你论坛主题的其他信息，以便为其提供索引，所以这时候宁可重新发一新帖。</p>
<p>&emsp;&emsp;成熟的论坛有一套完善的讨论规则，参与者发送的信息与特定的主题紧密结合，所以通过回复来提问也未尝不可。但并不是所有论坛都允许在回复中出现分支的主题，这样做的结果就是基本上没有人会去看[11]，而且通过回复来继续提问是一种成效较低的做法，因为它们只会被正在查看该主题的人看到。所以，除非你只想向当前活跃的人群中提问，否则还是另发新帖比较好。</p>
<p>【本章注释】</p>
<p>[10]论坛中经常会出现灌水或者是版聊的情况，一大群人一个主题下你谈你的我谈我的，原主题容易就会被冲散。</p>
<h3 id="让回答来得更简便一点"><a href="#让回答来得更简便一点" class="headerlink" title="让回答来得更简便一点"></a>让回答来得更简便一点</h3><p>&emsp;&emsp;用「请将回答发送到……」这样的方式来提问会使你的问题得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都嫌麻烦，我们也懒得花几秒钟去考虑你的问题。如果你的邮件客户端程序不支持设置，请换一个；如果你的操作系统不支持这种邮件客户端程序，也请换一个。</p>
<p>&emsp;&emsp;实际上，在论坛中，要求回答者通过电子邮件回复你的提问是粗暴无礼的，除非你确定他回复的比较敏感或涉及隐私的（现在的论坛也可以设置「私人可见」的回复）。如果你只是想在有人回复主题时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如「留意本主题」、「有回复发送邮件」等功能[12]。</p>
<p>【本章注释】</p>
<p>[12]实际上，目前中国的论坛已很少使用邮件通知回复，只有少数索取资料的主题要求留些邮箱发送而已，大部分的论坛已采用消息提醒的方式来显示回复。</p>
<h3 id="用字义清晰、语法标准、拼写正确的语句撰写问题"><a href="#用字义清晰、语法标准、拼写正确的语句撰写问题" class="headerlink" title="用字义清晰、语法标准、拼写正确的语句撰写问题"></a>用字义清晰、语法标准、拼写正确的语句撰写问题</h3><p>&emsp;&emsp;经验告诉我们，粗心草率的人通常也会粗心草率地思考与编程。回答这些粗心草率者的提问没有什么好处，我们宁可将时间花在其他地方。</p>
<p>&emsp;&emsp;清楚、正确地表达你的问题非常重要。如果你嫌斟字酌句麻烦，那我们也懒得回复。所以，请稍微花一点点时间组织语言，也用不着太正式和死板──事实上，黑客文化提倡使用非正式词句、网络语言和幽默的语句，同时注意在遣词造句的过程中体现文字的准确性和你思考问题的积极性。</p>
<p>&emsp;&emsp;正确地拼写、使用标点和大小写，不要将「its」混淆为「it’s」，「loose」搞成「lose」或者将「discrete」弄成 「discreet」。不要全部用大写，这会被视为粗鲁无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox[13]也许可以这样做，但你不行。）</p>
<p>&emsp;&emsp;一般来说，如果你像个半文盲般来提问，你多半会被无视。也不要使用短信中的简写，如将「you」简化为「u」，这会让你看起来像偷懒的傻逼。更有甚者像个小孩似地用火星文来提问，那就绝对是在找死，真的是喊破喉咙也没有人来理你（或者会有人在围观，并给你一大堆指责与挖苦）。</p>
<p>&emsp;&emsp;如果你在非母语（中文）的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上懒惰（没错，我们能看得出其中的差别）。同时，除非你知道回复者们使用的语言，否则请使用英语书写。如果你用黑客看不懂的语言发送提问，繁忙的黑客一般会直接无视并立即除。英语是互联网上的通用语言，用英语书写可以避免你的问题被直接无视。</p>
<p>&emsp;&emsp;如果你要用英文作为第二语言来提问，你可以使用以下的语句来进行说明，降低回答者对你语言使用的不适感：</p>
<p>· 1. English is not my native language; please excuse typing errors.</p>
<p>· 2. If you speak $LANGUAGE, please email&#x2F;PM me; I may need assistance translating my question.</p>
<p>· 3. I am familiar with the technical terms, but some slang expressions and idioms are difficult for me.</p>
<p>· 4. I’ve posted my question in $LANGUAGE and English. I’ll be glad to translate responses, if you only use one or the other.</p>
<p>【本章注释】</p>
<p>[13]Alan Cox：著名黑客，Linux 内核的重要参与者</p>
<h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>本章阅读提示[14]。</p>
<p>如果你将问题搞得复制难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p>
<p>· 1. 使用纯文本而不是HTML格式；</p>
<p>· 2. 发送邮件时如有附件，记得添加附件，同时记得检查附件内容是否能正常打开；</p>
<p>· 3. 不要发送整段的文字，尝试将文字按主题分段；</p>
<p>· 4. 发送数据时应该发送原始数据，让回复者看到的东西与你看到的一样；</p>
<p>· 5. 很多邮件程序并不支持「Quoted-Printable」MIME编码，所以谨慎使用；</p>
<p>· 6. 不要指望黑客们阅读封闭格式的文档，诸如微软公司的Word或Excel文件等。大多数黑客讨厌这种文件格式。即使他们能够处理，也很厌恶这么做；</p>
<p>· 7. 如果你用Windows操作系统发送电子邮件，关闭微软的「引用」功能，以免在你的邮件中出现乱码；</p>
<p>· 8. 切勿在在论坛勿滥用「表情符号」和「HTML」功能。使用一两个表情符号还可以，但使用过多的花哨彩色文本会使人认为你无法表达出你的意思。过滥地使用表情符号、色彩和字体会让看起来更傻逼；</p>
<p>&emsp;&emsp;如果你是使用图形界面的邮件客户端程序(如腾讯的Foxmail、微软公司的Outlook)，注意它们的默认配置不一定满足以上的这些要求。不过大多数这类程序有「查看源码」的命令，可以用它来检查发件箱的消息，确保发送的是没有乱码的纯文本文件。</p>
<p>【本章注释】</p>
<p>[14]在本章中作者使用大量的计算机术语，我已尽量简化处理，同时，我认为以上的方法并不适合大多数的提问者，所以我在此总结一下适合普通用户的文件格式：</p>
<p>· 1. Txt：直接粘贴，方便阅读；</p>
<p>· 2. Pdf：文件规范，推荐使用；</p>
<p>· 3. Doc：使用广泛，打开方便；</p>
<p>· 4. Md：Markdown文本，未来趋势。</p>
<p>邮件送发建议使用网页端，邮件客户端推荐使用Outlook2013或Foxmail 7。</p>
<h3 id="准确简练地描述问题"><a href="#准确简练地描述问题" class="headerlink" title="准确简练地描述问题"></a>准确简练地描述问题</h3><p>问题的描述应该包含以下内容：</p>
<p>· 1. 清晰的细节；</p>
<p>· 2. 问题发生的环境(主机品牌、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：「Fedora Core 7」、「Slackware 9.1」等）；</p>
<p>· 3. 提问前做过的调查研究及对其的理解；</p>
<p>· 4. 提问前为确定问题而采取的诊断步骤；</p>
<p>· 5. 最近对计算机或软件配置的任何相关改变；</p>
<p>· 6. 如果可能，提供在可控环境下重现问题的方法；</p>
<p>&emsp;&emsp;做大的努力预测黑客会提到的问题，并提前备好答案。</p>
<p>&emsp;&emsp;如果你认为是代码有问题，在可控环境下重现问题，并向黑客提供报告，这个的方法尤其重要。当你这么做时，你大有可能获得及时而有效的回复。</p>
<p>&emsp;&emsp;西蒙.泰瑟姆（Simon Tatham）曾写过一篇《如何有效报告bug》的文章，我强烈推荐各位阅读。<br>&emsp;&emsp;话不在多，精炼最好</p>
<p>&emsp;&emsp;你应该精炼且简要地描述问题，简单地将堆砌代码或罗列数据是没有用的。如果你有一个体积庞大且复杂的测试样本，尝试将其裁剪，越小越好。</p>
<p>&emsp;&emsp;至少有三个理由支持以上这点。第一，让别人看到你在努力简化问题的过程，这会使你更有可能得到回复。第二，简化的问题更容易得到回复。第三，在简化的过程中，你有可能自己就找到了解决办法。<br>&emsp;&emsp;别急于宣称找到bug</p>
<p>&emsp;&emsp;当你在一个软件中遇到问题时，除非你非常、非常的有根据，否则不要动辄声称找到了bug。提示：除非你能提供解决问题的源代码补丁，或者在前一版本的回归测试收集了足够的证据，否则你都不能够完全确信。对于网页和文档也如此，如果你声称发现了文档的「bug」，你应该提供可以替代的解决方案。</p>
<p>&emsp;&emsp;记住，还有许多用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时早应该发现了（疑问：你在报怨前已经搜索过了，是吧？）。这也意味着很有可能是你弄错了，而不是软件本身有问题。</p>
<p>&emsp;&emsp;编写软件的人总会非常努力地优化修正这个软件。所以，如果你声称找到了bug，这是对他们能力的质疑，即使你是对的，也有可能会使某些人人感到不爽。此外，在标题中寻找「bug」也是相当不厚道的行为。</p>
<p>&emsp;&emsp;即使你私下已经非常确信发现一个真正的bug，你在提交问题时最好也写得像是你做错了什么。这样，如果是真有bug，你会在回复中获知，同时，维护者会向你道歉，这总比你无心破坏而欠下一个道歉要好。<br>跪求也不能解决问题</p>
<p>&emsp;&emsp;有些人明白不应该采用粗鲁或傲慢的方式提问并要求得到答复，所以他们走了另一个极端，转而低声下气地哀求：「我知道我只是个可怜的菜鸟，一个loser，但……」。这种对实际问题含糊的描述特别令人反感，不但困扰，也没有用。</p>
<p>&emsp;&emsp;别用低级灵长类动物的老办法浪费时间，相反，尽可能清楚地描述背景情况和你的问题，这比摆出卑贱态度更有用，同时这也是对自己的重新定位。</p>
<p>&emsp;&emsp;有的论坛专门设置了新手提问区，如果你真的认为遇到了新手该遇到的问题，直接到那去提问就好，别再跪求了。<br>描述症状，不做猜测</p>
<p>&emsp;&emsp;向黑客陈述你的猜测是没有用的（如果你的诊断理论真的那么有用，你还会向别人求助吗？）。所以，你只需要告诉他们问题的原始状态，而不是你的解释和理论，让他们来解释和诊断。如果你真的认为自己的猜测很重要，那么你就应该清楚地说明这只是你的猜测，并解释为什么不起作用。</p>
<p>&emsp;&emsp;愚蠢的提问：我在编译内核时接连遇到SIG11错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？</p>
<p>&emsp;&emsp;明智的提问：我组装的电脑（K6&#x2F;233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机20分钟左右、做内核编译时频繁地报错，提示SIG11 ，但在头20分钟内从不出问题。重启动不会复位时钟，但会整夜关机。更换所有内存未解决问题，相关的典型编译会话日志附后。</p>
<p>&emsp;&emsp;鉴于不是每个人都不能做到明智的提问，所以这里有一句话可以给到你启示：「所有的诊断专家都来自密苏里州」。美国国务院的官方座右铭则是「让我看看」（Show me）[15]，对回复者而言，这并不是质疑，而只是一种真实而有用的需求，以便让他们看到与你看到一样的原始证据，目睹尽可能一致的东西，而不是你的片面的猜测与总结。（所以）让我们看看（Show me）。</p>
<p>【本章注释】</p>
<p>[15]「让我看看」出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：「我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。」大意是我不相信别人的描述，我只相信我眼前的事实。</p>
<h3 id="按时间顺序描述问题症状"><a href="#按时间顺序描述问题症状" class="headerlink" title="按时间顺序描述问题症状"></a>按时间顺序描述问题症状</h3><p>&emsp;&emsp;解决问题最有效的线索就是问题之前发生的情况。所以，在问题描述汇中应准确地记录你、电脑和软件在崩溃前的情况。在命令行处理的情况下，对话日志（如运行脚本工具生成的）的记录会非常有帮助。</p>
<p>&emsp;&emsp;如果崩溃的程序有诊断选项，试着选择能在能生成排错日志的选项。记住，「多」不等于「好」。试着选取适当的排错级别，以便提供有用的信息。</p>
<p>&emsp;&emsp;如果你的问题记录很长（如超过四段），在开头简述问题，随后按时间先后描述详细过程也许更有用。这样黑客在阅读你的记录时就知道该注意哪些内容了。<br>描述目标而不是过程</p>
<p>&emsp;&emsp;如果你想知道如何做某事（而不是报告一个bug），你需要在开头就表明你的目标，然后再陈述你遇到问题。</p>
<p>&emsp;&emsp;经常出现这种一种情况：寻求技术帮助的人在脑中里有个更高层次的目标，他们自以为按自己的路走能达成目的，但在中途却被卡住了，又跑来问该怎么走，他们从来没有意识到这条路本身有问题，所以他们往往更折腾才能达成目的</p>
<p>&emsp;&emsp;愚蠢的提问：我怎样才能让某图形程序的颜色拾取器取得十六进制的RGB值？</p>
<p>&emsp;&emsp;明智的提问：我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的RGB值。</p>
<p>&emsp;&emsp;第二种提法是明智的，它会获得更合适的回答：建议采用更合适的工具来完成任务。</p>
<h3 id="不要请求私下回复"><a href="#不要请求私下回复" class="headerlink" title="不要请求私下回复"></a>不要请求私下回复</h3><p>&emsp;&emsp;黑客们认为问题的解决过程应该公开、透明，这样就会有更多的人参与到此问题的解决，如果有知识渊博，经验更丰富的人发现了这个问题，他们就会留意到回答中不完整或不准确的地方，那么原来的回答就会被纠正修复。同时，这些人的能力和学识也会被其他同行看到而得到赏识。</p>
<p>&emsp;&emsp;而当你要求私下回复时，以上的纠正过程就会被中止，所以，不要请求私下回复，要让回复者来决定是否私下回复。实际上，如果他真的私下回复你了，通常是因为他认为问题太差或者太肤浅，自己给出的答案对其它人也毫无意义，那就发给你吧。</p>
<p>&emsp;&emsp;这条规则也有一个例外，如果你确定该提问可能会带来大量雷同的回复时，那么你可以主动表示：「请向我发电子邮件，我将为论坛统一归纳这些回复」。你这个举动是非常值得赞扬的，因为你将论坛从洪水般雷同的回复中解救出来。最后，最重要的一点，你必须言出必行。</p>
<h3 id="精准地提问"><a href="#精准地提问" class="headerlink" title="精准地提问"></a>精准地提问</h3><p>&emsp;&emsp;漫无边际的问题通常被视为时间黑洞，回答这些问题需要付出更多的时间和精力，只有最忙的人才会给你最有用答案，但这些人对于时间黑洞极其敏感，所以他们比较讨厌那些漫无边际的问题。</p>
<p>&emsp;&emsp;如果你明确指认了让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力去解决问题，并间接地设定了他们为帮助你需要花费的时间和精力上限，这是很好的做法。</p>
<p>&emsp;&emsp;如果你想要向专家提问，你可以这样设想：你去到一个金库，可是你只有一点点的时间。专家就像金库，如果你想在尽可能短的时间来换取更多的价值，你就要向他们提出一个精准的问题。</p>
<p>&emsp;&emsp;所以，为了让专家能够用尽量少的时间来回答你的问题，你最好限定问题的范围。限定问题范围与简化问题是不一样的。举个例，「请问可否指点一下哪有好一点关于X的解释？」通常就要比「请解释一下X」来得明智。再譬如，如果你的代码运行不了，「请别人看看哪有问题」就比「叫他们帮你改正」更加明智。<br>如何提问关于代码的问题</p>
<p>&emsp;&emsp;不要直接要求别人给你修正代码，而应该提问如何入手解决这个问题，如果你一上来就一段几百行的代码，说你这里有bug提示出错，你能帮我找出来吗？这样的请求只会被直接无视，而如果你精简代码，明确地描述问题：在第七行以后，本应该显示，但实际出现的是，如何处理？这样就大大提高问题被回答的几率。</p>
<p>&emsp;&emsp;最精确描述代码问题的方法是提供一个能展现问题的最小测试样本。什么是最小测试样本？它是可以集中展现问题，只需要能够刚好重现问题的代码即可。如何生成一个最小测试样本？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样本（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源代码并去除那些与问题无关的代码段。你能提供的最小测试样例本越小越好（参见《浓缩精华》这一章节 ）。</p>
<p>&emsp;&emsp;用最小测试样本去测试bug也并不是万能的，但这毕竟是一个很好的尝试，这有助于帮助你独立去解决问题，即使你找不到，黑客们也喜欢看到曾经你努力过，这将使他们跟你合作去解决这个问题。</p>
<p>&emsp;&emsp;如果你只是想让别人帮忙审核一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。<br>不要提问「家庭作业式」的问题</p>
<p>&emsp;&emsp;黑客们擅长发现「家庭作业式」[16]的问题。家庭作业要求独立完成，因为这是你该做的，这样你才能从中学到东西，遇到困惑的时候可以要去给一点提示，但是千万不要要求给出完整的答案。</p>
<p>&emsp;&emsp;如果你怀疑自己碰到了一个「家庭作业式」的问题，自己尝试过但仍然无法解决，可以试试在用户组、论坛或（作为最后一招）中提问。在那里，黑客们会留意到你的问题，一些老用户也许会给你提示。</p>
<p>【本章注释】</p>
<p>[16]「家庭作业式」的问题：在学习者眼中的复杂问题，在专家眼中的简单问题，基础式问题。</p>
<h3 id="删除无意义的疑问"><a href="#删除无意义的疑问" class="headerlink" title="删除无意义的疑问"></a>删除无意义的疑问</h3><p>&emsp;&emsp;有的人喜欢在求助信息的末尾加上「有人能帮我吗？」或者「有没有答案？」这一类无意义的提问，应该在提问中尽量删除这些废话，理由如下：第一，如果问题本身描述的不完整，这些附加的东西就是废话。第二，因为它们提问的方式不对，黑客们会认为这些东西很烦，很有可能就会用逻辑上无误回复来敷衍你，诸如「是的，你可以得到帮助」和「不好意思，没有人能帮你」。</p>
<p>&emsp;&emsp;一般来说，避免提「是或非」问题，除非你想得到「是或非」回答。</p>
<h3 id="不要把问题标记为「紧急」，即使你真的很紧急"><a href="#不要把问题标记为「紧急」，即使你真的很紧急" class="headerlink" title="不要把问题标记为「紧急」，即使你真的很紧急"></a>不要把问题标记为「紧急」，即使你真的很紧急</h3><p>&emsp;&emsp;「紧急」只是你的「紧急」，跟我们无关。同时，这些动辄「紧急」的提问往往欲速而不达，而且多数会被黑客们删掉，因为他们认为这是一种自私与鲁莽的提问方式：企图通过文字的简单修饰来引起别人注意而获得特殊的关照。</p>
<p>&emsp;&emsp;当然也有例外，如果你在知名度很高使用某些程序出现问题，你的提问很有可能让黑客们兴奋，在这种情况下，如果你有时间压力，并且很有礼貌地提出请求，黑客们会有兴趣尽快地回复你。</p>
<p>&emsp;&emsp;不过需要注意的一点是：这样提问是非常冒险的，因为黑客兴奋的标准和你的不同。譬如发个主题关于「国际空间站」帖子就可以得到关注，但是如果转发关于慈善或政治的帖子就几乎没人理你。再如「紧急：帮我救救这个毛绒绒的小海豹！」这样帖子在专业技术论坛让黑客看到了肯定会相当抓狂，即使他们认为拯救毛绒绒的小海豹很重要。</p>
<p>&emsp;&emsp;如果你觉得以上的解释难以理解，把剩下的内容多读几遍，直到弄懂了再发帖也不迟。</p>
<h3 id="谦逊没害，而且有益"><a href="#谦逊没害，而且有益" class="headerlink" title="谦逊没害，而且有益"></a>谦逊没害，而且有益</h3><p>&emsp;&emsp;礼貌一点，使用「请」和「谢谢你的关注」或者「谢谢你的帮助」，让别人明白你的真诚，让他们觉得这样无偿的帮助你是值得的。</p>
<p>&emsp;&emsp;坦白讲，对黑客而言，在提问中使用正确的语法、清晰的文字、准确的内容，标准的格式远比使用礼节重要。黑客们一般宁可看文字锋利直白但技术鲜明的bug报告，也不要看那种彬彬有礼有礼但内容空洞含糊其辞的报告。（如果你不明黑客们为什么喜欢这样，那么你就要明白：黑客评价一个提问价值的标准在于这个问题能给他带来什么样的成长。）</p>
<p>&emsp;&emsp;然而，如果你已经清楚地描述了一个问题，客气礼貌一点肯定会增加你得到回复的机会。</p>
<p>&emsp;&emsp;（本文曾受到一些老黑客的指责，这也是本文的唯一受指责的地方，所以我们必须指出，我们曾经推荐使用「提前谢了」的感谢方式，这种感谢方式在一些黑客看来有一种事后不用再感谢任何人暗示和过河拆桥的味道，所以，我们现在的建议是：一、先说「提前谢了」，事后再表示对回复者的感谢；二、换一种表达方式，譬如用「谢谢你的关注」或「谢谢你的帮助」等。）</p>
<h3 id="问题解决后，追加简短说明"><a href="#问题解决后，追加简短说明" class="headerlink" title="问题解决后，追加简短说明"></a>问题解决后，追加简短说明</h3><p>&emsp;&emsp;在问题解决后向所有帮助过的人回复一条信息，让他们知道问题是如何解决的并再次感谢。如果问题在论坛中受到广泛关注，在那里追加此信息比较恰当。</p>
<p>&emsp;&emsp;最理想的方式是向最初提问的主题中回复此消息，并在主题中注明「已解决」、「已搞定」或其它同等含义的字样[17]。这样，在信息快速流动的论坛中，一个注明「已解决」或「已搞定」的主题就会让别人节省很多时间，回复者不用再点进去重复回复（除非他觉得这个问题值得再商榷），因此他就可以用这些时间去解决其他问题。</p>
<p>&emsp;&emsp;追加的信息无须太冗厂繁复，一句简单的「你好，问题已解决，是网线坏了！谢谢大家──比尔」就比什么都没有要好。事实上，除非解决问题的过程很复杂，需要用得很高深的技术，否则就用一条简短亲切的总结来回复就好了，总结中说明用了什么方法，解决了什么问题，无需将整个解决问题的过程给写下来。</p>
<p>&emsp;&emsp;对于有深度的问题，建议给出一份完整解决该问题的方案，方案包括：问题的最终状态、用了什么方法、列出具体的步骤和和易出错的地方，这样才可以给到后来者一个完整的指引，注意不要将此方案搞成什么侦探推理小说。最后列出那些帮助过你的人的名字，那样你有可能会交到朋友。</p>
<p>&emsp;&emsp;这种后续的跟进信息不仅是礼貌的回复，而且是内容的分享，因为这些后续的解决方案会帮助其他有同样问题的人，他们会在论坛中找到你的解决方案，并因此受益。</p>
<p>&emsp;&emsp;最后，此类后续的信息跟进还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题的不了了之总会令人沮丧，但黑客们有强迫症，总渴望它们被解决，你的后续跟进就像是为他们消灭了一个眼中钉，并因此获得了一定的信誉的威望，这对你的下次提问非常有帮助。</p>
<p>&emsp;&emsp;考虑到将来也会有人面临类似的问题，如何避免重蹈覆辙呢？你可以自己写一篇文章或者对FAQ进行补充，然后发给项目的维护者。</p>
<p>&emsp;&emsp;在黑客交流的过程中，这种良好的后续跟踪行为比传统的礼貌更重要，这也是你善待他人赢得声誉的方式，这是非常有价值的经验和财富。</p>
<p>【本章注释】</p>
<p>[17]在国内论坛，问题解决之后，可以主动修改论坛主题，添加上「已解决」字样，然后通知版主做出处理。</p>
<h3 id="如何解读回答"><a href="#如何解读回答" class="headerlink" title="如何解读回答"></a>如何解读回答</h3><p>&emsp;&emsp;RTFM[18]和STFW[19]：你为什么不去试一试？</p>
<p>&emsp;&emsp;有一个古老而神圣的惯例：如果你收到RTFM的回复，你就应该去「Read The Fucking Manual」，他说得对，去读一下吧。</p>
<p>&emsp;&emsp;「Read The Fucking Manual」（RTFM）有个年轻点的亲戚，如果你收到「Search The Fucking Web」（STFW）的回复，你也应该去「Search The Fucking Web」，他说得也对，去去搜一下吧。(更温和一点的说法是「善用Google」)</p>
<p>&emsp;&emsp;在论坛，你也可能被要求去搜索论坛的存档记录。事实上，有人甚至可能热心到为你提供以前解决此问题的线索。但千万不要依赖这种帮助，你应该在提问前搜索一下存档。</p>
<p>&emsp;&emsp;通常的情况是，要求你主动去搜索的人已经打开了能解决你问题的手册或网页，他那时可能是一边在看屏幕一边敲着键盘回复「RTFM」或「STFW」，这些回复意味着：第一，你要的信息很容易找到。第二，自己动手，丰衣足食。</p>
<p>&emsp;&emsp;这不是一种是鄙视，按黑客的标准，回复者没有不理你，反而在耐心地回复你，这是对你提问的尊敬，你应该感谢他还像一个老奶奶一样唠唠叨叨地回复你。</p>
<p>【本章注释】</p>
<p>[18]RTFM，是一个英文缩写，意思是：「去读那些他妈的手册」（Read The Fucking Manual），这句话通常用在回复那些只要查阅文件就可以解决，拿出来提问只是浪费别人时间的问题.</p>
<p>[19]STFW：Search The Fucking Web，去搜那些他妈的网站，语意同RTFM。</p>
<h3 id="如果还不明白……"><a href="#如果还不明白……" class="headerlink" title="如果还不明白……"></a>如果还不明白……</h3><p>&emsp;&emsp;如果你看不懂回答，不要马上发帖要求别人进行解释说明，你应该回过头去看看你提问时候试用过的工具（如手册、FAQ、网页、行业内朋友等），如果检查过后，你发现还是需要解释说明，你就要将已学的东西展现出来。</p>
<p>&emsp;&emsp;譬如，我告诉你：「看起来像是输入项有问题，你需要清除它」，接着是个不好的回帖示范：「什么是输入项？」（因为你没有主动在搜索引擎中搜查什么是输入项）。而以下就是一个很好的跟帖：「是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？」<br>对待无礼</p>
<p>&emsp;&emsp;很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服。</p>
<p>&emsp;&emsp;如果你觉得被冒犯了，试着平静地对待。如果有人真的做了过分的事，论坛中的老前辈会教训他。如果这些没有发生而你却恼火了，那么这些致使你恼火的言语可能在黑客社区中看来是正常的，而你将被视为有错的一方，这会让你丧失进一步获得信息或帮助的机会。</p>
<p>&emsp;&emsp;另一方面，如果你真的偶然地遇到了无礼和无聊的冲撞，你就要对真正的冒犯者予以狠狠的反击了，用犀利的语言将其驳得体无完肤都是可以接受的，然而，在行事之前一定要有非常肯定的证据。因为纠正无礼的言论与一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况也屡见不鲜。新手可能难免中枪。但如果你想得到的是信息和帮助，就不要浪费时间参与到口水战之中。</p>
<p>&emsp;&emsp;（有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症[20]，缺少用于润滑人类社会「正常」社交所需的人脑回路。这既可能是真也可能是假。如果你不是黑客，也许你会认为我们脑袋有问题，以为还能帮助我们纠正那些古怪行为。如果你真的以为这么做会有效，你就只管这么做好了，我们不在乎。我们就喜欢现在这个样子，因我们会对那些所谓的「诊断」拥有正常的科学的健康的怀疑精神。</p>
<p>&emsp;&emsp;在下一节，我们会谈到另一个主题，当你犯错遭受到的指责该怎么办。</p>
<p>【本章注释】</p>
<p>20、阿斯伯格综合症，是一种泛自闭症障碍，其重要特征是社交困难，伴随着兴趣狭隘及重复特定行为，但相较于其他泛自闭症障碍，仍相对保有语言及认知发展。</p>
<h3 id="不要像-loser-那样去行事"><a href="#不要像-loser-那样去行事" class="headerlink" title="不要像 loser 那样去行事"></a>不要像 loser 那样去行事</h3><p>&emsp;&emsp;常在河边走，哪有不湿鞋。在黑客论坛混，总有有犯错的时候，你的错误会被别人长篇大论的公开地揭露，或许在言语之中还会透露着鄙视和得意。</p>
<p>&emsp;&emsp;事后你能做的最坏的事莫过于哀怨你的遭遇、四处哭喊着被人诽谤、要求道歉、竭斯底里的呼喊、忍隐不做声、威胁诉诸法律、向他公司投诉、忘了关马桶盖等等，但实际上，以下的的几件事才是你应该去做的：</p>
<p>&emsp;&emsp;就让它这样过去，这是一件很正常的事情。事实上，这样的被人指出错误也没什么大不了，对自己反而是好事。</p>
<p>&emsp;&emsp;论坛社区的规则不会自行运转，它们是只能通过参与者通过积极公开的方式来执行维持。不要哭诉着要求将所有的批评和指责通过私下的邮件传达，这不是行之有效的运作方式，当有人在评论你的一个说法有误或者提出不同看法时，你坚持声称受到人身攻击，这也是没用的，这也是loser对待事情的态度。</p>
<p>&emsp;&emsp;也有一些黑客论坛愚蠢地执行过「高礼节要求」的规则，禁止参与者公开发表任何对别人观点挑错的文章，并发出「如果你不想帮助用户就闭嘴」的言论，结果造成大批有思想的参与者逃离此论坛，这个论坛就变成了一个毫无意义，絮絮叨叨，没有价值的技术论坛。</p>
<p>&emsp;&emsp;是要夸张的不切实际的「友好」还是坦诚直白的「实用」？你自己挑一个吧。</p>
<p>&emsp;&emsp;记着：当黑客说你犯错了，并且(无论说得多么尖锐地)告诉你别再这样做时，这表明他在为关心你和这个社区。对他而言，无视并拉黑要容易得多，如果你无法做到感谢，至少要有点自尊，别大声哀怨，别以一个敏感而莽撞的新手自居，更别指望别人能像对待一个波大无脑的女人一样去抚慰你。</p>
<p>&emsp;&emsp;有时候，即使你没有犯错（或者只是别人的臆想），有些人也会以莫须有的名义来指责你。在这种情况下，你的报怨倒是真的会把事情弄得更糟。</p>
<p>&emsp;&emsp;这些无事生非的人其实也没有多大的能耐，不是在吹牛逼的专家，就是一天到晚在唱反调的心理预测专家。总有读者有能力分辨，并想办法去对付他们，这些人在玩火自焚，你就不用操心了。</p>
<p>&emsp;&emsp;如果你在网络上不得不要面对一场争论，你得首先去确认一下自己是否犯错，如果你没有犯错，那么你就可以断定这是一场无聊的口水战，不要将自己卷入口水战之中，也最好不要理睬其他与你无关的口水战，因为这样争论不会有一个明确的结果。<br>三思而后问</p>
<p>下面是些典型的愚蠢问题和黑客不回答它们的原因和想法。</p>
<p>· 问：1、我到哪可以找到某程序或X资源？</p>
<p>· 问：2、我怎样用X做Y？</p>
<p>· 问：3、如何配置我的shell提示？</p>
<p>· 问：4、我可以用Bass-o-matic文件转换工具将AcmeCorp文档转为TeX格式吗？</p>
<p>· 问：5、我的{程序、配置、SQL 语句}不运行了。</p>
<p>· 问：6、我的Windows系统出问题了，你能帮个忙吗？</p>
<p>· 问：7、我的程序运行不了，我认为是系统工具X有问题。</p>
<p>· 问：8、我在安装Linux或X是遇到困难，你能帮个忙吗？</p>
<p>· 问：9、我如何才能破解超级用户口令&#x2F;盗取操作员的特权&#x2F;查看某人的电子邮件？</p>
<p>问：1、我到哪可以找到某程序或X资源？</p>
<p>答： 在我找到的地方啊，笨蛋！──你就不会在网页找么，真抓狂，难道还有人不知道如何使用Google吗？</p>
<p>问：2、我怎样用X做Y？</p>
<p>答：如果你想得出Y的结果，那么请不要在想得出Y的结果前提供X的方法，这样的问题表明提问者不但对X完全无知，也对Y了解不深，这个问题还表明提问者已经被某种思维定势禁锢住了，最好让他们将问题整理好再来提问。</p>
<p>问：3、如何配置我的shell提示？</p>
<p>答：如果你有足够的智慧提这个问题，你也该有足够的智慧去「Read The Fucking Manual」（RTFM），然后自己去找出来。</p>
<p>问：4、我可以用Bass-o-matic文件转换工具将AcmeCorp文档转为TeX格式吗？</p>
<p>答： 试试就知道了。如果你试过，你既知道答案，又不用浪费我的时间。</p>
<p>问：5、我的{程序、配置、SQL 语句}不运行了。</p>
<p>答： 这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：</p>
<p>· 你还有什么补充吗？</p>
<p>· oh，太可惜了，希望你能搞定。</p>
<p>· 这跟我有什么关系？</p>
<p>问：6、我的Window系统出问题了，你能帮个忙吗？</p>
<p>答：可以，将Windows系统给卸了，装个开源操作系统，例如Linux或BSD[21]。</p>
<p>注意：你可以问与Windows系统相关的问题，前提是这个程序有Windows的官方版，不是我对Windows系统有偏见，而是Windows系统与大部分的软件存在兼容问题，而实际上Windows系统实在很差。</p>
<p>问：7、我的程序运行不了，我认为是系统工具X有问题。</p>
<p>答：这个程序被成千上万用户反复使用，你有可能是第一个提出这个程序有缺陷的人，不过你得要拿出具体的证明，最后有一份详细清晰的缺陷说明。</p>
<p>问：8、我在安装Linux或X是遇到困难，你能帮个忙吗？</p>
<p>答：不好意思，我帮不了你，我需要亲手操作你的电脑才能帮你排错，去向当地的Linux论坛寻求帮助吧。</p>
<p>注意：如果安装问题与某Linux发行版有关，请首先在论坛中提问。同时，应准确描述问题的细节。在此之前，先用 「linux」和所有被怀疑出问题的硬件 [作关键词] 仔细搜索。</p>
<p>问：9、我如何才能破解超级用户口令&#x2F;盗取操作员的特权&#x2F;查看某人的电子邮件？</p>
<p>答：想做这种事情说明你是个人品恶劣的家伙，想让黑客教你做这种事情说明你是个傻逼。</p>
<p>【本章注释】</p>
<p>21、这个回答可以视为一句吐槽，也可以视为一个建议，毕竟大多数黑客都是使用开源系统的。</p>
<h3 id="好问题与坏问题"><a href="#好问题与坏问题" class="headerlink" title="好问题与坏问题"></a>好问题与坏问题</h3><p>最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。</p>
<p>愚蠢：我在哪能找到关于Foonly Flurbamatic设备的东西？</p>
<p>这个问题在请求一个「Search The Fucking Web」（STFW） 式的回复。</p>
<p>明智：我用谷歌搜索过「Foonly Flurbamatic 2600」，但没有找到什么有用的信息，有谁知道在哪能找到这种设备的编程信息吗？</p>
<p>这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。</p>
<p>愚蠢：我不能编译某项目的源代码，它为什么这么烂？</p>
<p>提问者预提了一个假设：是别人搞砸了，太狂妄自大了。</p>
<p>明智：某项目的源代码不能在某Linux 6.2版下编译。我读了常见问题文档，但其中没有与某Linux相关的内容。这是编译时的记录，我做错了什么吗？</p>
<p>提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，值得留意一下。</p>
<p>愚蠢：我的主板有问题，谁能帮我？</p>
<p>某黑客管理员对此的反应可能是：「是的，还需要帮你拍背和换尿布吗？」，然后是敲下删除键。</p>
<p>明智：我在S2464主板上试过X、Y和Z方法，当它们都失败后，又试了A、B和C方法。注意我试C时的奇怪症状，显然某某东西正在做某某事情，这并不是正常的现象。通常在Athlon MP主板上导致某某事情的原因是什么？有谁知道我还能再尝试什么方法以确定问题？</p>
<p>相反地，这个人的问题看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。</p>
<p>&emsp;&emsp;在最后那个问题中，注意「给我一个答案」与「请帮我看看我还能再做点什么测试以得到启发」之间细微但重要的差别。</p>
<p>&emsp;&emsp;事实上，最后那个问题基本上源于2001年8月Linux内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现Tyan S2462主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。</p>
<p>&emsp;&emsp;通过这种提问方式，我给了别人可以深思玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。</p>
<p>&emsp;&emsp;事后，当我感谢大家并评论这次良好的经历时，一个Linux内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。</p>
<p>&emsp;&emsp;黑客们在某种层面上貌似是非常冷漠无情的精英分子。我想在这事上他是对的，如果我表现得像个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。<br>如果得不到回答</p>
<p>&emsp;&emsp;如果得不到回答，请不要认为我们不想帮你，有时的确是因为被问到的小组成员不知道答案。没有回复不等于不被无视，当然，必须承认从外部很难看出两者的差别。</p>
<p>&emsp;&emsp;一般而言，不要在再重复发表这个问题，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。</p>
<p>&emsp;&emsp;还有其它信息源可以寻求帮助，例如一些面向新手的资源区。</p>
<p>&emsp;&emsp;有许多在线与本地的用户组织，虽然他们自己不编写任何软件，但是他们对软件很忠诚热心。这些用户组通常因互助和帮助新手而形成。</p>
<p>&emsp;&emsp;还有众多大小商业公司提供签约支持服务（红帽与SpikeSource是两家最出名的，还有许多其它的）。别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧坏了，你还是得花钱找个修理店把它弄好。同理，即使软件没花你一分钱，你总不能指望他的服务支持都是免费的。</p>
<p>&emsp;&emsp;像Linux这样流行的软件，每个开发版至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。<br>如何更好地回答</p>
<p>&emsp;&emsp;态度和善一点。问题带来的压力常使人显得无礼或愚蠢，即使你平时不是这样的。</p>
<p>&emsp;&emsp;对初犯错者私下回复。对那些无心犯错之人也没有必要当众羞辱，一个真正的新手也许连怎么搜索或者连FAQ在哪都不知道。</p>
<p>&emsp;&emsp;如果你对某样事物不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p>
<p>&emsp;&emsp;如果你帮不了忙，也不要帮倒忙。不要在具体步骤上开玩笑，有些可怜的新手会把它当成真的指令，那样也许会毁了用户的安装进程。</p>
<p>&emsp;&emsp;探索性的疑问可以引出更多的细节。如果你问题问得好，你也可以学到点东西。试试将很差的问题转变成好问题，别忘了我们曾经都是新手。</p>
<p>&emsp;&emsp;尽管对那些懒人敷衍一句「Read The Fucking Manual」（RTFM）是正当的，但是指出文档的位置（或者给出一个搜索关键词）会更好</p>
<p>&emsp;&emsp;如果你决定回答一个问题，请尽可能详尽地提供一个好答案。当别人正在用错误的工具或方法时，别给出一个权宜之计，应推荐一个更好的工具，重新组织这个问题。</p>
<p>&emsp;&emsp;提供一个可操作的回答建议！如果回答者已经详细地研究过问题，并且已经测试过X、 Y, Z, A、B、和C方法，均没有得出一个满意的结果，这表明简单地回复「请尝试X或者Y方法」或提供一个链接是没有用的，你要给出一个可操作的详细的操作步骤。</p>
<p>&emsp;&emsp;让你所在的社区或论坛也从学习中获益。当回复一个好问题时，问问自己「如何修改相关文件或FAQ文档以免再次解答同样的问题？」，接着再向社区或论坛维护者发一份补充说明。</p>
<p>&emsp;&emsp;如果你的答案是在研究一番后得出的，请展现你的解题技巧而不是直接端出结果，毕竟「授人以鱼，不如授人以渔」。</p>
<h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><p>&emsp;&emsp;如果需要个人电脑、Unix和互联网如何工作的基础知识，参阅Unix和互联网工作的基本原理。</p>
<p>&emsp;&emsp;当你发布软件或补丁，试着按软件发布实践手册操作。</p>
<h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>&emsp;&emsp;Evelyn Mitchell贡献了一些愚蠢问题例子并启发了我编写「如何更好地回答问题」这一章节 Mikhail Ramendik贡献了一些特别有价值的建议和改进意见。<br>附：知乎对「如何提问题？」的答案总结</p>
<p>· 1. 认真：认真对待你的提问，就像你希望别人认真回答你的问题一样。</p>
<p>· 2. 先搜索：确保你提了一个新问题，而不是别人问过的重复问题（解决办法：提问之前先搜索）。</p>
<p>· 3. 具体：让你的问题处于具体的环境中，避免大而空洞、需要具体情况来分析、或别人难以读懂的问题。</p>
<p>· 4. 解决办法：将问题阐述清楚，尽可能将问题的「补充说明」写清楚。</p>
<p>· 5. 书写：正确地使用标点符号和英文大小写，没有错别字。</p>
<p>· 6. 添加话题：给问题添加合适的相关话题。</p>
<p>· 7. 邀请回答：使用右侧的「站内邀请」，邀请专业的人来回答。</p>
<p>· 8. 在问题中避免出现绝对性词汇。很多问题你认为是这样但事实并不如此。eg. 为什么画的画画得再像也一眼能看出来不是照的相？</p>
<p>· 9. 避免在问题中加上自己对答案非专业或非正确的猜想。<br>我们若能更妥善地搜寻资料，实在已经改变世界。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
</search>
